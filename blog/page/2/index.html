
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <title>破狼 Blog</title>
    <meta name="author" content="破 狼"> 
    <meta name="description" content="前后端分离 按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识。所谓的前后端分离，并不是传统行业中的按部门划分，一部分人只做前端（HTML/CSS/JavaScript等等），另一部分人只做后端（或者叫服务端），因为这种方式是不工作的：比如很多团队采取了后端的模板技术（JSP &hellip;"> 
    <!-- http://t.co/dKP3o1e -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1"> 
    <link rel="canonical" href="http://greengerong.github.io/blog/page/2">
    <link href="/favicon.png" rel="icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/atom.xml" rel="alternate" title="破狼 Blog" type="application/atom+xml">
    <script src="/javascripts/modernizr-2.0.js"></script>
    <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
    <script>
    !window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))
    </script>
    <script src="/javascripts/octopress.js" type="text/javascript"></script>
    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
 

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">破狼 Blog</a></h1>
  
    <h2>Write less got more.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:greengerong.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/29/swagger-qian-hou-duan-fen-chi-hou-de-qi-yue/">Swagger - 前后端分离后的契约</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-29T10:39:02+08:00" pubdate data-updated="true">Jul 29<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/07/29/swagger-qian-hou-duan-fen-chi-hou-de-qi-yue/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/07/29/swagger-qian-hou-duan-fen-chi-hou-de-qi-yue/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>前后端分离</h3>

<p>按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识。所谓的前后端分离，并不是传统行业中的按部门划分，一部分人只做前端（HTML/CSS/JavaScript等等），另一部分人只做后端（或者叫服务端），因为这种方式是不工作的：比如很多团队采取了后端的模板技术（JSP, FreeMarker, ERB等等），前端的开发和调试需要一个后台Web容器的支持，从而无法将前后端开发和部署做到真正的分离。</p>

<p>通常，前后端分别有着自己的开发流程，构建工具，测试等。做前端的谁也不会想要用Maven或者Gradle作为构建工具，同样的道理，做后端的谁也不会想要用Grunt或者Gulp作为构建工具。前后端仅仅通过接口来协作，这个接口可能是JSON格式的RESTFul的接口，也可能是XML的，重点是后台只负责数据的提供和计算，而完全不处理展现。而前端则负责拿到数据，组织数据并展现的工作。这样结构清晰，关注点分离，前后端会变得相对独立并松耦合。但是这种想法依然还是很理想化，前后端集成往往还是一个很头痛的问题。比如在最后需要集成的时候，我们才发现最开始商量好的数据结构发生了变化，而且这种变化往往是在所难免的，这样就会增加大量的集成时间。</p>

<p>归根结底，还是前端或者后端感知到变化的时间周期太长，不能“及时协商，尽早解决”，最终导致集中爆发。怎么解决这个问题呢？我们需要提前协商好一些契约，并将这些契约作为可以被测试的中间产品，然后前后端都通过自动化测试来检验这些契约，一旦契约发生变化，测试就会失败。这样，每个失败的测试都会驱动双方再次协商，有效的缩短了反馈周期，并且降低集成风险。具体的实践方式，请参加我同事的一篇博文，“前后端分离了，然后呢？”<a href="http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/">http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/</a>。</p>

<p>不过，仅仅靠纪律是不够的，还需要通过工具的辅助来提高效率。下面，我们就来看一下，一个API设计工具——Swagger，将如何帮助我们更好的实现“前后端分离”。</p>

<h3>Swagger</h3>

<p>Swagger包括库、编辑器、代码生成器等很多部分，这里我们主要讲一下Swagger Editor。这是一个完全开源的项目，并且它也是一个基于Angular的成功案例，我们可以下载源码并自己部署它，也可以修改它或集成到我们自己的软件中。</p>

<p>在Swagger Editor中，我们可以基于YAML语法定义我们的RESTful API，然后它会自动生成一篇排版优美的API文档，并且提供实时预览。相信大多数朋友都遇到过这样一个场景：明明调用的是之前约定好的API，拿到的结果却不是想要的。可能因为是有人修改了API的接口，却忘了更新文档；或者是文档更新的不及时；又或者是文档写的有歧义，大家的理解各不相同。总之，让API文档总是与API定义同步更新，是一件非常有价值的事。下面我们通过一个例子来感受一下Swagger给我们带来的好处。</p>

<p>首先我们需要安装一个Swagger Editor，或者也可以直接使用在线版本<a href="http://editor.swagger.io/">http://editor.swagger.io/</a>。如果需要在本地启动编辑器，执行以下三行命令即可（前提是已经安装好了Node.js）：</p>

<pre class='green'><code>git clone https://github.com/swagger-api/swagger-editor.git
cd swagger-editor
npm start
</code></pre>

<p>当我们修改了API的定义之后，在编辑器右侧就可以看到相应的API文档了，而且永远是最新的。</p>

<p><img src="/images/blog_img/SwaggerEditor.png" alt="Swagger editor" /></p>

<p>不仅如此，它还能够自动生成Mock server所需要的代码，这样一来前端开发就再也不用等着后端API
的实现了。除此之外，它还有一个更强大的功能，甚至能够帮助我们自动生成不同语言的客户端的代码。Swagger是基于插件来实现各种不同的语言的，所以，如果已经提供的语言中没有你正在用的，你也可以自己实现相应的插件，甚至是从源代码级别进行定制化。</p>

<p><img src="/images/blog_img/SwaggerGenerateClient.png" alt="Swagger generate client" /></p>

<h3>契约测试</h3>

<p>谈到了前后端分离，那么在所难免，会遇到一些集成的问题：一拨人在全心全意的进行前端开发，另一拨人在心无旁骛的做后端开发，那么谁应该为集成买单呢？在现在这个持续集成、持续交付的年代里，我们应该如何去保证双方不会分道扬镳、越走越远呢？</p>

<p>所以，在一开始就定一个契约就成了迫在眉睫的事情，双方就API相关的内容，包括路径、参数、类型等达成一致，当然，这份契约并不是一旦创建就不能修改的，而且，如果一开始没有设计好，很有可能会频繁的修改。这个时候，要让双方都能够实时的跟踪最新的API就成了一个难题。还好，在总结了前人的经验和教训之后，我们早已有了应对之策，那就是<code>契约测试</code>。</p>

<p>老马（Martin Fowler）早在2011年的时候就发表了一篇博客<a href="http://martinfowler.com/bliki/IntegrationContractTest.html">http://martinfowler.com/bliki/IntegrationContractTest.html</a>，专门讨论了如何做契约测试。</p>

<p>首先，我们先假设我们已经有了一份契约，可能是基于JSON格式的，有可能是基于XML格式的，这都不重要。然后，前端会根据这份契约建立一个Mock server，所有的测试都发往这个Mock server。有两方面的原因：一是这个时候可能后台的API还没有开发完成；二是有可能因为网络等其他方面的原因导致直接调用真实的后台API会很不稳定或者很耗时。到这里，可能有人就要说了，如果后台的API实现和之前约定的并不一样，怎么能保证到了集成的时候双方还能很顺利的集成呢？其实这个问题并不难，只需要让前端的测试定期连接真实的API执行一遍就能尽早的发现差异性。比方说，在我们平常的build pipeline上添加一个job，让这些测试每天在午夜里连着真实的API执行。如果，第二天发现这些测试有的失败了，那么就需要和开发后台API的人员进行一次沟通了，很有可能由于真实的业务逻辑发生了变化，API在实现的时候，已经和之前的契约不一致了，如果是这样，那么相应的测试和契约定义就需要更新以满足最新的业务需求。</p>

<p>总之，进行契约测试的目的就是尽早的发现差异性，并作出调整，将最后集成的风险降到最低。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/26/tsd-ti-sheng-ni-de-idedui-javascriptzhi-neng-gan-zhi-de-neng-li/">tsd-提升IDE对JavaScript智能感知的能力</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-26T00:55:31+08:00" pubdate data-updated="true">Jul 26<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/07/26/tsd-ti-sheng-ni-de-idedui-javascriptzhi-neng-gan-zhi-de-neng-li/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/07/26/tsd-ti-sheng-ni-de-idedui-javascriptzhi-neng-gan-zhi-de-neng-li/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在编写前端JavaScript代码时，最痛苦的莫过于代码的智能感知（Intelli Sense）。</p>

<p>追其根源，是因为JavaScript是一门弱类型的动态语言。对于弱类型的动态语言来说，智能感知就是IDE工具的一个“软肋”。IntelliJ等IDE所用智能感知方式，是一种折中的方式：全文搜索，然后展示出已经使用过的对象成员。这种方式的缺点是，其智能感知的的能力并不精准，经常会显示出很多无关的代码提示。</p>

<p>在很多现代化开发方式中，IDE的强大支持和模块化组织这种“工程化”的思想是我们应对大规模开发的方式之一，这也已经被业界所认同。所以在最近两年，JavaScript的世界也提出了大规模开发的方案，其中有Google的Dart和微软的TypeScript。随着Angular2.0放弃了自家的Dart，而选择了TypeScript，也标志着TypeScript的逐渐成熟。TypeScript是微软总架构师Anders Hejlsberg设计的新语言，他是软件界的传奇人物，是Delphi和.NET的设计者。TypeScript是一种可以编译成传统JavaScript的语言，它并不是完全的创造了一门新语言，而TypeScript是JavaScript语言的超集，它最大的特点就是引入了类型系统。并在编译为JavaScript文件后，可以输出“.ts”的类型元数据信息，为我们IDE的智能感知和重构提供了重要的依据。</p>

<p>关于TypeScript的更多知识，在这里笔者就不在叙述过多。有兴趣的读者可以到<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>学习，本节要讲的，是它的另一个特性：它编译输出的元数据信息文件（<code>*.d.ts</code>），它可以在不需要修改原有JavaScript文件的情况下，而给JavaScript添加元数据类型信息，而这些类型信息则可以辅助IDE，给出有智能的提示信息，以及重构的依据。</p>

<p>在TypeScript的开源社区，已经为很多的第三方库实现了这类模板文件，我们可以很快的应用在我们的项目之中。当然这里所说的额第三方包含我们常用的：Angular、jQuery、underscore、lodash、jasmine等。</p>

<p>在官方同时也为我们提供了一个方便的工具叫TSD（全称为：TypeScript Definition manager for DefinitelyTyped），它是借鉴NPM包管理工具的思想，实现了一个类似的包管理工具，我们不需要任何的学习成本，只管像使用NPM一样使用它。</p>

<p>这里是TSD主页:<a href="http://definitelytyped.org/tsd/">http://definitelytyped.org/tsd/</a>，你可以在这里深入了解它，或者是查询你所需要的模板库是否存在于TSD仓库。</p>

<p>TSD也是一个Nodejs的工具，所以我们安装它非常容易，只需要在命令行中输入（对于有些Linux用户需要sudo）：</p>

<pre class='green'><code>npm install tsd -g
</code></pre>

<p>安装我们需要的模板库，也很简单，如jQuery和Angular的安装：</p>

<pre class='green'><code>tsd install jquery angular --save
</code></pre>

<p>这样TSD就会帮助我们下载jQuery和Angular的d.ts文件，并存放在当前目录的typings独立子目录下，并且它会将我们需要的依赖信息保存在一个叫tsd.json的文件，如NPM的package.json一样，方便于我们的版本管理，以及团队之间的共享。我们只需要共享这个tsd.json文件给其他同事，然后</p>

<pre class='green'><code>tsd install
</code></pre>

<p>一切都可以满意就绪了。</p>

<p>tsd.json文件的格式如下：</p>

<p><img src="/images/blog_img/tsd-install.png" alt="tsd文件目录" /></p>

<p>同时候TSD工具还会为我们在typing目录下生产一个tsd.d.ts文件，它会为我们引入这些模板文件，使得IDE能够识别出这样模板文件：</p>

<pre class='green'><code>/// &lt;reference path="angularjs/angular.d.ts" /&gt;
/// &lt;reference path="jquery/jquery.d.ts" /&gt;
</code></pre>

<p>下面是我们在Intellij中得到的智能感知图：</p>

<p><img src="/images/blog_img/tsd-intellij-%E6%99%BA%E8%83%BD%E6%84%9F%E5%BA%94.png" alt="tsd智能感应" /></p>

<p>目前能够很好支持TypeScript这一特性的工具有：Intellij家族、微软自家的VS工具、Sublime。有了TSD这一工具，也许我们虽然还不能尝试TypeScript的特性，但我们仍然可以利用它来帮助我们的普通JavaScript开发。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/25/tui-jian-shu-ji-yi-dong-appce-shi-de-22tiao-jun-gui/">推荐书籍 -《移动App测试的22条军规》</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-25T01:29:56+08:00" pubdate data-updated="true">Jul 25<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/07/25/tui-jian-shu-ji-yi-dong-appce-shi-de-22tiao-jun-gui/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/07/25/tui-jian-shu-ji-yi-dong-appce-shi-de-22tiao-jun-gui/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在今天的博文中，博主希望给大家分享一本博主同事黄勇的最新利作：《移动App测试的22条军规》。黄勇是ThoughtWorks资深敏捷QA和咨询师。对于我来说，和黄勇在一起的工作的这个项目，是我至今所一直怀念的那种少有的项目。黄勇在团队中以资深QA的团队协调能力和专业技能，不仅保障了项目的交付质量，同时也能很好的协调从客户到开发中的各个环节。</p>

<h4>移动互联网的兴起</h4>

<p>在当今世界，移动互联网已经兴起了，它距离我们大家，已经不再那么遥远了，已经开始慢慢的融入了我们的生活之中。特别在最近两年，BAT这等巨头在移动互联网的扩张和斗争层起不穷，微信和支付宝的市场之战，滴滴、快滴、Uber的快速崛起，我们的生活也被些日星月异的移动App所改变。</p>

<p>特别在今年笔者的感触比较深，笔者维护着国内Angular中文社区群。某一天，作为日常惯例上线QQ群，为大家解决一些技术问题。当我帮助某某同学解决完他的问题的时候，突然，他向我发起私聊窗口，问笔者要支付宝账号，希望给笔者支付宝红包来感谢笔者的帮助。不禁的深叹：我们的消费观念已经改变了，我们开始选择了移动互联网，开始接受了网上消费。到这里这件事还没有完成，随后笔者将此感触消息发到了自己朋友圈。在满是“赞”的同时，笔者也陆续收到总共32元人民币的红包，都是为了感谢笔者“双狼说”的文章或者是平时的技术帮助。再次不禁的感慨万千：移动互联网已经来到了我们的身边，并且也在改变着我们的生活！世界这么大，移动互联网就在你身边。</p>

<p><img src="/images/blog_img/%E4%BA%92%E8%81%94%E7%BD%91%E6%B6%88%E8%B4%B9%E8%A7%82%E5%BF%B5%E7%9A%84%E6%94%B9%E5%8F%98.jpg" alt="互联网消费观念的改变" /></p>

<h4>《这是一个属于移动App开发者的时代》</h4>

<p>下面是摘自同事《移动App测试的22条军规》中：来自Testin云测 联合创始人、CEO 王军的书序《这是一个属于移动App开发者的时代》：</p>

<p>一年前，当我陪同Google董事会主席施密特先生在中关村海龙市场考察时，面对蓬勃发展的移动互联网和不确定的未来格局，施密特说到“移动App开发者将是未来的核心”。回想移动互联网的发展不过只有几年的历史，但以移动App为核心的创新正在影响着我们的现在，并且改变人类的未来。</p>

<p>人们的吃、喝、购物、旅游、用车、医疗健康的方方面面，我们花的每一分钱，可能都会跟移动App有关。虽然现阶段移动互联网和传统经济仅仅结合更于紧密的是移动游戏、电商、O2O，但随着技术的进步、创业者的创新，移动互联网与传统经济的接触将更为紧密，可穿戴、医疗、支付或者是所有的钱包。人类经济发展到现在位置，GDP或者是实体经济，是围绕着过去的现金和信用卡而支撑的体系，如果现金、信用卡被移动App颠覆了，我们所有的一切未来只是一个ID，只是手机上一个App，那这个信托责任是多么的巨大。伴随着传统互联网的发展，过去几十年在传统的IT建设上投资的钱，已经不是千万美金、数亿美金来算，是一个庞大的固定资产，而APP开发者三年前可能还是一个屌丝，就是无业的，或者是刚进校门的，可能几年之后就成长为一个承担人们数亿、数十亿资产管理的平台。作为软件，App不存在bug是不可能的，开发者的责任就是要在App发布前竭尽所能进行全面的测试，发现App是否存在隐患，判断支付的时候会不会崩溃，确保用户体验至少是可以接受的，还有没有让用户使用不爽的地方，这是App开发者必须承担的责任。</p>

<p>历史上第一个”Bug”诞生至今已有70年，期间经历了第三次工业革命、信息革命。现在，移动互联网已经无所不在。软件测试的重要性随着信息技术的发展，越来越被人们重视。功能测试、性能测试、压力测试、安全测试、用户体验测试，许多的专业词汇涌现出来。</p>

<p>测试在云端？移动App爆发所带来的碎片化困扰着开发者，于是我们在2011年创立了专门向移动App开发者提供云测试和质量管理的服务平台Testin云测，把传统的测试从本地搬到了云端。开发者在App中集成专用的测试SDK，一旦用户使用App时发生崩溃。SDK会把崩溃的堆栈信息，App版本等信息上报到云端。堆栈信息能够定位到出现崩溃的文件、类名、函数名、代码行，开发者在云端根据崩溃的堆栈信息能够快速定位并修复问题。</p>

<p>移动App测试的重要性？移动互联网的产品讲究的快，产品开发也是快速迭代的模式。我们很难像传统测试那样花费半年或者几个月的时间去测试整个系统。那云端测试恰好就帮助我们在既保证产品快速发布的情况下，又能够把控好产品的质量。开发者可以在完成基础的测试工作后将产品发布市场，一方面通过市场完善产品的能力；一方面在用户使用的过程中收集并修复产品的Bug，类如微信就经常进行灰度发布。</p>

<p>移动App测试的难度？云端测试一直以来存在几个难题：1、各类App或游戏的开发语言不统一，收集用户的崩溃信息较难；1、上报的堆栈信息因混淆或者语言本身因数，内容辨识度较低，很难定位问题；3、信息量太大，没有很好的去重。经过多年发展，崩溃分析用户性能管理能够跨平台支撑Cocos2d-x、Unity3d引擎，Java、C、C++、Objective-C、JavaScript、Lua、C#等不同编程语言。崩溃的堆栈信息更是通过符号化能力，清晰地将不可读的内容符号为出现崩溃的文件、类名、函数名、代码行。同一崩溃的去重是提高开发者工作效率的重要因素，通过对不同崩溃堆栈直接函数的调用关系判断及每日过亿条崩溃数据的分析。崩溃分析SDK不断总结、优化自身的去重算法。举个例子，一个崩溃可能在1万个用户终端出现过。云端可以判断出是同一块代码导致的，这种场景在传统测试中很难去分析。</p>

<p>如今，移动App的开发者越来越多，开发工具、引擎的发展迭代也在加快，App开发极为快速，而成本却在逐步降低。但移动App作为软件，传统的软件工程测试方法与质量体系，在飞速增长的移动App开发模式和生态体系中很难有效地发挥作用，《移动App测试的22条军规》的实战建议实用、简明、有效，将帮助开发者在激烈竞争的环境下能够脱颖而出，能更好地创新并快速发展。</p>

<h4>《移动App测试的22条军规》</h4>

<p>本书的在线购买或试读地址为：<a href="http://item.m.jd.com/ware/view.action?wareId=11730286&amp;from=timeline&amp;isappinstalled=0">http://item.m.jd.com/ware/view.action?wareId=11730286&amp;from=timeline&amp;isappinstalled=0</a></p>

<p><img src="http://img11.360buyimg.com/n1/jfs/t1615/101/742241908/97316/39b2b3e/55a8c17eNcf6e3c5b.jpg" alt="http://img11.360buyimg.com/n1/jfs/t1615/101/742241908/97316/39b2b3e/55a8c17eNcf6e3c5b.jpg" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/06/angular-modulesheng-ming-huo-qu-zhong-zai/">Angular Module声明和获取重载</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-06T08:30:33+08:00" pubdate data-updated="true">Jul 6<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/07/06/angular-modulesheng-ming-huo-qu-zhong-zai/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/07/06/angular-modulesheng-ming-huo-qu-zhong-zai/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>module是angular中重要的模块组织方式，它提供了将一组内聚的业务组件（controller、service、filter、directive&hellip;）封装在一起的能力。这样做可以将代码按照业务领域问题分module的封装，然后利用module的依赖注入其关联的模块内容，使得我们能够更好的”分离关注点“，达到更好的”高内聚低耦合“。”高内聚低耦合“是来自面向对象设计原则。内聚是指模块或者对象内部的完整性，一组紧密联系的逻辑应该被封装在同一模块、对象等代码单元中，而不是分散在各处；耦合则指模块、对象等代码单元之间的依赖程度，如果一个模块的修改，会影响到另一个模块，则说明这两模块之间是相互依赖紧耦合的。</p>

<p>同时module也是我们angular代码的入口，首先需要声明module，然后才能定义angular中的其他组件元素，如controller、service、filter、directive、config代码块、run代码块等。</p>

<p>关于module的定义为：angular.module(&lsquo;com.ngbook.demo&rsquo;, [])。关于module函数可以传递3个参数，它们分别为：</p>

<ol>
<li>name：模块定义的名称，它应该是一个唯一的必选参数，它会在后边被其他模块注入或者是在ngAPP指令中声明应用程序主模块；</li>
<li>requires：模块的依赖，它是声明本模块需要依赖的其他模块的参数。特别注意：如果在这里没有声明模块的依赖，则我们是无法在模块中使用依赖模块的任何组件的；它是个可选参数。</li>
<li>configFn： 模块的启动配置函数，在angular config阶段会调用该函数，对模块中的组件进行实例化对象实例之前的特定配置，如我们常见的对$routeProvider配置应用程序的路由信息。它等同于”module.config“函数，建议用”module.config“函数替换它。这也是个可选参数。</li>
</ol>


<p>对于angular.module方法，我们常用的方式有有种，分别为angular.module(&lsquo;com.ngbook.demo&rsquo;, [可选依赖])和angular.module(&lsquo;com.ngbook.demo&rsquo;)。请注意它是完全不同的方式，一个是声明创建module，而另外一个则是获取已经声明了的module。在应用程序中，对module的声明应该有且只有一次；对于获取module，则可以有多次。推荐将angular组件独立分离在不同的文件中，module文件中声明module，其他组件则引入module，需要注意的是在打包或者script方式引入的时候，我们需要首先加载module声明文件，然后才能加载其他组件模块。</p>

<p>在angular中文社区群中，有时会听见某些同学问关于”ng:areq“的错误：</p>

<pre class='green'><code> [ng:areq] Argument 'DemoCtrl' is not a function, got undefined！
</code></pre>

<p>这往往是因为忘记定义controller或者是声明了多次module，多次声明module会导致前边的module定义信息被清空，所以程序就会找不到已定义的组件。这我们也能从angular源码中了解到（来自loader.js）：</p>

<pre class='green'><code>function setupModuleLoader(window) {
            ...
            function ensure(obj, name, factory) {
                return obj[name] || (obj[name] = factory());
            }
            var angular = ensure(window, 'angular', Object);
            return ensure(angular, 'module', function() {
                var modules = {};
                return function module(name, requires, configFn) {
                    var assertNotHasOwnProperty = function(name, context) {
                        if (name === 'hasOwnProperty') {
                            throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
                        }
                    };

                    assertNotHasOwnProperty(name, 'module');
                    if (requires &amp;&amp; modules.hasOwnProperty(name)) {
                        modules[name] = null;
                    }
                    return ensure(modules, name, function() {
                        if (!requires) {
                            throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
                                "the module name or forgot to load it. If registering a module ensure that you " +
                                "specify the dependencies as the second argument.", name);
                        }
                        var invokeQueue = [];
                        var runBlocks = [];
                        var config = invokeLater('$injector', 'invoke');
                        var moduleInstance = {
                            _invokeQueue: invokeQueue,
                            _runBlocks: runBlocks,
                            requires: requires,
                            name: name,
                            provider: invokeLater('$provide', 'provider'),
                            factory: invokeLater('$provide', 'factory'),
                            service: invokeLater('$provide', 'service'),
                            value: invokeLater('$provide', 'value'),
                            constant: invokeLater('$provide', 'constant', 'unshift'),
                            animation: invokeLater('$animateProvider', 'register'),
                            filter: invokeLater('$filterProvider', 'register'),
                            controller: invokeLater('$controllerProvider', 'register'),
                            directive: invokeLater('$compileProvider', 'directive'),
                            config: config,
                            run: function(block) {
                                runBlocks.push(block);
                                return this;
                            }
                        };
                        if (configFn) {
                            config(configFn);
                        }
                        return moduleInstance;

                        function invokeLater(provider, method, insertMethod) {
                            return function() {
                                invokeQueue[insertMethod || 'push']([provider, method, arguments]);
                                return moduleInstance;
                            };
                        }
                    });
                };
            });
        }
</code></pre>

<p>在代码中，我们能了解到angular在启动时，会设置全局的angular对象，然后在angular对象上发布module这个API。关于module API代码，能清晰的看见第一行谓语句，module名称不能以hasOwnProperty命名，否则会抛出”badname“的错误信息。紧接着，如果传入了name参数，其表示是声明module，则会删除已有的module信息，将其置为null。</p>

<p>从moduleInstance的定义，我们能够看出，angular.module为我们公开的API有：<em>invokeQueue、</em>runBlocks、requires、name、provider、factory、servic、value、constant、animation、filter、controller、directive、config、run。其中<em>invokeQueue和</em>runBlocks是按名约定的私有属性，请不要随意使用，其他API都是我们常用的angular组件定义方法，从invokeLater代码中能看到这类angular组件定义的返回依然是moduleInstance实例，这就形成了流畅API，推荐使用链式定义这些组件，而不是声明一个全局的module变量。</p>

<p>最后，如果传入了第三个参数configFn，则会将它配置到config信息中，当angular进入config阶段时，它们将会依次执行，进行对angular应用或者angular组件如service等的实例化前的配置。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/30/dong-tai-bang-ding-html/">动态绑定HTML</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-06-30T06:38:36+08:00" pubdate data-updated="true">Jun 30<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/06/30/dong-tai-bang-ding-html/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/06/30/dong-tai-bang-ding-html/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在Web前端开发中，我们经常会遇见需要动态的将一些来自后端或者是动态拼接的HTML字符串绑定到页面DOM显示，特别是在内容管理系统（CMS：是Content Management System的缩写），这样的需求，更是遍地皆是。</p>

<p>对于对angular的读者肯定首先会想到ngBindHtml，对,angular为我们提供了这个指令来动态绑定HTML，它会将计算出来的表达式结果用innerHTML绑定到DOM。但是，问题并不是这么简单。在Web安全中XSS（Cross-site scripting，脚本注入攻击），它是在Web应用程序中很典型的计算机安全漏洞。XSS攻击指的是通过对网页注入可执行客户端代码且成功地被浏览器执行，来达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可能会获取到用户的一些敏感信息、改变用户的体验、诱导用户等非法行为，有时XSS攻击还会合其他攻击方式同时实施比如SQL注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨大的，也是web安全的头号大敌。更多的Web安全问题，请参考wiki <a href="https://en.wikipedia.org/wiki/Cross-site_scripting%E3%80%82">https://en.wikipedia.org/wiki/Cross-site_scripting%E3%80%82</a></p>

<p>在angular中默认是不相信添加的HTML内容，对于添加的HTML内容，首先必须利用$sce.trustAsHtml，告诉angular这是可信的HTML内容。否则你将会得到$sce:unsafe的异常错误。</p>

<pre class='green'><code>Error: [$sce:unsafe] Attempting to use an unsafe value in a safe context.
</code></pre>

<p>下面是一个绑定简单的angular链接的demo：</p>

<p>HTML：</p>

<pre class='green'><code>&lt;div ng-controller="DemoCtrl as demo"&gt;
    &lt;div ng-bind-html="demo.html"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>JavaScript：</p>

<pre class='green'><code>angular.module("com.ngbook.demo", [])
    .controller("DemoCtrl", ["$sce", function($sce) {
        var vm = this;

        var html = '&lt;p&gt;hello &lt;a href="https://angular.io/"&gt;angular&lt;/a&gt;&lt;/p&gt;';
        vm.html = $sce.trustAsHtml(html);

        return vm;
    }]);
</code></pre>

<p>对于简单的静态HTML，这个问题就解决了。但对于复杂的HTML，这里的复杂是指带有angular表达式、指令的HTML模板，对于它们来说，我们不仅希望绑定大DOM显示，同时还希望得到angular强大的双向绑定机制。ngBindHhtml并不会和$scope关联双向绑定，如果在HTML中存在ngClick、ngHref、ngSHow、ngHide等angular指令，它们并不会被compile，点击这些按钮，也不会发生任何反应，绑定的表达式也不会在更新。例如尝试将上次的链接变为：ng-href=&ldquo;demo.link&#8221;，链接并不会被解析，在DOM看见的仍然会是原样的HTML字符串。</p>

<p>在angular中的所有指令要生效，都需要经过compile，在compile中包含了pre-link和post-link，连接上特定行为，才能工作。大部分情况下compile，是会在angular启动时，自动compile的。但如果是对于动态添加的模板，则需要手动的compile。angular中为我们提供了$compile服务来实现这一功能。下面是一个比较通用的compile例子：</p>

<p>HTML：</p>

<pre class='green'><code>&lt;body ng-controller="DemoCtrl as demo"&gt;
    &lt;dy-compile html="{{demo.html}}"&gt; 
    &lt;/dy-compile&gt;
    &lt;button ng-click="demo.change();"&gt;change&lt;/button&gt;
&lt;/body&gt;
</code></pre>

<p>JavaScript：</p>

<pre class='green'><code>angular.module("com.ngbook.demo", [])
    .directive("dyCompile", ["$compile", function($compile) {
        return {
            replace: true,
            restrict: 'EA',
            link: function(scope, elm, iAttrs) {
                var DUMMY_SCOPE = {
                        $destroy: angular.noop
                    },
                    root = elm,
                    childScope,
                    destroyChildScope = function() {
                        (childScope || DUMMY_SCOPE).$destroy();
                    };

                iAttrs.$observe("html", function(html) {
                    if (html) {
                        destroyChildScope();
                        childScope = scope.$new(false);
                        var content = $compile(html)(childScope);
                        root.replaceWith(content);
                        root = content;
                    }

                    scope.$on("$destroy", destroyChildScope);
                });
            }
        };
    }])
    .controller("DemoCtrl", [function() {
        var vm = this;

         vm.html = '&lt;h2&gt;hello : &lt;a ng-href="{{demo.link}}"&gt;angular&lt;/a&gt;&lt;/h2&gt;';  

        vm.link = 'https://angular.io/';
        var i = 0;
        vm.change = function() {
            vm.html = '&lt;h3&gt;change after : &lt;a ng-href="{{demo.link}}"&gt;' + (++i) + '&lt;/a&gt;&lt;/h3&gt;';  
        };
    }]);
</code></pre>

<p>这里创建了一个叫dy-compile的指令，它首先会监听绑定属性html值的变化，当html内容存在的时候，它会尝试首先创个一个子scope，然后利用$compile服务来动态连接传入的html，并替换掉当前DOM节点；这里创建子scope的原因，是方便在每次销毁DOM的时，也能容易的销毁掉scope，去掉HTML compile带来的watchers函数，并在最后的父scope销毁的时候，也会尝试销毁该scope。</p>

<p>因为有了上边的compile的编译和连接，则ngHref指令就可以生效了。这里只是尝试给出动态compile angular模块的例子，具体的实现方式，请参照你的业务来声明特定的directive。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/29/ngmodel-zhi-bu-geng-xin-slash-xian-shi/">ngModel 值不更新/显示</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-06-29T06:50:10+08:00" pubdate data-updated="true">Jun 29<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/06/29/ngmodel-zhi-bu-geng-xin-slash-xian-shi/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/06/29/ngmodel-zhi-bu-geng-xin-slash-xian-shi/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>angular中的$scope是页面（view）和数据（model）之间的桥梁，它链接了页面元素和model，也是angular双向绑定机制的核心。</p>

<p>而ngModel是angular用来处理表单（form）的最重要的指令，它链接了页面表单中的可交互元素和位于$scope之上的model，它会自动把ngModel所指向的model值渲染到form表单的可交互元素上，同时也会根据用户在form表单的输入或交互来更新此model值。</p>

<p>在源码中，model值的格式化、解析、验证都是由ngModel指令所对应的控制器ngModelController来实现的。</p>

<p>在笔者所维护的国内ng群中，经常被问到一个问题：</p>

<pre class='green'><code>    为什么我的ng-model=“xxx”值不能在页面显示了呢?
</code></pre>

<p>对于ngModel的这类问题主要分为两类：</p>

<ul>
<li>model值不满足表单验证条件,所以angular不会渲染它</li>
<li>由于JavaScript特殊的原型链继承机制，对$scope中属性的赋值并不能更新到父$scope</li>
</ul>


<p>在本节中，我们将会详细分析此类问题，借此深入剖析ngModel的工作原理。</p>

<h4>验证引起的model值不显示</h4>

<p>我们先来看一个修改商品数量的例子，要求为必须输入1-100的个数；</p>

<p>下面是对应的html代码：</p>

<pre class='green'><code>&lt;body class="container"&gt;
  &lt;div ng-controller="DemoCtrl as demo"&gt;
   &lt;div ng-form="form" class="form-horizontal"&gt;
      &lt;div class="form-group" ng-class="{'has-error': form.amount.$invalid }"&gt;
      &lt;label for="amount"&gt;Amount&lt;/label&gt;
      &lt;!-- 这个input将工作不正常 --&gt;
    &lt;input id="amount" name="amount" type="number" ng-model="demo.amount" class="form-control" placeholder="1 - 100" min="1" max="100"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
   &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>javascript代码：</p>

<pre class='green'><code>angular.module("com.ngbook.demo", [])
    .controller("DemoCtrl", [function(){
    var vm = this;

    vm.amount = 0;

    return vm;
}]);
</code></pre>

<p> 在代码中我们已经为ngModel变量amount赋值了整数“0”，可是界面显示效果仍然显示&#8221;1 &ndash; 100&#8221;的placeholder(如下图)。</p>

<p><img src="/images/blog_img/ngModel-vadation-question.png" alt="ng-model绑定值不改变:验证" /></p>

<p>下面是关于angular number组件ngModel转换函数代码：</p>

<pre class='green'><code>var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);

    ctrl.$parsers.push(function(value) {
        var empty = ctrl.$isEmpty(value);
        if (empty || NUMBER_REGEXP.test(value)) {
            ctrl.$setValidity('number', true);
            return value === '' ? null : (empty ? value : parseFloat(value));
        } else {
            ctrl.$setValidity('number', false);
            return undefined;
        }
    });

    addNativeHtml5Validators(ctrl, 'number', numberBadFlags, null, ctrl.$$validityState);

    ctrl.$formatters.push(function(value) {
        return ctrl.$isEmpty(value) ? '' : '' + value;
    });

    if (attr.min) {
        var minValidator = function(value) {
            var min = parseFloat(attr.min);
            return validate(ctrl, 'min', ctrl.$isEmpty(value) || value &gt;= min, value);
        };

        ctrl.$parsers.push(minValidator);
        ctrl.$formatters.push(minValidator);
    }

    if (attr.max) {
        var maxValidator = function(value) {
            var max = parseFloat(attr.max);
            return validate(ctrl, 'max', ctrl.$isEmpty(value) || value &lt;= max, value);
        };

        ctrl.$parsers.push(maxValidator);
        ctrl.$formatters.push(maxValidator);
    }

    ctrl.$formatters.push(function(value) {
        return validate(ctrl, 'number', ctrl.$isEmpty(value) || isNumber(value), value);
    });
}
</code></pre>

<p>ngModel作为angular双向绑定中的重要组成部分，负责view控件交互数据到$scope上model的同步。当然这里存在一些差异，view上的显示和输入都是字符串类型，而在model上的数据则是有特定类型的，如常用的int、float、Date、Array、Object等。ngModel为了实现数据到model的类型转换，在ngModelController中提供了两个管道数组$formatters和$parsers，它们分别是将model的数据转换为view交互控件显示的值和将交互控件得到的view值转换为model数据，它们都是一个数组对象，在ngModel启动数据转换时，会以UNIX管道式传递执行这一些列的转换。我们也可以手动的添加$formatters和$parsers的转换函数（unshift、push），当然在这里也是做数据验证的最佳时机，能够转换意味应该是合法的数据。</p>

<p>在number组件代码中，我们清晰看见：依次添加了对数字验证转换、最小值合法性验证、最大值合法验证。首先会启动$parsers转换，如果在转换过程中出现不合法验证则会设置ngModelController.$setValidity验证错误，则返回undefined。对于model数据到交互控件显示，同样也会经过$formatters转换管道，对于没有通过验证的逻辑，同样也会ngModelController.$setValidity设置验证错误，返回undefined，因此这不合法的model数据不会显示在交互控件上。</p>

<h4>原型链继承问题</h4>

<p>JavaScript中每个对象都会链接到一个原型对象，并且他可以从中继承属性。即使通过字面量创建的对象也会链接到Object.prototype，它是JavaScript中的标配对象。JavaScript的原型链继承相对于其他语言常见的继承，是一种另类的继承，它是实施于对象上的动态继承方式，而非常见的实施与类型class之上的静态继承体系。JavaScript的这种继承方式很灵活，一个对象可以被多个对象继承，而且他们共享同一实例对象，但理解起来显得格外复杂，从JavaScript原型和原型链可以看出它的复杂性。在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个<strong>proto</strong>属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个<strong>proto</strong>指向自己的原型，这样逐层深入直到Object对象的原型，这样就形成了原型链。下面的是JavaScript原型继承基础原型和原型链展示图。</p>

<p><img src="/images/blog_img/javascript-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt="javascript-原型继承" /></p>

<p>函数是由Function函数创建的对象，因此函数也有一个<strong>proto</strong>属性指向Function函数的原型。需要注意的是，真正形成原型链的是每个对象的<strong>proto</strong>属性，而不是函数的prototype属性。更多的内容关于原型和原型链的知识，请参考《Javascript模式》这本书。</p>

<p>JavaScript的原型链连接只在属性检索的时候才会启用，如果我们尝试去获取对象的某个属性值，但该对象没有此属性名，则JavaScript会试着从原型对象中获取该属性值。如果那个对象也没有该属性名，那么在继续从它的原型中寻找，依次类推，直到Object.prototype，如果仍然没有找到该属性值，则返回结果为undefined。不幸的是，这种原型链连接检索，只会在属性检索的的时候启用，并不会在更新属性值时启用，因此当我们对于基础类型（非引用对象上的属性，换句通俗的话来说，就是不会出现“.”运算符）的属性更新的时候，它并不能更新父对象的属性，替代方式是在自身对象上创建了该属性。这也是angular中对于基础类型的属性，不能在子controller中被修改的原因，导致在子controller中ngModel的更新并不会反应在父controller上。</p>

<p>下边是关于该问题的一个简化例子：</p>

<p>HTML：</p>

<pre class='green'><code>&lt;div ng-controller="ParentCtrl"&gt;
    &lt;div class="form-group"&gt;
        &lt;h4&gt;Parent Controller:&lt;/h4&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;input type="text" ng-model="greet" class="form-control" /&gt;
    &lt;/div&gt;
    &lt;div ng-controller="ChildCtrl"&gt;
        &lt;div class="form-group"&gt;
            &lt;h4&gt;Child controller:&lt;/h4&gt;
            &lt;pre&gt;&lt;/pre&gt;
            &lt;input type="text" ng-model="greet" class="form-control" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>JavaScript：</p>

<pre class='green'><code>angular.module("com.ngbook.demo", [])
    .controller("ParentCtrl", ["$scope", function($scope) {

        $scope.greet = "hello angular!";

    }])
    .controller("ChildCtrl", angular.noop);
</code></pre>

<p>从初始化显示效果中，我们能看出子$scope之继承了来自父$scope的greet属性，都显示为&#8221;hello angular!&ldquo;。如果我们尝试利用父controller提供了input控件改变父$scope的greet属性，你也能看见子controller区域的显示也会被及时更新。对于ngController默认会使用原型链继承其父对象的属性，所有的$scope的根$scope或称祖$scope是来自ngApp节点创建的$rootScope，换句话说，$rootScope是万物之源，所有的$scope都直接或者间接继承至它。</p>

<p><img src="/images/blog_img/ngModel-%E5%80%BC%E4%B8%8D%E6%9B%B4%E6%96%B0-javascript-issue-1.png" alt="ngModel-controller继承" /></p>

<p>当我们尝试去改变输入框的greet属性的时，则发生了下面的情况：子controller区域发生了更新，父controller区域却无法更新。因为上面所说的JavaScript的原型链检索并不对更新启用，对于基础类型JavaScript在自身对象（这里是子$scope）上创建了一个同名的变量。你也想可以从下面angular调试插件batarang截图中看出来。一旦利用子controller的input控件修改了greet属性，再次之后我再次尝试修改父controller区域的greet属性，子controller区别不会在像初始化时候那样及时同步了，它们之间完全独立了，各自拥有了自己的greet属性。</p>

<p><img src="/images/blog_img/ngModel-%E5%80%BC%E4%B8%8D%E6%9B%B4%E6%96%B0-javascript-issue-2.png" alt="ngModel-controller继承" /></p>

<p>batarang插件截图</p>

<p><img src="/images/blog_img/ngModel-%E5%80%BC%E4%B8%8D%E6%9B%B4%E6%96%B0-javascript-issue-3.png" alt="ngModel-controller继承" /></p>

<p>经过上面的例子分析，相信作为读者的你已经能够理解这类由于继承链引用问题导致的ngModel不能更新问题了，请记住：这是JavaScript原型继承的issue，并不是angular的issue。</p>

<p>那么我们在子controller中如何更新父controller的属性值呢？这个问题已经很简单了，issue的问题在于没有启用原型链的检索，那么如果我们将ngModel的属性变为引用对象，换句话说：在ngModel的属性值中加了“.”，那么在JavaScript的原型链检索就会启动了。</p>

<p>HTML:</p>

<pre class='green'><code>&lt;div ng-controller="ParentCtrl"&gt;
    &lt;div class="form-group"&gt;
        &lt;h4&gt;Parent Controller:&lt;/h4&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;input type="text" ng-model="vm.greet" class="form-control" /&gt;
    &lt;/div&gt;
    &lt;div ng-controller="ChildCtrl"&gt;
        &lt;div class="form-group"&gt;
            &lt;h4&gt;Child controller:&lt;/h4&gt;
            &lt;pre&gt;&lt;/pre&gt;
            &lt;input type="text" ng-model="vm.greet" class="form-control" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>JavaScript:</p>

<pre class='green'><code>angular.module("com.ngbook.demo", [])
    .controller("ParentCtrl", ["$scope", function($scope) {

        $scope.vm = {
            greet: "hello angular!"
        };

    }])
    .controller("ChildCtrl", angular.noop);
</code></pre>

<p>jsbin demo: <a href="http://jsbin.com/metufi/1/edit?html,js,output">http://jsbin.com/metufi/1/edit?html,js,output</a></p>

<p>这里在ngModel属性值多引入了“vm”变量，这个时候，不管我们尝试修改greet值，整个页面都会得到相应的同步。关于这个问题，作者更推荐使用angular 1.2后的controller as vm的方式解决，更多的信息请阅读《使用controller as vm方式.md》一节。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/16/angularzhong-de-mvvmmo-shi/">angular中的MVVM模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-06-16T11:33:55+08:00" pubdate data-updated="true">Jun 16<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/06/16/angularzhong-de-mvvmmo-shi/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/06/16/angularzhong-de-mvvmmo-shi/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p> 在开始介绍angular原理之前，我们有必要先了解下mvvm模式在angular中运用。虽然在angular社区一直将angular统称为前端MVC框架，同时angular团队也称它为MVW（Whatever）框架，但angular框架整体上更接近MVVM模式。下面是Igor Minar发布在Google+ <a href="https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV">https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV</a>的文章内容：</p>

<p> MVC vs MVVM vs MVP. What a controversial topic that many developers can spend hours and hours debating and arguing about.</p>

<p>For several years +AngularJS was closer to MVC (or rather one of its client-side variants), but over time and thanks to many refactorings and api improvements, it&rsquo;s now closer to MVVM – the $scope object could be considered the ViewModel that is being decorated by a function that we call a Controller.</p>

<p>Being able to categorize a framework and put it into one of the MV* buckets has some advantages. It can help developers get more comfortable with its apis by making it easier to create a mental model that represents the application that is being built with the framework. It can also help to establish terminology that is used by developers.</p>

<p>Having said, I&rsquo;d rather see developers build kick-ass apps that are well-designed and follow separation of concerns, than see them waste time arguing about MV* nonsense. And for this reason, I hereby declare AngularJS to be MVW framework &ndash; Model-View-Whatever. Where Whatever stands for &ldquo;whatever works for you&rdquo;.</p>

<p>Angular gives you a lot of flexibility to nicely separate presentation logic from business logic and presentation state. Please use it fuel your productivity and application maintainability rather than heated discussions about things that at the end of the day don&rsquo;t matter that much.</p>

<p>在文中特别指出angular在多次的API重构和改善，它越来越接近于MVVM模式，$scope可以被认为是ViewModl，而Controller则是装饰、加工处理这个ViewModel的JavaScript函数。作者更希望大家关注于实现一个成功的，具有好的设计以及遵循“分离关注点”原则的应用程序，而不是去争论MV*，所以他将angular称为MVW框架，是什么并不重要，只要适合你的应用就行。</p>

<p> MVVM模式是Model-View-ViewMode（模型-视图-视图模型）模式的简称，其最早出现在微软的WPF和Silverlight框架中。MVVM模式利用框架内置的双向绑定技术对MVP（Model-View-Presenter）模式的变型，引入了专门的ViewModel（视图模型）来实现View和Model的粘合，让View和Model的进一步分离和解耦。MVVM模式的优势有如下四点：</p>

<ol>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ol>


<p>下面是angular中关于MVVM模式的运用：</p>

<p><img src="/images/blog_img/angular-mvvm.png" alt="angular mvvm" /></p>

<p>在angular中MVVM模式主要分为四部分：</p>

<ol>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。</li>
</ol>


<p>View不能直接与Model交互，而是通过$scope这个ViewModel来实现与Model的交互。对于界面表单的交互，通过ngModel指令来实现View和ViewModel的同步。ngModelController包含$parsers和$formatters两个转换器管道，它们分别实现View表单输入值到Model数据类型转换和Model数据到View表单数据的格式化。对于用户界面的交互Command事件（如ngClick、ngChange等）则会转发到ViewModel对象上，通过ViewModel来实现对于Model的改变。然而对于Model的任何改变，也会反应在ViewModel之上，并且会通过$scope的“脏检查机制”（$digest）来更新到View。从而实现View和Model的分离，达到对前端逻辑MVVM的分层架构。</p>

<p>angular中MVVM模式的实现，以领域Model为中心思维，遵循“分离关注点”设计原则，这也是与jQuery以DOM驱动的思维所不同之处。所以我们在做angular开发的时候应该谨记下面几点：</p>

<h4>绝不要先设计你的页面，然后用DOM操作去改变它</h4>

<p>在以往的jQuery开发中，我们会首先设计页面DOM结构，然后在利用jQuery来改变DOM结构或者实现动态交互效果。因为jQuery是为DOM驱动而设计的，对于拥有大量复杂的前端交互的项目，JavaScript的逻辑变得越来越臃肿，交互逻辑分散各处。</p>

<p>在MVVM模式下的angular开发中， 我们首先需要在脑子里挂着Model的弦。不能老想着“我有XXX这个DOM，我希望让它做XXX这种动态效果”，我们需要从要完成的目标开始思考我们需要或拥有怎么样的Model数据，然后设计我们的应用， 最后才是设计视图，并用$scope来粘合它们。</p>

<h4>Directive不是封装jQuery代码的“天堂”</h4>

<p>如上条所述，我们不能一开始就去想如何利用DOM操作的方法去实现应用目标，然后“冠冕堂皇”的写上一堆jQuery的代码，并将其封装到angular的directive中，最后不得不加上$scope.$apply()来通知angular你的ViewModel的改变，需要启动“脏检查机制”来更新你的改变到View。作者在多个客户项目中看见这种将Directive作为封装jQuery代码“天堂”的例子，其实对于这类问题，大部分情况下，我们都可以用很少了angular代码将其重构为真正的angular way。特别在ng社区经常看见在angular directive中利用jQuery的on方法绑定click、keydown、blur等事件的代码，大部分情况我们都能以对应的ng事件（ngClick、ngChange、ngBlur）来重构它们。</p>

<p>对于这类问题，首先我们应该尽量尝试复用angular的内置指令，以真正的angular way去思考我们的问题，请慎重的引入jQuery的DOM方法和操作。</p>

<p>关于angular MVVM模式的资料，你还可以参考视频：<a href="https://frontendmasters.com/courses/angularjs-mvc-mvvm-mvwhatever/#v=ypur7bfbcq">https://frontendmasters.com/courses/angularjs-mvc-mvvm-mvwhatever/#v=ypur7bfbcq</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/11/jshan-shu-ke-li-hua/">JavaScript函数柯里化</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-11T19:37:18+08:00" pubdate data-updated="true">May 11<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/05/11/jshan-shu-ke-li-hua/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/05/11/jshan-shu-ke-li-hua/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>函数式</h4>

<p>JavaScript是以函数为一等公民的函数式语言。函数在JavaScript中也是一个对象（继承制Function），函数也可以作为参数传递成函数变量。最近几年函数式也因为其无副作用的特性、透明性、惰性计算等在高并发，大数据领域火起来了。</p>

<p>JavaScript中也有如Underscore、lodash之类的函数式库，如lodash的使用方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre class='green'><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">names</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">users</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">){</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>
</span><span class='line'>  <span class="p">})</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot; , &quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">value</span><span class="p">();</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">names</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于lodash更多内容请参考<a href="http://www.cnblogs.com/whitewolf/p/4417873.html">JavaScript工具库之Lodash</a>.</p>

<h4>柯里化</h4>

<p>今天文章将以高阶函数中的柯里化方式来，看看JavaScript的函数式能力。</p>

<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>

<p>在理论计算机科学中，柯里化提供了在简单的理论模型中比如只接受一个单一参数的lambda 演算中研究带有多个参数的函数的方式。</p>

<h4>JavaScript的柯里化实现</h4>

<p>下边的例子，我们将把柯里化方式泛化为接受任意个参数，直到声明的方法参数个数饱和才执行，所以根据参数个数可以有多种柯里化函数产生。</p>

<p>代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre class='green'><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">global</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">FN_ARGS</span> <span class="o">=</span> <span class="sr">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span><span class="p">,</span>
</span><span class='line'>        <span class="nx">FN_ARG_SPLIT</span> <span class="o">=</span> <span class="sr">/,/</span><span class="p">,</span>
</span><span class='line'>        <span class="nx">FN_ARG</span> <span class="o">=</span> <span class="sr">/^\s*(_?)(\S+?)\1\s*$/</span><span class="p">,</span>
</span><span class='line'>        <span class="nx">STRIP_COMMENTS</span> <span class="o">=</span> <span class="sr">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">getArgLength</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">fnText</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">replace</span><span class="p">(</span><span class="nx">STRIP_COMMENTS</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">argDecl</span> <span class="o">=</span> <span class="nx">fnText</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">FN_ARGS</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>        <span class="nx">argDecl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="nx">FN_ARG_SPLIT</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">arg</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">FN_ARG</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">all</span><span class="p">,</span> <span class="nx">underscore</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">params</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">params</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">curryFunc</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">len</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">||</span> <span class="nx">getArgLength</span><span class="p">(</span><span class="nx">func</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[].</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">arguments</span><span class="p">));</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">global</span><span class="p">.</span><span class="nx">curryFunc</span> <span class="o">=</span> <span class="nx">curryFunc</span><span class="p">;</span>
</span><span class='line'><span class="p">})(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;result 1:&quot;</span><span class="p">,</span> <span class="nx">curryFunc</span><span class="p">(</span><span class="nx">add</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">));</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;result 2:&quot;</span><span class="p">,</span> <span class="nx">curryFunc</span><span class="p">(</span><span class="nx">add</span><span class="p">)(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;result 3:&quot;</span><span class="p">,</span> <span class="nx">curryFunc</span><span class="p">(</span><span class="nx">add</span><span class="p">)(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">z</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;result 1:&quot;</span><span class="p">,</span> <span class="nx">curryFunc</span><span class="p">(</span><span class="nx">add</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)(</span><span class="mi">6</span><span class="p">));</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;result 2:&quot;</span><span class="p">,</span> <span class="nx">curryFunc</span><span class="p">(</span><span class="nx">add</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;result 3:&quot;</span><span class="p">,</span> <span class="nx">curryFunc</span><span class="p">(</span><span class="nx">add</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">6</span><span class="p">)(</span><span class="mi">4</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">curryFunc</span><span class="p">(</span><span class="nx">sayHello</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先上面会利用正则来获取传入函数的参数个数。再返回一个函数的代理，每次的调用都会将传入参数缓存在args临时变量中，直到参数个数饱和才会立即执行。代码比较冗长，慢慢品味，当然有不足之处，也希望大家指出来。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/10/qian-duan-html-css-gui-fan/">前端HTML-CSS规范</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-10T08:15:28+08:00" pubdate data-updated="true">May 10<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/05/10/qian-duan-html-css-gui-fan/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/05/10/qian-duan-html-css-gui-fan/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="heading" id="toc">
    <h2>目录</h2>
</div>
<div class="section toc">
    <div class="col">
        <h4><a href="http://codeguide.bootcss.com/#html">HTML</a></h4>
        <ul>
            <li><a href="http://codeguide.bootcss.com/#html-syntax">语法</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-doctype">HTML5 doctype</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-lang">语言属性（Language attribute）</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-encoding">字符编码</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-ie-compatibility-mode">IE 兼容模式</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-style-script">引入 CSS 和 JavaScript 文件</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-practicality">实用为王</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-attribute-order">属性顺序</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-boolean-attributes">布尔（boolean）型属性</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-reducing-markup">减少标签的数量</a></li>
            <li><a href="http://codeguide.bootcss.com/#html-javascript">JavaScript 生成的标签</a></li>
        </ul>
    </div>
    <div class="col">
        <h4><a href="http://codeguide.bootcss.com/#css">CSS</a></h4>
        <ul>
            <li><a href="http://codeguide.bootcss.com/#css-syntax">语法</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-declaration-order">声明顺序</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-media-queries">媒体查询（Media query）的位置</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-prefixed-properties">带前缀的属性</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-single-declarations">单行规则声明</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-shorthand">简写形式的属性声明</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-nesting">Less 和 Sass 中的嵌套</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-comments">注释</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-classes">class 命名</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-selectors">选择器</a></li>
            <li><a href="http://codeguide.bootcss.com/#css-organization">代码组织</a></li>
        </ul>
    </div>
</div>
<div class="section" id="golden-rule">
    <div class="col">
        <h2>黄金定律</h2>
        <p>一个项目应该永远遵循同一套编码规范！</p>
    </div>
    <div class="col">
        <blockquote>
            <p>不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。</p>
        </blockquote>
    </div>
</div>
<div class="heading" id="html">
    <h2>HTML</h2>
</div>
<div class="section" id="html-syntax">
    <div class="col">
        <h3>语法</h3>
        <ul>
            <li>用两个空格来代替制表符（tab） &#8211; 这是唯一能保证在所有环境下获得一致展现的方法。</li>
            <li>嵌套元素应当缩进一次（即两个空格）。</li>
            <li>对于属性的定义，确保全部使用双引号，绝不要使用单引号。</li>
            <li>不要在自闭合（self-closing）元素的尾部添加斜线 &#8211; <a href="http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag">HTML5 规范</a>中明确说明这是可选的。</li>
            <li>不要省略可选的结束标签（closing tag）（例如，<code>&lt;/li&gt;</code> 或 <code>&lt;/body&gt;</code>）。</li>
        </ul>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Page title<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"images/company-logo.png"</span> <span class="na">alt=</span><span class="s">"Company"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1</span> <span class="na">class=</span><span class="s">"hello-world"</span><span class="nt">&gt;</span>Hello, world!<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-doctype">
    <div class="col">
        <h3>HTML5 doctype</h3>
        <p>为每个 HTML 页面的第一行添加标准模式（standard mode）的声明，这样能够确保在每个浏览器中拥有一致的展现。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-lang">
    <div class="col">
        <h3>语言属性</h3>
        <p>根据 HTML5 规范：</p>
        <blockquote>
            <p>强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言。这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。</p>
        </blockquote>
        <p>更多关于 <code>lang</code> 属性的知识可以从 <a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-html-element">此规范</a> 中了解。</p>
        <p>这里列出了<a href="http://reference.sitepoint.com/html/lang-codes">语言代码表</a>。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"zh-CN"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-ie-compatibility-mode">
    <div class="col">
        <h3>IE 兼容模式</h3>
        <p>IE 支持通过特定的 <code>&lt;meta&gt;</code> 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为 <strong>edge mode</strong>，从而通知 IE 采用其所支持的最新的模式。</p>
        <p><a href="http://stackoverflow.com/questions/6771258/whats-the-difference-if-meta-http-equiv-x-ua-compatible-content-ie-edge-e">阅读这篇 stack overflow 上的文章</a>可以获得更多有用的信息。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"X-UA-Compatible"</span> <span class="na">content=</span><span class="s">"IE=Edge"</span><span class="nt">&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-encoding">
    <div class="col">
        <h3>字符编码</h3>
        <p>通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致（一般采用 UTF-8 编码）。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-style-script">
    <div class="col">
        <h3>引入 CSS 和 JavaScript 文件</h3>
        <p>根据 HTML5 规范，在引入 CSS 和 JavaScript 文件时一般不需要指定 <code>type</code> 属性，因为 <code>text/css</code> 和 <code>text/javascript</code> 分别是它们的默认值。</p>
        <h4>HTML5 spec links</h4>
        <ul>
            <li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-link-element">Using link</a></li>
            <li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-style-element">Using style</a></li>
            <li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/scripting-1.html#the-script-element">Using script</a></li>
        </ul>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="c">&lt;!-- External CSS --&gt;</span>
<span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"code-guide.css"</span><span class="nt">&gt;</span>

<span class="c">&lt;!-- In-document CSS --&gt;</span>
<span class="nt">&lt;style&gt;</span>
  <span class="c">/* ... */</span>
<span class="nt">&lt;/style&gt;</span>

<span class="c">&lt;!-- JavaScript --&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"code-guide.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-practicality">
    <div class="col">
        <h3>实用为王</h3>
        <p>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。</p>
    </div>
</div>
<div class="section" id="html-attribute-order">
    <div class="col">
        <h3>属性顺序</h3>
        <p>HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。</p>
        <ul>
            <li><code>class</code></li>
            <li><code>id</code>, <code>name</code></li>
            <li><code>data-*</code></li>
            <li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code></li>
            <li><code>title</code>, <code>alt</code></li>
            <li><code>aria-*</code>, <code>role</code></li>
        </ul>
        <p>class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">"..."</span> <span class="na">id=</span><span class="s">"..."</span> <span class="na">data-modal=</span><span class="s">"toggle"</span> <span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>
  Example link
<span class="nt">&lt;/a&gt;</span>

<span class="nt">&lt;input</span> <span class="na">class=</span><span class="s">"form-control"</span> <span class="na">type=</span><span class="s">"text"</span><span class="nt">&gt;</span>

<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"..."</span> <span class="na">alt=</span><span class="s">"..."</span><span class="nt">&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-boolean-attributes">
    <div class="col">
        <h3>布尔（boolean）型属性</h3>
        <p>布尔型属性可以在声明时不赋值。XHTML 规范要求为其赋值，但是 HTML5 规范不需要。</p>
        <p>更多信息请参考 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attributes">WhatWG section on boolean attributes</a>：</p>
        <blockquote>
            <p>元素的布尔型属性如果有值，就是 true，如果没有值，就是 false。</p>
        </blockquote>
        <p>如果<em>一定</em>要为其赋值的话，请参考 WhatWG 规范：</p>
        <blockquote>
            <p>如果属性存在，其值必须是空字符串或 [&#8230;] 属性的规范名称，并且不要再收尾添加空白符。</p>
        </blockquote>
        <p><strong>简单来说，就是不用赋值。</strong></p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">disabled</span><span class="nt">&gt;</span>

<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">value=</span><span class="s">"1"</span> <span class="na">checked</span><span class="nt">&gt;</span>

<span class="nt">&lt;select&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"1"</span> <span class="na">selected</span><span class="nt">&gt;</span>1<span class="nt">&lt;/option&gt;</span>
<span class="nt">&lt;/select&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-reducing-markup">
    <div class="col">
        <h3>减少标签的数量</h3>
        <p>编写 HTML 代码时，尽量避免多余的父元素。很多时候，这需要迭代和重构来实现。请看下面的案例：</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="c">&lt;!-- Not so great --&gt;</span>
<span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"avatar"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"..."</span><span class="nt">&gt;</span>
<span class="nt">&lt;/span&gt;</span>

<span class="c">&lt;!-- Better --&gt;</span>
<span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"avatar"</span> <span class="na">src=</span><span class="s">"..."</span><span class="nt">&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="html-javascript">
    <div class="col">
        <h3>JavaScript 生成的标签</h3>
        <p>通过 JavaScript 生成的标签让内容变得不易查找、编辑，并且降低性能。能避免时尽量避免。</p>
    </div>
</div>
<div class="heading" id="css">
    <h2>CSS</h2>
</div>
<div class="section" id="css-syntax">
    <div class="col">
        <h3>语法</h3>
        <ul>
            <li>用两个空格来代替制表符（tab） &#8211; 这是唯一能保证在所有环境下获得一致展现的方法。</li>
            <li>为选择器分组时，将单独的选择器单独放在一行。</li>
            <li>为了代码的易读性，在每个声明块的左花括号前添加一个空格。</li>
            <li>声明块的右花括号应当单独成行。</li>
            <li>每条声明语句的 <code>:</code> 后应该插入一个空格。</li>
            <li>为了获得更准确的错误报告，每条声明都应该独占一行。</li>
            <li>所有声明语句都应当以分号结尾。最后一条声明语句后面的分号是可选的，但是，如果省略这个分号，你的代码可能更易出错。</li>
            <li>对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如，<code>box-shadow</code>）。</li>
            <li>不要在 <code>rgb()</code>、<code>rgba()</code>、<code>hsl()</code>、<code>hsla()</code> 或 <code>rect()</code> 值的<em>内部</em>的逗号后面插入空格。这样利于从多个属性值（既加逗号也加空格）中区分多个颜色值（只加逗号，不加空格）。</li>
            <li>对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，<code>.5</code> 代替 <code>0.5</code>；<code>-.5px</code> 代替 <code>-0.5px</code>）。</li>
            <li>十六进制值应该全部小写，例如，<code>#fff</code>。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。</li>
            <li>尽量使用简写形式的十六进制值，例如，用 <code>#fff</code> 代替 <code>#ffffff</code>。</li>
            <li>为选择器中的属性添加双引号，例如，<code>input[type="text"]</code>。<a href="http://mathiasbynens.be/notes/unquoted-attribute-values#css">只有在某些情况下是可选的</a>，但是，为了代码的一致性，建议都加上双引号。</li>
            <li>避免为 0 值指定单位，例如，用 <code>margin: 0;</code> 代替 <code>margin: 0px;</code>。</li>
        </ul>
        <p>对于这里用到的术语有疑问吗？请参考 Wikipedia 上的 <a href="http://en.wikipedia.org/wiki/Cascading_Style_Sheets#Syntax">syntax section of the Cascading Style Sheets article</a>。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/* Bad CSS */</span>
<span class="nc">.selector</span><span class="o">,</span> <span class="nc">.selector-secondary</span><span class="o">,</span> <span class="nc">.selector</span><span class="o">[</span><span class="nt">type</span><span class="o">=</span><span class="nt">text</span><span class="o">]</span> <span class="p">{</span>
  <span class="k">padding</span><span class="o">:</span><span class="m">15px</span><span class="p">;</span>
  <span class="k">margin</span><span class="o">:</span><span class="m">0px</span> <span class="m">0px</span> <span class="m">15px</span><span class="p">;</span>
  <span class="k">background-color</span><span class="o">:</span><span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="o">,</span> <span class="m">0</span><span class="o">,</span> <span class="m">0</span><span class="o">,</span> <span class="m">0</span><span class="o">.</span><span class="m">5</span><span class="p">);</span>
  <span class="n">box</span><span class="o">-</span><span class="n">shadow</span><span class="o">:</span><span class="m">0px</span> <span class="m">1px</span> <span class="m">2px</span> <span class="m">#CCC</span><span class="o">,</span><span class="k">inset</span> <span class="m">0</span> <span class="m">1px</span> <span class="m">0</span> <span class="m">#FFFFFF</span>
<span class="p">}</span>

<span class="c">/* Good CSS */</span>
<span class="nc">.selector</span><span class="o">,</span>
<span class="nc">.selector-secondary</span><span class="o">,</span>
<span class="nc">.selector</span><span class="o">[</span><span class="nt">type</span><span class="o">=</span><span class="s2">"text"</span><span class="o">]</span> <span class="p">{</span>
  <span class="k">padding</span><span class="o">:</span> <span class="m">15px</span><span class="p">;</span>
  <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">15px</span><span class="p">;</span>
  <span class="k">background-color</span><span class="o">:</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,.</span><span class="m">5</span><span class="p">);</span>
  <span class="n">box</span><span class="o">-</span><span class="n">shadow</span><span class="o">:</span> <span class="m">0</span> <span class="m">1px</span> <span class="m">2px</span> <span class="m">#ccc</span><span class="o">,</span> <span class="k">inset</span> <span class="m">0</span> <span class="m">1px</span> <span class="m">0</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-declaration-order">
    <div class="col">
        <h3>声明顺序</h3>
        <p>相关的属性声明应当归为一组，并按照下面的顺序排列：</p>
        <ol>
            <li>Positioning</li>
            <li>Box model</li>
            <li>Typographic</li>
            <li>Visual</li>
        </ol>
        <p>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。</p>
        <p>其他属性只是影响组件的<em>内部（inside）</em>或者是不影响前两组属性，因此排在后面。</p>
        <p>完整的属性列表及其排列顺序请参考 <a href="http://twitter.github.com/recess">Recess</a>。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="nc">.declaration-order</span> <span class="p">{</span>
  <span class="c">/* Positioning */</span>
  <span class="k">position</span><span class="o">:</span> <span class="k">absolute</span><span class="p">;</span>
  <span class="k">top</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="k">right</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="k">bottom</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="k">left</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="k">z-index</span><span class="o">:</span> <span class="m">100</span><span class="p">;</span>

  <span class="c">/* Box-model */</span>
  <span class="k">display</span><span class="o">:</span> <span class="k">block</span><span class="p">;</span>
  <span class="k">float</span><span class="o">:</span> <span class="k">right</span><span class="p">;</span>
  <span class="k">width</span><span class="o">:</span> <span class="m">100px</span><span class="p">;</span>
  <span class="k">height</span><span class="o">:</span> <span class="m">100px</span><span class="p">;</span>

  <span class="c">/* Typography */</span>
  <span class="k">font</span><span class="o">:</span> <span class="k">normal</span> <span class="m">13px</span> <span class="s2">"Helvetica Neue"</span><span class="o">,</span> <span class="k">sans-serif</span><span class="p">;</span>
  <span class="k">line-height</span><span class="o">:</span> <span class="m">1</span><span class="o">.</span><span class="m">5</span><span class="p">;</span>
  <span class="k">color</span><span class="o">:</span> <span class="m">#333</span><span class="p">;</span>
  <span class="k">text-align</span><span class="o">:</span> <span class="k">center</span><span class="p">;</span>

  <span class="c">/* Visual */</span>
  <span class="k">background-color</span><span class="o">:</span> <span class="m">#f5f5f5</span><span class="p">;</span>
  <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#e5e5e5</span><span class="p">;</span>
  <span class="k">border</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">3px</span><span class="p">;</span>

  <span class="c">/* Misc */</span>
  <span class="k">opacity</span><span class="o">:</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-import">
    <div class="col">
        <h3>不要使用 <code>@import</code></h3>
        <p>与 <code>&lt;link&gt;</code> 标签相比，<code>@import</code> 指令要慢很多，不光增加了额外的请求次数，还会导致不可预料的问题。替代办法有以下几种：</p>
        <ul>
            <li>使用多个 <code>&lt;link&gt;</code> 元素</li>
            <li>通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件</li>
            <li>通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能</li>
        </ul>
        <p>请参考 <a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/">Steve Souders 的文章</a>了解更多知识。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="html"><span class="c">&lt;!-- Use link elements --&gt;</span>
<span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"core.css"</span><span class="nt">&gt;</span>

<span class="c">&lt;!-- Avoid @imports --&gt;</span>
<span class="nt">&lt;style&gt;</span>
  <span class="k">@import</span> <span class="nt">url</span><span class="o">(</span><span class="s2">"more.css"</span><span class="o">)</span><span class="p">;</span>
<span class="nt">&lt;/style&gt;</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-media-queries">
    <div class="col">
        <h3>媒体查询（Media query）的位置</h3>
        <p>将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。下面给出一个典型的实例。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="nc">.element</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.element-avatar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.element-selected</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">@media</span> <span class="o">(</span><span class="nt">min-width</span><span class="o">:</span> <span class="nt">480px</span><span class="o">)</span> <span class="p">{</span>
  <span class="nc">.element</span> <span class="p">{</span> <span class="o">...</span><span class="p">}</span>
  <span class="nc">.element-avatar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="nc">.element-selected</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-prefixed-properties">
    <div class="col">
        <h3>带前缀的属性</h3>
        <p>当使用特定厂商的带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑。</p>
        <p>在 Textmate 中，使用 <strong>Text → Edit Each Line in Selection</strong> (⌃⌘A)。在 Sublime Text 2 中，使用 <strong>Selection → Add Previous Line</strong> (⌃⇧↑) 和 <strong>Selection →  Add Next Line</strong> (⌃⇧↓)。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/* Prefixed properties */</span>
<span class="nc">.selector</span> <span class="p">{</span>
  <span class="o">-</span><span class="n">webkit</span><span class="o">-</span><span class="n">box</span><span class="o">-</span><span class="n">shadow</span><span class="o">:</span> <span class="m">0</span> <span class="m">1px</span> <span class="m">2px</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,.</span><span class="m">15</span><span class="p">);</span>
          <span class="n">box</span><span class="o">-</span><span class="n">shadow</span><span class="o">:</span> <span class="m">0</span> <span class="m">1px</span> <span class="m">2px</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,.</span><span class="m">15</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-single-declarations">
    <div class="col">
        <h3>单行规则声明</h3>
        <p>对于<strong>只包含一条声明</strong>的样式，为了易读性和便于快速编辑，建议将语句放在同一行。对于带有多条声明的样式，还是应当将声明分为多行。</p>
        <p>这样做的关键因素是为了错误检测 &#8211; 例如，CSS 校验器指出在 183 行有语法错误。如果是单行单条声明，你就不会忽略这个错误；如果是单行多条声明的话，你就要仔细分析避免漏掉错误了。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/* Single declarations on one line */</span>
<span class="nc">.span1</span> <span class="p">{</span> <span class="k">width</span><span class="o">:</span> <span class="m">60px</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.span2</span> <span class="p">{</span> <span class="k">width</span><span class="o">:</span> <span class="m">140px</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.span3</span> <span class="p">{</span> <span class="k">width</span><span class="o">:</span> <span class="m">220px</span><span class="p">;</span> <span class="p">}</span>

<span class="c">/* Multiple declarations, one per line */</span>
<span class="nc">.sprite</span> <span class="p">{</span>
  <span class="k">display</span><span class="o">:</span> <span class="k">inline</span><span class="o">-</span><span class="k">block</span><span class="p">;</span>
  <span class="k">width</span><span class="o">:</span> <span class="m">16px</span><span class="p">;</span>
  <span class="k">height</span><span class="o">:</span> <span class="m">15px</span><span class="p">;</span>
  <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(../img/sprite.png)</span><span class="p">;</span>
<span class="p">}</span>
<span class="nc">.icon</span>           <span class="p">{</span> <span class="k">background-position</span><span class="o">:</span> <span class="m">0</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.icon-home</span>      <span class="p">{</span> <span class="k">background-position</span><span class="o">:</span> <span class="m">0</span> <span class="m">-20px</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.icon-account</span>   <span class="p">{</span> <span class="k">background-position</span><span class="o">:</span> <span class="m">0</span> <span class="m">-40px</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-shorthand">
    <div class="col">
        <h3>简写形式的属性声明</h3>
        <p>在需要显示地设置所有值的情况下，应当尽量限制使用简写形式的属性声明。常见的滥用简写属性声明的情况如下：</p>
        <ul>
            <li><code>padding</code></li>
            <li><code>margin</code></li>
            <li><code>font</code></li>
            <li><code>background</code></li>
            <li><code>border</code></li>
            <li><code>border-radius</code></li>
        </ul>
        <p>大部分情况下，我们不需要为简写形式的属性声明指定所有值。例如，HTML 的 heading 元素只需要设置上、下边距（margin）的值，因此，在必要的时候，只需覆盖这两个值就可以。过度使用简写形式的属性声明会导致代码混乱，并且会对属性值带来不必要的覆盖从而引起意外的副作用。</p>
        <p>MDN（Mozilla Developer Network）上一片非常好的关于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties">shorthand properties</a> 的文章，对于不太熟悉简写属性声明及其行为的用户很有用。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/* Bad example */</span>
<span class="nc">.element</span> <span class="p">{</span>
  <span class="k">margin</span><span class="o">:</span> <span class="m">0</span> <span class="m">0</span> <span class="m">10px</span><span class="p">;</span>
  <span class="k">background</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
  <span class="k">background</span><span class="o">:</span> <span class="sx">url("image.jpg")</span><span class="p">;</span>
  <span class="k">border</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">3px</span> <span class="m">3px</span> <span class="m">0</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* Good example */</span>
<span class="nc">.element</span> <span class="p">{</span>
  <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
  <span class="k">background-color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
  <span class="k">background-image</span><span class="o">:</span> <span class="sx">url("image.jpg")</span><span class="p">;</span>
  <span class="k">border-top</span><span class="o">-</span><span class="k">left</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">3px</span><span class="p">;</span>
  <span class="k">border-top</span><span class="o">-</span><span class="k">right</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">3px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-nesting">
    <div class="col">
        <h3>Less 和 Sass 中的嵌套</h3>
        <p>避免非必要的嵌套。这是因为虽然你可以使用嵌套，但是并不意味着应该使用嵌套。只有在必须将样式限制在父元素内（也就是后代选择器），并且存在多个需要嵌套的元素时才使用嵌套。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="scss"><span class="c1">// Without nesting</span>
<span class="nc">.table</span> <span class="o">&gt;</span> <span class="nt">thead</span> <span class="o">&gt;</span> <span class="nt">tr</span> <span class="o">&gt;</span> <span class="nt">th</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="nc">.table</span> <span class="o">&gt;</span> <span class="nt">thead</span> <span class="o">&gt;</span> <span class="nt">tr</span> <span class="o">&gt;</span> <span class="nt">td</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

<span class="c1">// With nesting</span>
<span class="nc">.table</span> <span class="o">&gt;</span> <span class="nt">thead</span> <span class="o">&gt;</span> <span class="nt">tr</span> <span class="p">{</span>
  <span class="o">&gt;</span> <span class="nt">th</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
  <span class="o">&gt;</span> <span class="nt">td</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-comments">
    <div class="col">
        <h3>注释</h3>
        <p>代码是由人编写并维护的。请确保你的代码能够自描述、注释良好并且易于他人理解。好的代码注释能够传达上下文关系和代码目的。不要简单地重申组件或 class 名称。</p>
        <p>对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/* Bad example */</span>
<span class="c">/* Modal header */</span>
<span class="nc">.modal-header</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="c">/* Good example */</span>
<span class="c">/* Wrapping element for .modal-title and .modal-close */</span>
<span class="nc">.modal-header</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-classes">
    <div class="col">
        <h3>class 命名</h3>
        <ul>
            <li>class 名称中只能出现小写字符和破折号（dashe）（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，<code>.btn</code> 和 <code>.btn-danger</code>）。</li>
            <li>避免过度任意的简写。<code>.btn</code> 代表 <em>button</em>，但是 <code>.s</code> 不能表达任何意思。</li>
            <li>class 名称应当尽可能短，并且意义明确。</li>
            <li>使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。</li>
            <li>基于最近的父 class 或基本（base） class 作为新 class 的前缀。</li>
            <li>使用 <code>.js-*</code> class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。</li>
        </ul>
        <p>在为 Sass 和 Less 变量命名是也可以参考上面列出的各项规范。</p>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/* Bad example */</span>
<span class="nc">.t</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.red</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.header</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c">/* Good example */</span>
<span class="nc">.tweet</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.important</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.tweet-header</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-selectors">
    <div class="col">
        <h3>选择器</h3>
        <ul>
            <li>对于通用元素使用 class ，这样利于渲染性能的优化。</li>
            <li>对于经常出现的组件，避免使用属性选择器（例如，<code>[class^="..."]</code>）。浏览器的性能会受到这些因素的影响。</li>
            <li>选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。</li>
            <li><strong>只有</strong>在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的 class 时 &#8211; 前缀类似于命名空间）。</li>
        </ul>
        <p>扩展阅读：</p>
        <ul>
            <li><a href="http://markdotto.com/2012/02/16/scope-css-classes-with-prefixes/">Scope CSS classes with prefixes</a></li>
            <li><a href="http://markdotto.com/2012/03/02/stop-the-cascade/">Stop the cascade</a></li>
        </ul>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/* Bad example */</span>
<span class="nt">span</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.page-container</span> <span class="nf">#stream</span> <span class="nc">.stream-item</span> <span class="nc">.tweet</span> <span class="nc">.tweet-header</span> <span class="nc">.username</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.avatar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c">/* Good example */</span>
<span class="nc">.avatar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.tweet-header</span> <span class="nc">.username</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="nc">.tweet</span> <span class="nc">.avatar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-organization">
    <div class="col">
        <h3>代码组织</h3>
        <ul>
            <li>以组件为单位组织代码段。</li>
            <li>制定一致的注释规范。</li>
            <li>使用一致的空白符将代码分隔成块，这样利于扫描较大的文档。</li>
            <li>如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动。</li>
        </ul>
    </div>
    <div class="col">
        <div class="highlight"><pre class='green'><code class="css"><span class="c">/*</span>
<span class="c"> * Component section heading</span>
<span class="c"> */</span>

<span class="nc">.element</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>


<span class="c">/*</span>
<span class="c"> * Component section heading</span>
<span class="c"> *</span>
<span class="c"> * Sometimes you need to include optional context for the entire component. Do that up here if it's important enough.</span>
<span class="c"> */</span>

<span class="nc">.element</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c">/* Contextual sub-component or modifer */</span>
<span class="nc">.element-heading</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div>
    </div>
</div>
<div class="section" id="css-editor-prefs">
    <div class="col">
        <h3>编辑器配置</h3>
        <p>将你的编辑器按照下面的配置进行设置，以避免常见的代码不一致和差异：</p>
        <ul>
            <li>用两个空格代替制表符（soft-tab 即用空格代表 tab 符）。</li>
            <li>保存文件时，删除尾部的空白符。</li>
            <li>设置文件编码为 UTF-8。</li>
            <li>在文件结尾添加一个空白行。</li>
        </ul>
        <p>参照文档并将这些配置信息添加到项目的 <code>.editorconfig</code> 文件中。例如：<a href="https://github.com/twbs/bootstrap/blob/master/.editorconfig">Bootstrap 中的 .editorconfig 实例</a>。更多信息请参考 <a href="http://editorconfig.org/">about EditorConfig</a>。</p>
    </div>
</div>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa25e97c8b6d0ae5501b3b46d61ed807f' type='text/javascript'%3E%3C/script%3E"));
</script>
<script src=" http://hm.baidu.com/h.js?a25e97c8b6d0ae5501b3b46d61ed807f" type="text/javascript"></script>
<script src="./编码规范_files/h.js" type="text/javascript"></script>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/09/qian-duan-javascriptgui-fan/">前端JavaScript规范</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-09T23:18:20+08:00" pubdate data-updated="true">May 9<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/05/09/qian-duan-javascriptgui-fan/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/05/09/qian-duan-javascriptgui-fan/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="MathJax_Message" style="display: none;"></div><div class="container"><h1 id="javascript规范">JavaScript规范</h1>



<h2 id="目录"><a>目录</a></h2>

<ol>
<li><a href="#types">类型</a></li>
<li><a href="#objects">对象</a></li>
<li><a href="#arrays">数组</a></li>
<li><a href="#strings">字符串</a></li>
<li><a href="#functions">函数</a></li>
<li><a href="#properties">属性</a></li>
<li><a href="#variables">变量</a></li>
<li><a href="#conditionals">条件表达式和等号</a></li>
<li><a href="#blocks">块</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#whitespace">空白</a></li>
<li><a href="#commas">逗号</a></li>
<li><a href="#semicolons">分号</a></li>
<li><a href="#type-coercion">类型转换</a></li>
<li><a href="#naming-conventions">命名约定</a></li>
<li><a href="#accessors">存取器</a></li>
<li><a href="#constructors">构造器</a></li>
<li><a href="#events">事件</a></li>
<li><a href="#modules">模块</a></li>
<li><a href="#jquery">jQuery</a></li>
<li><a href="#es5">ES5 兼容性</a></li>
<li><a href="#html-css-js">HTML、CSS、JavaScript分离</a></li>
<li><a href="#jshint">使用jsHint</a></li>
<li><a href="#tools">前端工具</a></li>
</ol>

<h2 id="类型"><a>类型</a></h2>

<ul>
<li><p><strong>原始值</strong>: 相当于传值(JavaScript对象都提供了字面量)，使用字面量创建对象。</p>

<ul><li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li></ul>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>,
    bar = foo;

bar = <span class="hljs-number">9</span>;

console.log(foo, bar); <span class="hljs-comment">// =&gt; 1, 9</span></code></pre></li>
<li><p><strong>复杂类型</strong>: 相当于传引用</p>

<ul><li><code>object</code></li>
<li><code>array</code></li>
<li><code>function</code></li></ul>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> foo = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
    bar = foo;

bar[<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>;

console.log(foo[<span class="hljs-number">0</span>], bar[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; 9, 9</span></code></pre></li>
</ul>



<h2 id="对象"><a>对象</a></h2>

<ul>
<li><p>使用字面值创建对象</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> item = {};</code></pre></li>
<li><p>不要使用保留字 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Reserved_Words">reserved words</a> 作为键</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> superman = {
  <span class="hljs-keyword">class</span>: <span class="hljs-string">'superhero'</span>,
  <span class="hljs-keyword">default</span>: { clark: <span class="hljs-string">'kent'</span> },
  private: <span class="hljs-literal">true</span>
};

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> superman = {
  klass: <span class="hljs-string">'superhero'</span>,
  defaults: { clark: <span class="hljs-string">'kent'</span> },
  hidden: <span class="hljs-literal">true</span>
};</code></pre></li>
</ul>



<h2 id="数组"><a>数组</a></h2>

<ul>
<li><p>使用字面值创建数组</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> items = [];</code></pre></li>
<li><p>如果你不知道数组的长度，使用push</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> someStack = [];


<span class="hljs-comment">// bad</span>
someStack[someStack.length] = <span class="hljs-string">'abracadabra'</span>;

<span class="hljs-comment">// good</span>
someStack.push(<span class="hljs-string">'abracadabra'</span>);</code></pre></li>
<li><p>当你需要拷贝数组时使用slice. <a href="http://jsperf.com/converting-arguments-to-an-array/7">jsPerf</a></p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> len = items.length,
    itemsCopy = [],
    i;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
  itemsCopy[i] = items[i];
}

<span class="hljs-comment">// good</span>
itemsCopy = items.slice();</code></pre></li>
<li><p>使用slice将类数组的对象转成数组.</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trigger</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> args = [].slice.apply(<span class="hljs-built_in">arguments</span>);
  ...
}</code></pre></li>
</ul>



<h2 id="字符串"><a>字符串</a></h2>

<ul>
<li><p>对字符串使用单引号 <code>''</code>(因为大多时候我们的字符串。特别html会出现<code>"</code>)</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">"Bob Parr"</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">'Bob Parr'</span>;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> fullName = <span class="hljs-string">"Bob "</span> + <span class="hljs-keyword">this</span>.lastName;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> fullName = <span class="hljs-string">'Bob '</span> + <span class="hljs-keyword">this</span>.lastName;</code></pre></li>
<li><p>超过80(也有规定140的，项目具体可制定)个字符的字符串应该使用字符串连接换行</p></li>
<li><p>注: 如果过度使用，长字符串连接可能会对性能有影响. <a href="http://jsperf.com/ya-string-concat">jsPerf</a> &amp; <a href="https://github.com/airbnb/javascript/issues/40">Discussion</a></p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> errorMessage = <span class="hljs-string">'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'</span>;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> errorMessage = <span class="hljs-string">'This is a super long error that \
was thrown because of Batman. \
When you stop to think about \
how Batman had anything to do \
with this, you would get nowhere \
fast.'</span>;


<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> errorMessage = <span class="hljs-string">'This is a super long error that '</span> +
  <span class="hljs-string">'was thrown because of Batman.'</span> +
  <span class="hljs-string">'When you stop to think about '</span> +
  <span class="hljs-string">'how Batman had anything to do '</span> +
  <span class="hljs-string">'with this, you would get nowhere '</span> +
  <span class="hljs-string">'fast.'</span>;</code></pre></li>
<li><p>编程时使用join而不是字符串连接来构建字符串，特别是IE: <a href="http://jsperf.com/string-vs-array-concat/2">jsPerf</a>.</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> items,
    messages,
    length, i;

messages = [{
    state: <span class="hljs-string">'success'</span>,
    message: <span class="hljs-string">'This one worked.'</span>
},{
    state: <span class="hljs-string">'success'</span>,
    message: <span class="hljs-string">'This one worked as well.'</span>
},{
    state: <span class="hljs-string">'error'</span>,
    message: <span class="hljs-string">'This one did not work.'</span>
}];

length = messages.length;

<span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inbox</span><span class="hljs-params">(messages)</span> {</span>
  items = <span class="hljs-string">'&lt;ul&gt;'</span>;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    items += <span class="hljs-string">'&lt;li&gt;'</span> + messages[i].message + <span class="hljs-string">'&lt;/li&gt;'</span>;
  }

  <span class="hljs-keyword">return</span> items + <span class="hljs-string">'&lt;/ul&gt;'</span>;
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inbox</span><span class="hljs-params">(messages)</span> {</span>
  items = [];

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    items[i] = messages[i].message;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;ul&gt;&lt;li&gt;'</span> + items.join(<span class="hljs-string">'&lt;/li&gt;&lt;li&gt;'</span>) + <span class="hljs-string">'&lt;/li&gt;&lt;/ul&gt;'</span>;
}</code></pre></li>
</ul>



<h2 id="函数"><a>函数</a></h2>

<ul>
<li><p>函数表达式:</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// 匿名函数表达式</span>
<span class="hljs-keyword">var</span> anonymous = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-comment">// 有名函数表达式</span>
<span class="hljs-keyword">var</span> named = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">named</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-comment">// 立即调用函数表达式</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'Welcome to the Internet. Please follow me.'</span>);
})();</code></pre></li>
<li><p>绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同。</p></li>
<li><p><strong>注:</strong> ECMA-262定义把<code>块</code>定义为一组语句，函数声明不是一个语句。<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97">阅读ECMA-262对这个问题的说明</a>.</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">if</span> (currentUser) {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-string">'Nope.'</span>);
  }
}

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (currentUser) {
  <span class="hljs-keyword">var</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-string">'Yup.'</span>);
  };
}</code></pre></li>
<li><p>绝对不要把参数命名为 <code>arguments</code>, 这将会逾越函数作用域内传过来的 <code>arguments</code> 对象.</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nope</span><span class="hljs-params">(name, options, arguments)</span> {</span>
  <span class="hljs-comment">// ...stuff...</span>
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yup</span><span class="hljs-params">(name, options, args)</span> {</span>
  <span class="hljs-comment">// ...stuff...</span>
}</code></pre></li>
</ul>



<h2 id="属性"><a>属性</a></h2>

<ul>
<li><p>当使用变量和特殊非法变量名时，访问属性时可以使用中括号(<code>.</code> 优先).</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> luke = {
  jedi: <span class="hljs-literal">true</span>,
  age: <span class="hljs-number">28</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProp</span><span class="hljs-params">(prop)</span> {</span>
  <span class="hljs-keyword">return</span> luke[prop];
}

<span class="hljs-keyword">var</span> isJedi = getProp(<span class="hljs-string">'jedi'</span>);</code></pre></li>
</ul>



<h2 id="变量"><a>变量</a></h2>

<ul>
<li><p>总是使用 <code>var</code> 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
superPower = <span class="hljs-keyword">new</span> SuperPower();

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> superPower = <span class="hljs-keyword">new</span> SuperPower();</code></pre></li>
<li><p>使用一个 <code>var</code> 以及新行声明多个变量，缩进4个空格。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> items = getItems();
<span class="hljs-keyword">var</span> goSportsTeam = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> dragonball = <span class="hljs-string">'z'</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> items = getItems(),
    goSportsTeam = <span class="hljs-literal">true</span>,
    dragonball = <span class="hljs-string">'z'</span>;</code></pre></li>
<li><p>最后再声明未赋值的变量，当你想引用之前已赋值变量的时候很有用。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> i, len, dragonball,
    items = getItems(),
    goSportsTeam = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> i, items = getItems(),
    dragonball,
    goSportsTeam = <span class="hljs-literal">true</span>,
    len;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> items = getItems(),
    goSportsTeam = <span class="hljs-literal">true</span>,
    dragonball,
    length,
    i;</code></pre></li>
<li><p>在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  test();
  console.log(<span class="hljs-string">'doing stuff..'</span>);

  <span class="hljs-comment">//..other stuff..</span>

  <span class="hljs-keyword">var</span> name = getName();

  <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'test'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> name;
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> name = getName();

  test();
  console.log(<span class="hljs-string">'doing stuff..'</span>);

  <span class="hljs-comment">//..other stuff..</span>

  <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'test'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> name;
}

<span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> name = getName();

  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">var</span> name = getName();

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</code></pre></li>
</ul>



<h2 id="条件表达式和等号"><a>条件表达式和等号</a></h2>

<ul>
<li>合理使用 <code>===</code> 和 <code>!==</code> 以及 <code>==</code> 和 <code>!=</code>.</li>
<li>合理使用表达式逻辑操作运算.</li>
<li><p>条件表达式的强制类型转换遵循以下规则：</p>

<ul><li><strong>对象</strong> 被计算为 <strong>true</strong></li>
<li><strong>Undefined</strong> 被计算为 <strong>false</strong></li>
<li><strong>Null</strong> 被计算为 <strong>false</strong></li>
<li><strong>布尔值</strong> 被计算为 <strong>布尔的值</strong></li>
<li><strong>数字</strong> 如果是 <strong>+0, -0, or NaN</strong> 被计算为 <strong>false</strong> , 否则为 <strong>true</strong></li>
<li><strong>字符串</strong> 如果是空字符串 <code>''</code> 则被计算为 <strong>false</strong>, 否则为 <strong>true</strong></li></ul>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">if</span> ([<span class="hljs-number">0</span>]) {
  <span class="hljs-comment">// true</span>
  <span class="hljs-comment">// An array is an object, objects evaluate to true</span>
}</code></pre></li>
<li><p>使用快捷方式.</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">if</span> (name !== <span class="hljs-string">''</span>) {
  <span class="hljs-comment">// ...stuff...</span>
}

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (name) {
  <span class="hljs-comment">// ...stuff...</span>
}

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">if</span> (collection.length &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-comment">// ...stuff...</span>
}

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (collection.length) {
  <span class="hljs-comment">// ...stuff...</span>
}</code></pre></li>
<li><p>阅读 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108">Truth Equality and JavaScript</a> 了解更多</p></li>
</ul>



<h2 id="块"><a>块</a></h2>

<ul>
<li><p>给所有多行的块使用大括号</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">if</span> (test)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (test) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (test) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</code></pre></li>
</ul>



<h2 id="注释"><a>注释</a></h2>

<ul>
<li><p>使用 <code>/** ... */</code> 进行多行注释，包括描述，指定类型以及参数值和返回值</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-comment">// make() returns a new element</span>
<span class="hljs-comment">// based on the passed in tag name</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// @param &lt;String&gt; tag</span>
<span class="hljs-comment">// @return &lt;Element&gt; element</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span><span class="hljs-params">(tag)</span> {</span>

  <span class="hljs-comment">// ...stuff...</span>

  <span class="hljs-keyword">return</span> element;
}

<span class="hljs-comment">// good</span>
<span class="hljs-comment">/**
 * make() returns a new element
 * based on the passed in tag name
 *
 * @param &lt;String&gt; tag
 * @return &lt;Element&gt; element
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span><span class="hljs-params">(tag)</span> {</span>

  <span class="hljs-comment">// ...stuff...</span>

  <span class="hljs-keyword">return</span> element;
}</code></pre></li>
<li><p>使用 <code>//</code> 进行单行注释，在评论对象的上面进行单行注释，注释前放一个空行.</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> active = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// is current tab</span>

<span class="hljs-comment">// good</span>
<span class="hljs-comment">// is current tab</span>
<span class="hljs-keyword">var</span> active = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'fetching type...'</span>);
  <span class="hljs-comment">// set the default type to 'no type'</span>
  <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._type || <span class="hljs-string">'no type'</span>;

  <span class="hljs-keyword">return</span> type;
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'fetching type...'</span>);

  <span class="hljs-comment">// set the default type to 'no type'</span>
  <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._type || <span class="hljs-string">'no type'</span>;

  <span class="hljs-keyword">return</span> type;
}</code></pre></li>
<li><p>如果你有一个问题需要重新来看一下或如果你建议一个需要被实现的解决方法的话需要在你的注释前面加上 <code>FIXME</code> 或 <code>TODO</code> 帮助其他人迅速理解</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Calculator</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-comment">// FIXME: shouldn't use a global here</span>
  total = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}</code></pre>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Calculator</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-comment">// TODO: total should be configurable by an options param</span>
  <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}</code></pre></li>
<li>满足规范的文档，在需要文档的时候，可以尝试<a href="http://usejsdoc.org/">jsdoc</a>.</li>
</ul>



<h2 id="空白"><a>空白</a></h2>

<ul>
<li>缩进、格式化能帮助团队更快得定位修复代码BUG.</li>
<li><p>将tab设为4个空格</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
∙∙<span class="hljs-keyword">var</span> name;
}

<span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
∙<span class="hljs-keyword">var</span> name;
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
∙∙∙∙<span class="hljs-keyword">var</span> name;
}</code></pre></li>
<li><p>大括号前放一个空格</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>{</span>
  console.log(<span class="hljs-string">'test'</span>);
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'test'</span>);
}

<span class="hljs-comment">// bad</span>
dog.set(<span class="hljs-string">'attr'</span>,{
  age: <span class="hljs-string">'1 year'</span>,
  breed: <span class="hljs-string">'Bernese Mountain Dog'</span>
});

<span class="hljs-comment">// good</span>
dog.set(<span class="hljs-string">'attr'</span>, {
  age: <span class="hljs-string">'1 year'</span>,
  breed: <span class="hljs-string">'Bernese Mountain Dog'</span>
});</code></pre></li>
<li><p>在做长方法链时使用缩进.</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
$(<span class="hljs-string">'#items'</span>).find(<span class="hljs-string">'.selected'</span>).highlight().end().find(<span class="hljs-string">'.open'</span>).updateCount();

<span class="hljs-comment">// good</span>
$(<span class="hljs-string">'#items'</span>)
  .find(<span class="hljs-string">'.selected'</span>)
    .highlight()
    .end()
  .find(<span class="hljs-string">'.open'</span>)
    .updateCount();

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> leds = stage.selectAll(<span class="hljs-string">'.led'</span>).data(data).enter().append(<span class="hljs-string">'svg:svg'</span>).class(<span class="hljs-string">'led'</span>, <span class="hljs-literal">true</span>)
    .attr(<span class="hljs-string">'width'</span>,  (radius + margin) * <span class="hljs-number">2</span>).append(<span class="hljs-string">'svg:g'</span>)
    .attr(<span class="hljs-string">'transform'</span>, <span class="hljs-string">'translate('</span> + (radius + margin) + <span class="hljs-string">','</span> + (radius + margin) + <span class="hljs-string">')'</span>)
    .call(tron.led);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> leds = stage.selectAll(<span class="hljs-string">'.led'</span>)
    .data(data)
  .enter().append(<span class="hljs-string">'svg:svg'</span>)
    .class(<span class="hljs-string">'led'</span>, <span class="hljs-literal">true</span>)
    .attr(<span class="hljs-string">'width'</span>,  (radius + margin) * <span class="hljs-number">2</span>)
  .append(<span class="hljs-string">'svg:g'</span>)
    .attr(<span class="hljs-string">'transform'</span>, <span class="hljs-string">'translate('</span> + (radius + margin) + <span class="hljs-string">','</span> + (radius + margin) + <span class="hljs-string">')'</span>)
    .call(tron.led);</code></pre></li>
</ul>



<h2 id="逗号"><a>逗号</a></h2>

<ul>
<li><p>不要将逗号放前面</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> once
  , upon
  , aTime;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> once,
    upon,
    aTime;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> hero = {
    firstName: <span class="hljs-string">'Bob'</span>
  , lastName: <span class="hljs-string">'Parr'</span>
  , heroName: <span class="hljs-string">'Mr. Incredible'</span>
  , superPower: <span class="hljs-string">'strength'</span>
};

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> hero = {
  firstName: <span class="hljs-string">'Bob'</span>,
  lastName: <span class="hljs-string">'Parr'</span>,
  heroName: <span class="hljs-string">'Mr. Incredible'</span>,
  superPower: <span class="hljs-string">'strength'</span>
};</code></pre></li>
<li><p>不要加多余的逗号，这可能会在IE下引起错误，同时如果多一个逗号某些ES3的实现会计算多数组的长度。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> hero = {
  firstName: <span class="hljs-string">'Kevin'</span>,
  lastName: <span class="hljs-string">'Flynn'</span>,
};

<span class="hljs-keyword">var</span> heroes = [
  <span class="hljs-string">'Batman'</span>,
  <span class="hljs-string">'Superman'</span>,
];

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> hero = {
  firstName: <span class="hljs-string">'Kevin'</span>,
  lastName: <span class="hljs-string">'Flynn'</span>
};

<span class="hljs-keyword">var</span> heroes = [
  <span class="hljs-string">'Batman'</span>,
  <span class="hljs-string">'Superman'</span>
];</code></pre></li>
</ul>



<h2 id="分号"><a>分号</a></h2>

<ul>
<li><p>语句结束一定要加分号</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Skywalker'</span>
  <span class="hljs-keyword">return</span> name
})()

<span class="hljs-comment">// good</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Skywalker'</span>;
  <span class="hljs-keyword">return</span> name;
})();

<span class="hljs-comment">// good</span>
;(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Skywalker'</span>;
  <span class="hljs-keyword">return</span> name;
})();</code></pre></li>
</ul>



<h2 id="类型转换"><a>类型转换</a></h2>

<ul>
<li>在语句的开始执行类型转换.</li>
<li><p>字符串:</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">//  =&gt; this.reviewScore = 9;</span>

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> totalScore = <span class="hljs-keyword">this</span>.reviewScore + <span class="hljs-string">''</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> totalScore = <span class="hljs-string">''</span> + <span class="hljs-keyword">this</span>.reviewScore;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> totalScore = <span class="hljs-string">''</span> + <span class="hljs-keyword">this</span>.reviewScore + <span class="hljs-string">' total score'</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> totalScore = <span class="hljs-keyword">this</span>.reviewScore + <span class="hljs-string">' total score'</span>;</code></pre></li>
<li><p>对数字使用 <code>parseInt</code> 并且总是带上类型转换的基数.，如<code>parseInt(value, 10)</code></p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> inputValue = <span class="hljs-string">'4'</span>;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> val = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(inputValue);

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> val = +inputValue;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> val = inputValue &gt;&gt; <span class="hljs-number">0</span>;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> val = <span class="hljs-built_in">parseInt</span>(inputValue);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> val = <span class="hljs-built_in">Number</span>(inputValue);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> val = <span class="hljs-built_in">parseInt</span>(inputValue, <span class="hljs-number">10</span>);

<span class="hljs-comment">// good</span>
<span class="hljs-comment">/**
 * parseInt was the reason my code was slow.
 * Bitshifting the String to coerce it to a
 * Number made it a lot faster.
 */</span>
<span class="hljs-keyword">var</span> val = inputValue &gt;&gt; <span class="hljs-number">0</span>;</code></pre></li>
<li><p>布尔值:</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span>;

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> hasAge = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(age);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> hasAge = <span class="hljs-built_in">Boolean</span>(age);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> hasAge = !!age;</code></pre></li>
</ul>



<h2 id="命名约定"><a>命名约定</a></h2>

<ul>
<li><p>避免单个字符名，让你的变量名有描述意义。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">q</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-comment">// ...stuff...</span>
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-comment">// ..stuff..</span>
}</code></pre></li>
<li><p>当命名对象、函数和实例时使用驼峰命名规则</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> OBJEcttsssss = {};
<span class="hljs-keyword">var</span> this_is_my_object = {};
<span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>-is-my-object = {};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> {</span>};
<span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> user({
  name: <span class="hljs-string">'Bob Parr'</span>
});

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> thisIsMyObject = {};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thisIsMyFunction</span><span class="hljs-params">()</span> {</span>};
<span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User({
  name: <span class="hljs-string">'Bob Parr'</span>
});</code></pre></li>
<li><p>当命名构造函数或类时使用驼峰式大写</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">user</span><span class="hljs-params">(options)</span> {</span>
  <span class="hljs-keyword">this</span>.name = options.name;
}

<span class="hljs-keyword">var</span> bad = <span class="hljs-keyword">new</span> user({
  name: <span class="hljs-string">'nope'</span>
});

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span><span class="hljs-params">(options)</span> {</span>
  <span class="hljs-keyword">this</span>.name = options.name;
}

<span class="hljs-keyword">var</span> good = <span class="hljs-keyword">new</span> User({
  name: <span class="hljs-string">'yup'</span>
});</code></pre></li>
<li><p>命名私有属性时前面加个下划线 <code>_</code></p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">this</span>.__firstName__ = <span class="hljs-string">'Panda'</span>;
<span class="hljs-keyword">this</span>.firstName_ = <span class="hljs-string">'Panda'</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">this</span>._firstName = <span class="hljs-string">'Panda'</span>;</code></pre></li>
<li><p>当保存对 <code>this</code> 的引用时使用 <code>self(python 风格)</code>,避免<code>this issue</code>.Angular建议使用<code>vm(MVVM模式中view-model)</code></p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    console.log(self);
  };
}</code></pre></li>
</ul>



<h2 id="存取器"><a>存取器</a></h2>

<ul>
<li>属性的存取器函数不是必需的</li>
<li><p>如果你确实有存取器函数的话使用getVal() 和 setVal(‘hello’),<code>java getter、setter风格</code>或者<code>jQuery风格</code></p></li>
<li><p>如果属性是布尔值，使用isVal() 或 hasVal()</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">if</span> (!dragon.age()) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (!dragon.hasAge()) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</code></pre></li>
<li><p>可以创建get()和set()函数，但是要保持一致</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Jedi</span><span class="hljs-params">(options)</span> {</span>
  options || (options = {});
  <span class="hljs-keyword">var</span> lightsaber = options.lightsaber || <span class="hljs-string">'blue'</span>;
  <span class="hljs-keyword">this</span>.set(<span class="hljs-string">'lightsaber'</span>, lightsaber);
}

Jedi.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, val)</span> {</span>
  <span class="hljs-keyword">this</span>[key] = val;
};

Jedi.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[key];
};</code></pre></li>
</ul>



<h2 id="构造器"><a>构造器</a></h2>

<ul>
<li><p>给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Jedi</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'new jedi'</span>);
}

<span class="hljs-comment">// bad</span>
Jedi.prototype = {
  fight: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-string">'fighting'</span>);
  },

  block: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-string">'blocking'</span>);
  }
};

<span class="hljs-comment">// good</span>
Jedi.prototype.fight = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'fighting'</span>);
};

Jedi.prototype.block = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'blocking'</span>);
};</code></pre></li>
<li><p>方法可以返回 <code>this</code> 帮助方法可链。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
Jedi.prototype.jump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.jumping = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

Jedi.prototype.setHeight = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(height)</span> {</span>
  <span class="hljs-keyword">this</span>.height = height;
};

<span class="hljs-keyword">var</span> luke = <span class="hljs-keyword">new</span> Jedi();
luke.jump(); <span class="hljs-comment">// =&gt; true</span>
luke.setHeight(<span class="hljs-number">20</span>) <span class="hljs-comment">// =&gt; undefined</span>

<span class="hljs-comment">// good</span>
Jedi.prototype.jump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.jumping = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

Jedi.prototype.setHeight = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(height)</span> {</span>
  <span class="hljs-keyword">this</span>.height = height;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

<span class="hljs-keyword">var</span> luke = <span class="hljs-keyword">new</span> Jedi();

luke.jump()
  .setHeight(<span class="hljs-number">20</span>);</code></pre></li>
<li><p>可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Jedi</span><span class="hljs-params">(options)</span> {</span>
  options || (options = {});
  <span class="hljs-keyword">this</span>.name = options.name || <span class="hljs-string">'no name'</span>;
}

Jedi.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
};

Jedi.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Jedi - '</span> + <span class="hljs-keyword">this</span>.getName();
};</code></pre></li>
</ul>



<h2 id="事件"><a>事件</a></h2>

<ul>
<li><p>当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器</p>

<pre class="prettyprint"><code class="language-js hljs "><span class="hljs-comment">// bad</span>
$(<span class="hljs-keyword">this</span>).trigger(<span class="hljs-string">'listingUpdated'</span>, listing.id);

...

$(<span class="hljs-keyword">this</span>).on(<span class="hljs-string">'listingUpdated'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e, listingId)</span> {</span>
  <span class="hljs-comment">// do something with listingId</span>
});</code></pre>

<p>更好:</p>

<pre class="prettyprint"><code class="language-js hljs "><span class="hljs-comment">// good</span>
$(<span class="hljs-keyword">this</span>).trigger(<span class="hljs-string">'listingUpdated'</span>, { listingId : listing.id });

...

$(<span class="hljs-keyword">this</span>).on(<span class="hljs-string">'listingUpdated'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e, data)</span> {</span>
  <span class="hljs-comment">// do something with data.listingId</span>
});</code></pre></li>
</ul>



<h2 id="模块"><a>模块</a></h2>

<ul>
<li>这个文件应该以驼峰命名，并在同名文件夹下，同时导出的时候名字一致</li>
<li>对于公开API库可以考虑加入一个名为noConflict()的方法来设置导出的模块为之前的版本并返回它</li>
<li><p>总是在模块顶部声明 <code>'use strict';</code>，引入<code>[JSHint规范](http://jshint.com/)</code></p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// fancyInput/fancyInput.js</span>

（<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(global)</span> {</span>
<span class="hljs-pi">  'use strict'</span>;

  <span class="hljs-keyword">var</span> previousFancyInput = global.FancyInput;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FancyInput</span><span class="hljs-params">(options)</span> {</span>
    <span class="hljs-keyword">this</span>.options = options || {};
  }

  FancyInput.noConflict = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noConflict</span><span class="hljs-params">()</span> {</span>
    global.FancyInput = previousFancyInput;
    <span class="hljs-keyword">return</span> FancyInput;
  };

  global.FancyInput = FancyInput;
})(<span class="hljs-keyword">this</span>);</code></pre></li>
</ul>



<h2 id="jquery"><a>jQuery</a></h2>

<ul>
<li><p>对于jQuery对象以<code>$</code>开头，以和原生DOM节点区分。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> menu = $(<span class="hljs-string">".menu"</span>);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">var</span> $menu = $(<span class="hljs-string">".menu"</span>);</code></pre></li>
<li><p>缓存jQuery查询</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSidebar</span><span class="hljs-params">()</span> {</span>
  $(<span class="hljs-string">'.sidebar'</span>).hide();

  <span class="hljs-comment">// ...stuff...</span>

  $(<span class="hljs-string">'.sidebar'</span>).css({
    <span class="hljs-string">'background-color'</span>: <span class="hljs-string">'pink'</span>
  });
}

<span class="hljs-comment">// good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSidebar</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> $sidebar = $(<span class="hljs-string">'.sidebar'</span>);
  $sidebar.hide();

  <span class="hljs-comment">// ...stuff...</span>

  $sidebar.css({
    <span class="hljs-string">'background-color'</span>: <span class="hljs-string">'pink'</span>
  });
}</code></pre></li>
<li><p>对DOM查询使用级联的 <code>$('.sidebar ul')</code> 或 <code>$('.sidebar ul')</code>，<a href="http://jsperf.com/jquery-find-vs-context-sel/16">jsPerf</a></p></li>
<li><p>对有作用域的jQuery对象查询使用 <code>find</code></p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
$(<span class="hljs-string">'.sidebar'</span>, <span class="hljs-string">'ul'</span>).hide();

<span class="hljs-comment">// bad</span>
$(<span class="hljs-string">'.sidebar'</span>).find(<span class="hljs-string">'ul'</span>).hide();

<span class="hljs-comment">// good</span>
$(<span class="hljs-string">'.sidebar ul'</span>).hide();

<span class="hljs-comment">// good</span>
$(<span class="hljs-string">'.sidebar &gt; ul'</span>).hide();

<span class="hljs-comment">// good (slower)</span>
$sidebar.find(<span class="hljs-string">'ul'</span>);

<span class="hljs-comment">// good (faster)</span>
$($sidebar[<span class="hljs-number">0</span>]).find(<span class="hljs-string">'ul'</span>);</code></pre></li>
<li><p>每个页面只使用一次document的ready事件，这样便于调试与行为流跟踪。</p>

<pre class="prettyprint"><code class="language-javascript hljs ">$(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
   <span class="hljs-comment">//do your page init.  </span>
});</code></pre></li>
<li><p>事件利用<code>jQuery.on</code>从页面分离到JavaScript文件。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// bad</span>
&lt;a id=<span class="hljs-string">"myLink"</span> href=<span class="hljs-string">"#"</span> onclick=<span class="hljs-string">"myEventHandler();"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>

// good
<span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"myLink"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"#"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>

$("#myLink").on("click", myEventHandler);
</span></code></pre></li>
<li><p>对于Ajax使用promise方式。</p>

<pre class="prettyprint"><code class="language-javascript hljs ">    <span class="hljs-comment">// bad</span>
    $.ajax({
        ...
        success : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        },
        error : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        } 
    })

    <span class="hljs-comment">// good</span>
    $.ajax({.
        ..
    }).then( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( )</span>{</span>
        <span class="hljs-comment">// success</span>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( )</span>{</span>
        <span class="hljs-comment">// error</span>
    })</code></pre></li>
<li><p>利用promise的deferred对象解决延迟注册问题。</p>

<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> dtd = $.Deferred(); <span class="hljs-comment">// 新建一个deferred对象</span>
　　<span class="hljs-keyword">var</span> wait = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(dtd)</span>{</span>
　　　　<span class="hljs-keyword">var</span> tasks = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
　　　　　　alert(<span class="hljs-string">"执行完毕！"</span>);
　　　　　　dtd.resolve(); <span class="hljs-comment">// 改变deferred对象的执行状态</span>
　　　　};
　　　　setTimeout(tasks,<span class="hljs-number">5000</span>);
　　　　<span class="hljs-keyword">return</span> dtd;
　　};</code></pre></li>
<li>HTML中Style、以及JavaScript中style移到CSS中class，在HTML、JavaScript中引入class，而不是直接style。</li>
</ul>



<h2 id="ecmascript-5兼容性"><a>ECMAScript 5兼容性</a></h2>

<p>尽量采用ES5方法，特别数组map、filter、forEach方法简化日常开发。在老式IE浏览器中引入<a href="https://github.com/es-shims/es5-shim">ES5-shim</a>。或者也可以考虑引入<a href="http://underscorejs.org/">underscore</a>、<a href="https://lodash.com/">lodash</a> 常用辅助库. <br>
  - 参考<a href="https://twitter.com/kangax/">Kangax</a>的 ES5 <a href="http://kangax.github.com/es5-compat-table/">compatibility table</a> <br>
 - <a href="http://www.cnblogs.com/whitewolf/p/4417873.html">JavaScript工具库之Lodash</a> <br>
 - <a href="http://www.cnblogs.com/whitewolf/p/4357916.html">Babel-现在开始使用 ES6</a></p>



<h2 id="htmlcssjavascript分离"><a>HTML、CSS、JavaScript分离</a></h2>

<ul>
<li>页面DOM结构使用HTML，样式则采用CSS，动态DOM操作JavaScript。不要混用在HTML中</li>
<li>分离在不同类型文件，文件link。</li>
<li>HTML、CSS、JavaScript变量名都需要有业务价值。CSS以中划线分割的全小写命名，JavaScript则首字母小写的驼峰命名。</li>
<li>CSS可引入Bootstrap、Foundation等出名响应式设计框架。以及SASS、LESS工具书写CSS。</li>
<li>对于CSS、JavaScript建议合并为单文件，减少Ajax的连接数。也可以引入AMD(Require.js)加载方式。</li>
<li>对于内部大部分企业管理系统，可以尝试采用前端 MVC框架组织代码。如Angular、React + flux架构、Knockout等。</li>
<li>对于兼容性可用<a href="http://modernizr.com/">Modernizr</a>规范库辅助。</li>
</ul>



<h2 id="使用jshint"><a>使用jsHint</a></h2>

<ul>
<li>前端项目中推荐引入<a href="http://jshint.com/">jshint</a>插件来规范项目编码规范。以及一套完善的IDE配置。</li>
<li>注意：jshint需要引入nodejs 工具grunt或gulp插件，建议企业级nodejs npm私服。</li>
</ul>



<h2 id="前端工具"><a>前端工具</a></h2>

<ul>
<li>前端第三方JavaScript包管理工具bower(<code>bower install jQuery</code>)，bower可以实现第三方库的依赖解析、下载、升级管理等。建议建立企业级bower私服。</li>
<li>前端构建工具，可以采用grunt或者gulp工具，可以实现html、css、js压缩、验证、测试，文件合并、watch和liveload等所有前端任务。建议企业级nodejs npm私服。</li>
<li>前端开发IDE： WebStorm( Idea )、Sublime为最佳 。项目组统一IDE。IDE统一配置很重要。</li>
</ul></div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>破 狼</h1>
  <p>    那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息。 那一月，我转过所有经轮，不为超度，只为触摸你的指纹。 那一年，我磕长头拥抱尘埃，不为朝佛，只为贴着了你的温暖。 那一世，我翻遍十万大山，不为修来世，只为路中能与你相遇。 那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。<a href="http://greengerong.github.io/blog/2009/12/24/cang-yang-jia-cuo-na-yi-tian-na-yi-yue-na-yi-nian-na-yi-shi/">《那一天，那一月，那一年，那一世》&#8211;仓央嘉措。</a></p>
</section>
<section>
  <p style="align: center"><a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3158890&amp;c=9476983" alt="count web site visits"/></a></p>
</section>
<section>
    <h1>博客友情链接</h1>
    <ul>
        <li><a href="http://www.cnblogs.com/whitewolf/">博客园-破狼</a></li>
    </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing/">Verlet-js JavaScript 物理引擎</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/15/html5te-shu-su-ji-tu/">HTML5特性速记图</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/">Angular遇上CoffeeScript - NgComponent封装</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/09/kuo-zhan-bootstrap-tooltipcha-jian-shi-qi-ke-jiao-hu/">扩展Bootstrap Tooltip插件使其可交互</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao/">前端获取元素定位位置的法宝</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/03/angular-inputge-shi-hua/">Angular Input格式化</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view/">Angular实现递归指令 - Tree View</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/greengerong">@greengerong</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'greengerong',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 破 狼 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'greengerong';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
