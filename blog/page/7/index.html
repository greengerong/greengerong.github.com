
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<<<<<<< HEAD
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <title>破狼 Blog</title>
    <meta name="author" content="破 狼"> 
    <meta name="description" content="在软件开发设计中我们经常会面对业务分析，提取领域问题，从而实现软件架构设计。关于
软件架构设计Martin Fowler在2004出版的《企业应用架构模式》中
概括了四种方式的架构模式。它们分别为事务性脚本，表驱动模式，活动记录模式，领域驱动设计。前两者事务性脚本，表驱动模式作为 &hellip;"> 
    <!-- http://t.co/dKP3o1e -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1"> 
    <link rel="canonical" href="http://greengerong.github.io/blog/page/7">
    <link href="/favicon.png" rel="icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/atom.xml" rel="alternate" title="破狼 Blog" type="application/atom+xml">
    <script src="/javascripts/modernizr-2.0.js"></script>
    <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
    <script>
    !window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))
    </script>
    <script src="/javascripts/octopress.js" type="text/javascript"></script>
    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
 

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">破狼 Blog</a></h1>
  
    <h2>Write less got more.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:greengerong.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/18/ddd-practice/">软件架构设计模式简述</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-18T19:07:08+08:00" pubdate data-updated="true">Mar 18<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在软件开发设计中我们经常会面对业务分析，提取领域问题，从而实现软件架构设计。关于
软件架构设计Martin Fowler在2004出版的<a href="http://book.douban.com/subject/4826290/">《企业应用架构模式》</a>中
概括了四种方式的架构模式。它们分别为事务性脚本，表驱动模式，活动记录模式，领域驱动设计。前两者事务性脚本，表驱动模式作为
面向过程方式架构设计，后两者为面向对象架构设计。它们适合于不同的业务场景，它们也各有长短。</p>

<h4>事务脚本模式</h4>

<p>事务脚本模式是架构设计中最简单的架构模式，面向过程模式。该模式以用户的操作，UI表现为起点，设计业务组件，
即业务逻辑将直接映射到用户界面的操作。这通常是从表现层逻辑出发，表现层需要什么那么业务层就提供什么，
直到数据层。针对每一个用户的新功能都需要新增一个从UI到关系数据库的分支流程。其适用于逻辑不是
很复杂或者变化不会太大的稳定的应用系统开发。其不需要付出与业务无关的额外代价，并且在现代可见即可得的IDE
结合，能够很快的进行快速应用开发（RAD）。但是这种优势，也是其最大的劣势，程序中充满了IF-else，
switch-case之类的逻辑或者大量的static的方法，每个功能都是一个程序分支，这对代码无法重用。
编码不易于维护，对复杂项目和变化需求不适应。</p>

<h4>表驱动模式</h4>

<p>表驱动模式为每个数据库表定义一个表模块类，包含操作该数据的所有行为方法。作为一个容器，将数据
和行为组织在一起。其对数据的粒度针对于数据表，而非数据行，因此需要以集合或者表(DataTable)传递数据信息。
表驱动模式基于对象但是完全由数据库驱动开发，在业务模型和数据库关系模型显著差异的情况下，应对需求，
并不是那么适合。但是在.net中提供的一些列如强类型DataSet等IDE的辅助下自动生成大量的代码，
也是一个不错的选择，因为部分数据库的操作趋于自动化。表驱动模式没有太过于关注业务逻辑，而是关注数据库
表结构。而业务逻辑和领域问题才是软件核心，所以对于复杂的场景也存在不能很好的胜任。</p>

<h4>活动记录模式</h4>

<p>活动记录模式是一个以数据库表一行Row为对象，并且对象中包含行为和数据的模式方法。其数据对象
很大程度的接近数据库表结构。在活动记录模式中对象通常也包含架构设计和扩展对象的CRUD(增删改查)的行为，以及数据验证等业
务规则。对于业务不是很复杂，对象关系与关系模型映射不具有很大差异情况，活动记录模式会运用的
很好。活动模式比较简单化设计，在现行的如Linq to sql，ActiveRecord框架，
spring JDBC(Active Record),Ruby On Rails之类的框架之下，
将针对问题领域不是太过复杂的中小型项目十分有用，而且能做到快速，并且有较好设计的架构设计和扩展。
但是其模式和数据库表结构的过度的相互依赖，导致若你修改
数据库结构，你不得不同时修改对象以及相关逻辑。如果不能保证数据库关系模型和对象模式的很大程度
的相似这就进入的困境，无法解决对象和数据库结构的映射。</p>

<h4>领域驱动设计(DDD)</h4>

<p>在我们所述前面的几种架构模式都是在项目开始站在了以数据为中心的角度，而不是业务本身的问题领域。
而领域驱动设计模式是着重关注于系统的业务问题领域，首先开始为领域对象设计。与活动记录模式来说，
领域模型完全反映于问题领域业务概念模型逻辑，与数据库，持久化机制完成独立，其推崇持久化透明（POCO）。
其可以充分利用面向对象设计，不受持久化机制的任何约束。其为完全由业务驱动出来的。但是其最大的优势如上
各个模式一样也是其最大的劣势领域对象模型与关系模型具有天然的阻抗，领域实体对象早晚会需要映射到
持久化机制，有时我们必须等为了这种阻抗而让步。在当前有NHibearnate,EF,Fluent NHibearnate这类
ORM(Object Relation Mapping)框架辅助。</p>

<p>领域驱动设计是Eric Evans于2004年在<a href="http://book.douban.com/subject/5344973/">《领域驱动设计：软件核心复杂性应对之道》</a>
首先提出的，简称DDD.其实际为面向对象分析设计(OOAD)的延伸，利用面向对象思想进行分析设计，对系统逻辑严格
分层，对领域对象的的职责划分。领域逻辑按照职责和内聚的划分在不同的领域对象上，对象不再是单纯的数据载体，而应该
是一个具有行为，逻辑的富对象。</p>

<p>同时领域驱动设计中分层架构也是很重要的一部分，这是分离关注点(SOC)的体现。按照职责对每一层次划分。大体分为
表现层，业务逻辑层，仓储层，领域层，以及基本出设施层。以及后来所倡导的CQRS(读写分离).在层次之间为了应对面向对象设计
所有存在领域模型(DO)，然而我们常用的存储却是关系类型(PO),所以还存在ORM(Object Relation Mapping).以及为了更好的
适应UI的表现存在视图对象(VO，有时我们简单VO的存在直接用数据传输对象(DTO)代替)，所以存在DTO Mapping，在这里的VO或者DTO，往往
都是一层简单getter,setter的数据载体。</p>

<p>在领域驱动设计中还包含工作单元(UOW))，仓储，值类型,实体，聚合根，领域事件，领域边界，以及领域跟踪一类的概念，关于这些更多的知识
请参考<a href="http://book.douban.com/subject/4826290/">《企业应用架构模式》</a>，以及<a href="http://book.douban.com/subject/25844633/">实现领域驱动设计</a></p>

<p>最后推荐最新的领域驱动设计书籍资料：此书被DDD鼻祖Eric Evans誉为继其开山之作后，近十年内第一本将DDD落到具体(接地气)的经典书籍。</p>

<p><img src="http://img5.douban.com/lpic/s27236377.jpg" alt="实现领域驱动设计" /></p>

<ul>
<li><a href="http://www.amazon.cn/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E6%B2%83%E6%81%A9%E2%80%A2%E5%BC%97%E5%86%9C/dp/B00IYTVWA6/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1395749901&amp;sr=1-1">亚马逊</a></li>
<li><a href="http://product.dangdang.com/23439300.html#ddclick?act=click&amp;pos=23439300_0_1_p&amp;cat=01.00.00.00.00.00&amp;key=%CE%D6%B6%F7.%B8%A5%C5%A9&amp;qinfo=&amp;pinfo=1_1_72&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140309205553118327545287259908607&amp;ref=http%3A%2F%2Fproduct.dangdang.com%2F23439300.html&amp;rcount=&amp;type=&amp;t=1395231961000">当当</a></li>
<li><a href="http://item.jd.com/1100303441.html">京东</a></li>
<li><a href="http://book.douban.com/subject/25844633/">豆瓣</a></li>
</ul>

=======
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>破狼 Blog</title>
  <meta name="author" content="破 狼">

  
  <meta name="description" content="&nbsp;&nbsp; 在上两篇我们介绍了OnExceptionAspect和OnMethodBoundaryAspect ，在这节我们将继续了解MethodInterceptionAspect，他为我们提供了关于方法处理的AOP切入，不同于OnMethodBoundaryAspect， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://greengerong.github.io/blog/page/7">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="破狼 Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  


<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa24b16b917fd5e88f6d6dd10dc673619' type='text/javascript'%3E%3C/script%3E"));
</script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">破狼 Blog</a></h1>
  
    <h2>Write less got more.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:greengerong.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/04/AOP-zhi-PostSharp3-MethodInterceptionAspect/">AOP之PostSharp3-MethodInterceptionAspect</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-04T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/12/04/AOP-zhi-PostSharp3-MethodInterceptionAspect/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/12/04/AOP-zhi-PostSharp3-MethodInterceptionAspect/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>&nbsp;&nbsp; 在上两篇我们介绍了<a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp1.html">OnExceptionAspect</a>和<a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/2275680.html">OnMethodBoundaryAspect</a> ，在这节我们将继续了解MethodInterceptionAspect，他为我们提供了关于方法处理的AOP切入，不同于OnMethodBoundaryAspect，他不是边界，是方法体。有了我们可以在我们的方法切入aspect很多有用的信息，比如将同步方法变为异步，防止多次点击重复提交，winform，wpf的多线程调用UI（参见<a href="http://www.cnblogs.com/whitewolf/archive/2011/08/18/2144153.html">PostSharp &ndash; Thread Dispatching（GUI多线程）</a>），长时间操作在超过用户接受时间弹出进度条等等有用的关于用户体验和业务逻辑功能，简化我们的编程开发。</p>

<p>同样我们先来看看其MethodInterceptionAspect定义：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112042346079947.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112042346096618.png" title="image" alt="image" /></a></p>

<p>Invoke MethodInterceptionArgs参数：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112042346138763.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112042346153482.png" title="image" alt="image" /></a></p>

<p>我们一般使用Proceed是的方法进行处理。在这时我们可以加入线程池调用，使的其变为异步操作。</p>

<p>同时MethodInterceptionAspect 还继承了MethodLevelAspect 的CompileTimeValidate编译是验证，CompileTimeInitialize编译时初始化，RuntimeInitialize运行时初始化，后边的初始化我们将在后面一节PostSharp范围（static和instance中讲到）。</p>

<p>其定义很简单，在于我们的发挥：</p>

<p>二：防止多次提交处理demo：</p>

<p>我们这里只采用简单思路在方法进入禁止按钮可用，方法执行完成后恢复可用状态。我们将使监听winform事件处理方法，按钮来自EventHandle的第一个参数Sender。</p>

<pre><code>[Serializable] 
    public class UnMutipleTriggerAttribute : MethodInterceptionAspect 
    { 


public override bool CompileTimeValidate(System.Reflection.MethodBase method) 
       { 
           var ps = method.GetParameters(); 
           if (ps != null &amp;&amp; ps.Count() &gt; 0 &amp;&amp; ps[0].Name == "sender") 
               return true; 
           return false; 
       } 

        public override void OnInvoke(MethodInterceptionArgs args) 
        { 
            if (args.Arguments.Count &gt; 0) 
            { 
                var controls = args.Arguments[0] as System.Windows.Forms.Control; 
                if (controls != null &amp;&amp; controls.Enabled) 
                { 
                    controls.Enabled = false; 
                    args.Proceed(); ; 
                    controls.Enabled = true; 
                } 
            } 

        } 
    }
</code></pre>

<p>在这里我们是监听方法的处理事件函数根据vs自动生成规则，第一个参数是sender，事件源，这里利用了CompileTimeValidate在编译时决定是否注入aspect。</p>

<p>注意这里只是一个简单的demo，只针对于同步操作，如要变为异步操作，这需要改为在异步操作后启用。</p>

<p>测试在button点击方法加上attribute：</p>

<pre><code> [UnMutipleTriggerAttribute] 
      private void Save(object sender, EventArgs e) 
      { 
          System.Threading.Thread.Sleep(2000); 
      }
</code></pre>

<p>效果：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112042346163416.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112042346178857.png" title="image" alt="image" /></a></p>

<p>这个例子很简单的就完成了。</p>

<p><a href="http://files.cnblogs.com/whitewolf/PostSharpDemo.rar" title="Demo下载">demo下载</a></p>

<p>参考：</p>

<ol>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp1.html"><font color="#3d81ee">AOP之PostSharp初见-OnExceptionAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp2.html"><font color="#3d81ee">AOP之PostSharp2-OnMethodBoundaryAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp3.html"><font color="#3d81ee">AOP之PostSharp3-MethodInterceptionAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/10/PostSharp4.html"><font color="#6699cc">AOP之PostSharp4-实现类INotifyPropertyChanged植入</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/11/PostSharp5.html"><font color="#6699cc">AOP之PostSharp5-LocationInterceptionAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/13/PostSharp6.html"><font color="#6699cc">AOP之PostSharp6-EventInterceptionAspect</font></a></li>
<li> <a href="http://www.cnblogs.com/whitewolf/category/312638.html"><font color="#3d81ee">http://www.cnblogs.com/whitewolf/category/312638.html</font></a></li>
</ol>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp3.html" title="原文首发">原文首发请看这里</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/04/AOP-zhi-PostSharp-chu-jian-OnExceptionAspect/">AOP之PostSharp初见-OnExceptionAspect</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-04T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/12/04/AOP-zhi-PostSharp-chu-jian-OnExceptionAspect/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/12/04/AOP-zhi-PostSharp-chu-jian-OnExceptionAspect/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>&nbsp;&nbsp;&nbsp;&nbsp; PostSharp 这个静态植入的aop框架我就不多说了，在以前的aop文件，我们也尝试用<a href="http://www.cnblogs.com/whitewolf/category/312638.html">MSBuild+Mono.Cicel</a>理解静态植入AOP的原理。最近公司准备购买Postsharp做一些AOP，减少开发是代码量，至于选择AOP相信也不用多说。我也在今天重新了解了些Postsharp最新版更新，这阵子的博客更新也少了，所以准备在<a href="http://www.cnblogs.com/whitewolf/category/312638.html">MSBuild+Mono.Cicel</a>的基础上再一些Postsharp系列。今天既然是初见，那么我们就从最简单的OnExceptionAspect开始。</p>

<p>一：OnExceptionAspect</p>

<p>起定义如下：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132372435.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132381812.png" title="image" alt="image" /></a></p>

<p>先写Aspect Attribute：</p>

<pre><code>[Serializable] 
    public class ExceptionAspectDemoAttribute : OnExceptionAspect 
    { 

        public override void OnException(MethodExecutionArgs args) 
        { 
            var msg = string.Format("时间[{0:yyyy年MM月dd日 HH时mm分}]方法{1}发生异常: {2}\n{3}", DateTime.Now, args.Method.Name, args.Exception.Message, args.Exception.StackTrace); 
            Console.WriteLine(msg); 
            args.FlowBehavior = FlowBehavior.Continue; 
        } 
        public override Type GetExceptionType(System.Reflection.MethodBase targetMethod) 
        { 
            return typeof(NullReferenceException); 
        } 
    }
</code></pre>

<p>注意Postsharp的Aspect都需要标记为可序列化的，因为在编译时会为我们二进制序列化为资源，减少在运行是的开销，这个将在后面专门讲。</p>

<p>上面的code继承至OnExceptionAspect，并且override OnException和GetExceptionType，GetExceptionType为我们需要处理的特定异常。OnException为异常处理决策方法。我们的异常处理决策是当NullReferenceException时候我们会记录日志，并且方法指定继续（args.FlowBehavior = FlowBehavior.Continue）。</p>

<p>看看我们的测试代码：</p>

<pre><code> class Program 
   { 
       static void Main(string[] args) 
       { 
           Program.ExceptionAspectDemoAttribute1(); 
           Program.ExceptionAspectDemoAttribute2(); 
           Console.Read(); 
       } 
       [ExceptionAspectDemo] 
       public static void ExceptionAspectDemoAttribute1() 
       { 
           string s = null; 
           s.GetType(); 
       } 
       [ExceptionAspectDemo] 
       public static void ExceptionAspectDemoAttribute2() 
       { 
           throw new Exception("exception"); 
       } 
   }
</code></pre>

<p>&nbsp;很显然我们的两个方法抛出了null异常和自定义异常，预期是NullReferenceException会被扑捉，而自定义异常会中断，运行效果如下：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/20111204013240186.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132436890.png" title="image" alt="image" /></a>&nbsp;</p>

<p>我们在来看看postsharp为我们做了什么，当然是反编译看看：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/20111204013246115.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132497243.png" title="image" alt="image" /></a></p>

<p>二：Postsharp的Multicasting</p>

<p>1:Multicasting class:</p>

<p>&nbsp; 在这随便也说一下postsharp的Multicasting，多播这样翻译感觉有点死板呵呵，理解就行。利用这一点我们可以吧我们的aspect放在class，assembly等目标上匹配我们的多个目标。比如现在我们不想在我们的每个方法上加attribute，那我们可以选择在class上，如：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132509686.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132515475.png" title="image" alt="image" /></a></p>

<p>反编译，同样注入了我们每个方法：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132524994.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132551142.png" title="image" alt="image" /></a></p>

<p>2:Multicasting assembly:</p>

<p>我们同样可以利用</p>

<p>[assembly: PostSharpDemo.ExceptionAspectDemoAttribute()]</p>

<p>标记在我们的程序集上。</p>

<p>3:AttributeExclude:</p>

<p>但是注意这样也标记了我们的aspect，某些时候可能会导致堆栈溢出 ，我们可以用AttributeExclude=true来排除。</p>

<p>同时我们也可以设置应用目标：AttributeTargetMemberAttributes是一个枚举类型，定义如下：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/20111204013255520.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132564009.png" title="image" alt="image" /></a></p>

<p>比如我们需要过滤编译时候生成的目标（自动属性，action等等），</p>

<div class="cnblogs_code">
<div>[assembly:&nbsp;PostSharpDemo1.MethodTraceAspect(AttributeExclude&nbsp;=&nbsp;<span style="color: #0000ff">true</span>,&nbsp;AttributePriority&nbsp;=&nbsp;<span style="color: #800080">0</span>,&nbsp;AttributeTargetMemberAttributes&nbsp;=&nbsp;MulticastAttributes.CompilerGenerated)]</div></div>


<p>&nbsp;4:AttributePriority:</p>

<p>还有AttributePriority，我们可以设置编译时优先级。如果我们对目标标记了多个aspect，这样postsharp就不确定注入先后顺序，这样不能确保正确性，在vs编译时候我们会看见警告：Their order of execution is undeterministic.</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040132595140.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201112/201112040133019119.png" title="image" alt="image" /></a></p>

<p>这是时候AttributePriority就派上用途了来决定我们植入的先后优先级。</p>

<p>5:其他匹配</p>

<p>同上AttributeTargetMemberAttributes 我们还可以利用AttributeTargetMembers，AttributeTargetTypes进行目标名称的匹配，支持模糊匹配。</p>

<p>附件：<a href="http://files.cnblogs.com/whitewolf/PostSharpDemo.rar" title="Demo下载">Demo下载</a></p>

<p>我的AOP资料：</p>

<ol>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp1.html"><font color="#3d81ee">AOP之PostSharp初见-OnExceptionAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp2.html"><font color="#3d81ee">AOP之PostSharp2-OnMethodBoundaryAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp3.html"><font color="#3d81ee">AOP之PostSharp3-MethodInterceptionAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/10/PostSharp4.html"><font color="#6699cc">AOP之PostSharp4-实现类INotifyPropertyChanged植入</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/11/PostSharp5.html"><font color="#6699cc">AOP之PostSharp5-LocationInterceptionAspect</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/12/13/PostSharp6.html"><font color="#6699cc">AOP之PostSharp6-EventInterceptionAspect</font></a></li>
<li> <a href="http://www.cnblogs.com/whitewolf/category/312638.html"><font color="#3d81ee">http://www.cnblogs.com/whitewolf/category/312638.html</font></a></li>
</ol>


<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/12/04/PostSharp1.html" title="原文首发">原文首发请看这里</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/29/li-yong-Attribute-jian-hua-Unity-kuang-jia-IOC-zhu-ru/">利用Attribute简化Unity框架IOC注入</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/11/29/li-yong-Attribute-jian-hua-Unity-kuang-jia-IOC-zhu-ru/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/11/29/li-yong-Attribute-jian-hua-Unity-kuang-jia-IOC-zhu-ru/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在我们的领域驱动设计(DDD)开发中,我们经常需要IOC框架使得我的框架依赖翻转，依赖抽象，避免直接new依赖于我们的具体实现。这些使得我们的框架整个项目结构不变，很方便的改变具体实现，使得项目提供可测试性，模块之间实现高内聚低耦合，减少我们的后期维护成本。IOC框架一般基于容器，在容器中存储着各个抽象和具体实现的依赖关系，当我们需要发出请求的时候，IOC框架会在当前容器中找到我们所需要的具体实现返回给我们，当然这里还有DI注入（属性，方法，构造），在我们的使用者（客户端）不需要了解具体实现，如何初始化，如何流转等具体，只需明白我们的契约接口暴露给我们的服务，IOC框架是解决抽象和具体直接的创建问题。其他资料可以参见<strong><a href="http://martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern</a>。</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 当然Unity框架中为我们提供了RegisterInstance，RegisterType方法我们可以在代码中注册到容器，比如NLayerApp中就在<code>IoCFactory中注册一大堆抽象-具体关联。但是在我们的实际实践中一般会选择另一种方式xml配置配置，因为这样我们会得到更大的灵活性，需求变化只要抽象接口不变，我们也只需要在xml配置文件中修改一行配置加入我们的具体实现，加入我们的程序集，就可以适应需求变化，这更满足oo设计&amp;#8220;开闭原则&amp;#8221;。</code></p>

<p><code>&amp;nbsp;&amp;nbsp; 在这里个人实践利用抽象（接口）定义Attribute制定具体ConfigFile（配置文件），Container（容器），Name（名称）解决IOC植入，减少我们多次去读取配置文件。Unity为我们提供了在Web.config,App.config中配置注入信息，或者注册外部配置，但是很多时候我们更希望，在我们的 不同模块下，应用不同的IOC配置信息，这些可以减少维护的关联少些，清晰，同时文件夹的出现便于我们的配置信息的管理。</code></p>

<p><code>Attribute实现：UnityInjectionAttribute</code></p>

<pre><code>[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false, Inherited = true)] 

   public class UnityInjectionAttribute : Attribute 

   { 



       public UnityInjectionAttribute(string Container) 

       { 

           this.Container = Container;            

       } 



       public string Container 

       { 

           get; 

           set; 

       } 



       public string ConfigFile 

       { 

           get; 

           set; 

       } 



       public string Name 

       { 

           get; 

           set; 

       } 



       public Microsoft.Practices.Unity.Configuration.UnityConfigurationSection GetUnityConfigurationSection() 

       { 

           if (!string.IsNullOrEmpty(this.ConfigFile)) 

           { 

               var fileMap = new System.Configuration.ExeConfigurationFileMap { ExeConfigFilename = System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, this.ConfigFile) }; 

               System.Configuration.Configuration configuration = System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(fileMap, System.Configuration.ConfigurationUserLevel.None); 

               return configuration == null ? null : configuration.GetSection(Microsoft.Practices.Unity.Configuration.UnityConfigurationSection.SectionName) as Microsoft.Practices.Unity.Configuration.UnityConfigurationSection; 

           } 

           return System.Configuration.ConfigurationManager.GetSection(Microsoft.Practices.Unity.Configuration.UnityConfigurationSection.SectionName) as Microsoft.Practices.Unity.Configuration.UnityConfigurationSection; 

       } 

   }
</code></pre>

<p>&nbsp; 在这里我们GetUnityConfigurationSection根据ConfigFile获取UnityConfigurationSection ，ConfigFile为空则当前应用配置文件，不空则为路径。在这里我们为了性能，减少过多的IOC操作，读取配置文件，我们可以更具具体需要加入对配置文件UnityConfigurationSection的缓存（ConfigFile作为key，UnityConfigurationSection为value ）。</p>

<p>&nbsp;&nbsp; 同时提供操作辅助方法：ELUnityUtility</p>

<pre><code> public static class ELUnityUtility 

   { 

       public static T Resolve&lt;T&gt;() where T : class 

       { 

           return Resolve(typeof(T)) as T; 

       } 



       public static object Resolve(this Type type) 

       { 

           var attrs = type.GetCustomAttributes(typeof(Utils.UnityInjectionAttribute), true) as Utils.UnityInjectionAttribute[]; 

           if (attrs != null &amp;&amp; attrs.Length &gt; 0) 

           { 

               var attr = attrs[0]; 

               var unitySection = attr.GetUnityConfigurationSection(); 

               if (unitySection != null) 

               { 

                   var container = new Microsoft.Practices.Unity.UnityContainer().LoadConfiguration(unitySection, string.IsNullOrEmpty(attr.Container) ? unitySection.Containers.Default.Name : attr.Container); 

                   var obj = string.IsNullOrEmpty(attr.Name) ? container.Resolve(type) : container.Resolve(type, attr.Name); 

                   if (obj != null) 

                   { 

                       var piabAtttr = obj.GetType().GetCustomAttributes(typeof(ELPolicyinjectionAttribute), false) as ELPolicyinjectionAttribute[]; 

                       if (piabAtttr.Length &gt; 0) 

                       { 

                           obj = Microsoft.Practices.EnterpriseLibrary.PolicyInjection.PolicyInjection.Wrap(type, obj); 

                       } 

                       return obj; 

                   } 

               } 

           } 

           return null; 

       } 



       public static IEnumerable&lt;T&gt; ResolveAll&lt;T&gt;() where T : class 

       { 

           return ResolveAll(typeof(T)) as IEnumerable&lt;T&gt;; 

       } 



       public static object ResolveAll(this Type type) 

       { 

           var attrs = type.GetCustomAttributes(typeof(Utils.UnityInjectionAttribute), true) as Utils.UnityInjectionAttribute[]; 

           if (attrs != null &amp;&amp; attrs.Length &gt; 0) 

           { 

               var attr = attrs[0]; 

               var unitySection = attr.GetUnityConfigurationSection(); 

               if (unitySection != null) 

               { 

                   var container = new Microsoft.Practices.Unity.UnityContainer().LoadConfiguration(unitySection, string.IsNullOrEmpty(attr.Container) ? unitySection.Containers.Default.Name : attr.Container); 

                   return container.ResolveAll(type); 

               } 

           } 

           return null; 

       } 



   }
</code></pre>

<p><font face="Courier New">这里我们就可以很简便的获取IOC翻转。注：这里还有根据具体实现是否具体ELPolicyinjectionAttribute来决定是否进行PIAB的AOP操作，当然我们也可以在Unity配置文件中引入节点扩展</font></p>

<p>Microsoft.Practices.Unity.InterceptionExtension.Configuration.InterceptionConfigurationExtension,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft.Practices.Unity.Interception.Configuration</p>

<p><font face="Courier New">（PIAB利用的是透明代理速度较慢所以一般很少使用，当然你也可以实现具体的PIAB AOP方式比如注入MSIL，但我们已经有了很多注入MSIL的AOP框架了，我不准备去造轮子），ELPolicyinjectionAttribute：</font></p>

<pre><code> [AttributeUsage(AttributeTargets.Class)] 

   public class ELPolicyinjectionAttribute : Attribute 

   { 

       public string Name 

       { 

           get; 

           set; 

       } 

   }
</code></pre>

<p>这样：我们的客户端 就可以很简单的使用了：</p>

<pre><code> class Program 

   { 

       static void Main(string[] args) 

       { 



           ELUnityUtility.Resolve&lt;IClass2&gt;().Show(); 

           (typeof(IClass2).Resolve() as IClass2).Show(); 

           Console.Read(); 

       } 

   } 



   public interface IClass1 

   { 

       void Show(); 

   } 



   [Green.Utils.ELPolicyinjection] 

   public class Class1 : IClass1 

   { 



       #region IClass1 成员 

       [TestCallHandler] 

       public void Show() 

       { 

           Console.WriteLine(this.GetType()); 

       } 



       #endregion 

   } 



   [Green.Utils.UnityInjection("First", Name = "class2", ConfigFile = "App1.config")] 

   public interface IClass2 

   { 

       void Show(); 

   } 



    public class Class2 : ConsoleApplication1.IClass2 

   { 

       [Microsoft.Practices.Unity.Dependency("class1")] 

       public IClass1 Class1 

       { 

           get; 

           set; 

       } 



            public void Show() 

       { 

           Console.WriteLine(this.GetType()); 

           Class1.Show(); 

       } 

   }
</code></pre>

<p>App1.Config配置：</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt; 

&lt;configuration&gt; 

  &lt;configSections&gt; 

    &lt;section name="unity" 

             type="Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, 

             Microsoft.Practices.Unity.Configuration"/&gt; 

  &lt;/configSections&gt; 

  &lt;unity xmlns="http://schemas.microsoft.com/practices/2010/unity%22&gt; 

    &lt;container name="First"&gt; 

      &lt;register type="ConsoleApplication1.IClass1,ConsoleApplication1" mapTo="ConsoleApplication1.Class1,ConsoleApplication1" name="class1" /&gt; 

      &lt;register type="ConsoleApplication1.IClass2,ConsoleApplication1" mapTo="ConsoleApplication1.Class2,ConsoleApplication1" name="class2"  /&gt; 

    &lt;/container&gt; 

  &lt;/unity&gt; 

&lt;/configuration&gt;
</code></pre>

<p>下边是一个完整的带PIAB的例子：</p>

<p> using System;</p>

<p>using System.Collections.Generic;</p>

<p>using System.Linq;</p>

<p>using System.Text;</p>

<p>using Green.Utils;</p>

<p>using Microsoft.Practices.Unity.InterceptionExtension;</p>

<p>using Microsoft.Practices.EnterpriseLibrary.Common.Configuration;</p>

<p>namespace ConsoleApplication1</p>

<p>{</p>

<pre><code>class Program 

{ 

    static void Main(string[] args) 

    { 



        ELUnityUtility.Resolve&lt;IClass2&gt;().Show(); 

        (typeof(IClass2).Resolve() as IClass2).Show(); 

        Console.Read(); 

    } 

} 



public interface IClass1 

{ 

    void Show(); 

} 



[Green.Utils.ELPolicyinjection] 

public class Class1 : IClass1 

{ 



    #region IClass1 成员 

    [TestCallHandler] 

    public void Show() 

    { 

        Console.WriteLine(this.GetType()); 

    } 



    #endregion 

} 



[Green.Utils.UnityInjection("First", Name = "class2", ConfigFile = "App1.config")] 

public interface IClass2 

{ 

    void Show(); 

} 



[Green.Utils.ELPolicyinjection] 

public class Class2 : ConsoleApplication1.IClass2 

{ 

    [Microsoft.Practices.Unity.Dependency("class1")] 

    public IClass1 Class1 

    { 

        get; 

        set; 

    } 



    [TestCallHandler] 

    public void Show() 

    { 

        Console.WriteLine(this.GetType()); 

        Class1.Show(); 

    } 

} 



[Microsoft.Practices.EnterpriseLibrary.Common.Configuration.ConfigurationElementType(typeof(CustomCallHandlerData))] 

public class TestCallHandler : ICallHandler 

{ 

    #region ICallHandler 成员 



    public IMethodReturn Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext) 

    { 

        if (input == null) throw new ArgumentNullException("input"); 

        if (getNext == null) throw new ArgumentNullException("getNext"); 

        Console.WriteLine("begin...."); 

        var result = getNext()(input, getNext); 

        Console.WriteLine("end...."); 

        return result; 

    } 



    public int Order 

    { 

        get; 

        set; 

    } 



    #endregion 

} 



[AttributeUsage(AttributeTargets.Method)] 

public class TestCallHandlerAttribute : HandlerAttribute 

{ 

    public override ICallHandler CreateHandler(Microsoft.Practices.Unity.IUnityContainer container) 

    { 

        return new TestCallHandler(); 

    } 

} 

}
</code></pre>

<p>欢迎大家指正，批评，交流是的大家都功能进步。<a href="http://files.cnblogs.com/whitewolf/UnityInjectionAttribute.rar">代码下载</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/11/29/2268379.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
<<<<<<< HEAD
      <h1 class="entry-title"><a href="/blog/2014/03/18/docker-ecosystem-mapped-out/">[翻译]docker生态圈Mindmap</a></h1>
=======
      <h1 class="entry-title"><a href="/blog/2011/09/21/StringTemplate-yu-jian-jQuery-di-chong-tu/">StringTemplate遇见jQuery的冲突</a></h1>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
    
    
      <p class="meta">
        








  


<<<<<<< HEAD
<time datetime="2014-03-18T05:01:09+08:00" pubdate data-updated="true">Mar 18<span>th</span>, 2014</time>
=======
<time datetime="2011-09-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/09/21/StringTemplate-yu-jian-jQuery-di-chong-tu/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/09/21/StringTemplate-yu-jian-jQuery-di-chong-tu/">Comments</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
        
      </p>
    
  </header>


<<<<<<< HEAD
  <div class="entry-content"><p>Docker是一个开源的Linux容器，其被业界所接受，很快成为了一个产业标准。Docker可以减少应用程序启动
时候的大量资源的筹备。docker很快的成为了新兴的应用程序容器标准。现在有很多项目正围绕着它处于开发中。
下面将是Mindmap出我所知道的一些项目。你可以在这里访问<a href="http://www.mindmeister.com/389671722/docker-ecosystem">Mindmap</a>.</p>

<p><a href="http://www.mindmeister.com/389671722/docker-ecosystem"><img src="http://i0.wp.com/allthingsplatforms.com/wp-content/uploads/2014/03/Docker-Ecosystem-v0.1.png?resize=717%2C432" alt="docker mindmap" /></a></p>

<p>英语原文链接<a href="http://allthingsplatforms.com/platforms/docker-ecosystem-mapped-out/">http://allthingsplatforms.com/platforms/docker-ecosystem-mapped-out/</a></p>
=======
  <div class="entry-content"><p>&nbsp;&nbsp;&nbsp; &nbsp;最近在做一个流程引擎，现着手于自定义模板的处理。设计在模板中所有的数据都将与字段对应，采用xml结构序列化作为流程持久化机制。字段对于用户的输入则为字段，字段涉及到用户的输入，必定是控件。由于有以前项目word模板转化为在线展示输入经验（这里不仅仅是将word转化为html，还需要提取word书签作为关键字段，关键字段作为用户的输入，根据用户配置转化为文本框，下拉框，数字，货币框，时间等等可扩展控件）。我在本次的模板设计中不再考虑服务器控件，因为服务器控件将生成一大堆难以控制的html标记。所以彻底疯狂了一把，采用完全html+jQuery实现（验证用的也是jQuery validator）。关于流程的设计将会在后续慢慢总结。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天只是记录一下在控件用户设置界面字段修改界面需要还原用户的上次记录，因为我的全是html+jQuery，所以在框架设计中提供了两种方案：1：根据page对象注册页面初始化脚本，回填控件值。2：利用StringTemplate生成带有回填值的html输出。</p>

<p>&nbsp;&nbsp;&nbsp; 就是第二种方案的使用，出现了StringTemplate对于jQuery$的错误解析：解决方案总结如下：</p>

<ol>
<li>从jQuery触发，可以利用jQuery()代替$()。</li>
<li>StringTemplate这可以使jQuery的$转义：\$.</li>
</ol>


<p>&nbsp;&nbsp;&nbsp; 内容很少，废话很多，网见谅。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/09/21/2184488.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
<<<<<<< HEAD
      <h1 class="entry-title"><a href="/blog/2014/03/17/create-yourself-archetypes-plugin/">自定义项目脚手架- Maven Archetypes</a></h1>
=======
      <h1 class="entry-title"><a href="/blog/2011/08/23/html5-xi-lie-mu-lu/">Html5系列目录</a></h1>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
    
    
      <p class="meta">
        








  


<<<<<<< HEAD
<time datetime="2014-03-17T05:14:21+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2014</time>
=======
<time datetime="2011-08-23T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/08/23/html5-xi-lie-mu-lu/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/08/23/html5-xi-lie-mu-lu/">Comments</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
        
      </p>
    
  </header>


<<<<<<< HEAD
  <div class="entry-content"><p>在上篇<a href="http://greengerong.github.io/blog/2014/03/16/intellij-remove-archetype-plugin/">Intellij修改archetype Plugin配置</a>
中我们已经简单介绍了关于archetype的作用。</p>

<p>简单来说maven archetype插件就是创建项目的脚手架,通过命令行或者IDE集成简化项目创建的工作。例如：</p>

<ul>
<li>org.apache.maven.archetypes:maven-archetype-quickstart</li>
<li>org.apache.maven.archetypes:maven-archetype-site</li>
<li>org.apache.maven.archetypes:maven-archetype-webapp</li>
<li>以及spring或者第三方提供了一些archetype plugin。</li>
</ul>


<p>同时maven archetype插件也是一个简单的maven artifact，它包含了创建项目所需要的所有资源。
主要分为几类原型信息：</p>

<ul>
<li>archetype描述文件(src/main/resources/META-INF/maven/archetype.xml),这为<a href="http://maven.apache.org/plugins/maven-archetype-plugin-1.0-alpha-7/">archetype 1.0</a>,
包含所有创建项目的文件信息和路径信息。在(archetype 2.0)[<a href="http://maven.apache.org/archetype/maven-archetype-plugin/">http://maven.apache.org/archetype/maven-archetype-plugin/</a>]增加了更灵活的archetype-metadata.xml(src/main/resources/META-INF/maven/下),
archetype元数据信息，并且完全支持1.0.</li>
<li>项目的原型文件(src/main/resources/archetype-resources/之下)，将会被archetype插件
copy到项目目录结构去。</li>
<li>创建项目的pom文件(src/main/resources/archetype-resources下)</li>
<li>archetype pom文件，在archetype项目根目录下。</li>
</ul>


<h4>创建archetype插件</h4>

<ol>
<li><p>首先在archetype中加入一个pom文件，如下：</p>

<pre class='green'><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;com.github.greengerong&lt;/groupId&gt;
      &lt;artifactId&gt;component&lt;/artifactId&gt;
      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
      &lt;packaging&gt;jar&lt;/packaging&gt;

      &lt;name&gt;component&lt;/name&gt;
      &lt;url&gt;http://maven.apache.org&lt;/url&gt;

      &lt;properties&gt;
          &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;/properties&gt;

      &lt;dependencies&gt;
      &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre></li>
<li><p>创建archetype-metadata.xml,位于src/main/resources/META-INF/maven/目录下，例如：</p>

<pre class='green'><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;archetype-descriptor name="app-server"&gt;
    &lt;fileSets&gt;
        &lt;fileSet filtered="true" encoding="UTF-8"&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.**&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/fileSet&gt;
        &lt;fileSet filtered="true" encoding="UTF-8"&gt;
            &lt;directory&gt;src/test/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.**&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/archetype-descriptor&gt;
</code></pre></li>
</ol>


<p>更多配置信息参考<a href="https://maven.apache.org/archetype/archetype-common/archetype-descriptor.html">archetype-descriptor</a>.</p>

<ol>
<li><p>为将创建的项目增加pom.xml文件，以${artifactId} / ${groupId} 变量作为占位符，例如：</p>

<pre class='green'><code>  &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;${groupId}&lt;/groupId&gt;
      &lt;artifactId&gt;${artifactId}&lt;/artifactId&gt;
      &lt;version&gt;${version}&lt;/version&gt;
      &lt;packaging&gt;jar&lt;/packaging&gt;

      &lt;name&gt;${artifactId}&lt;/name&gt;

      &lt;properties&gt;
          &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;/properties&gt;

      &lt;dependencies&gt;
          &lt;dependency&gt;
              &lt;groupId&gt;junit&lt;/groupId&gt;
              &lt;artifactId&gt;junit&lt;/artifactId&gt;
              &lt;version&gt;4.11&lt;/version&gt;
              &lt;scope&gt;test&lt;/scope&gt;
          &lt;/dependency&gt;
      &lt;/dependencies&gt;

      &lt;build&gt;
          &lt;pluginManagement&gt;
              &lt;plugins&gt;
                  &lt;plugin&gt;
                      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                      &lt;configuration&gt;
                          &lt;source&gt;1.6&lt;/source&gt;
                          &lt;target&gt;1.6&lt;/target&gt;
                      &lt;/configuration&gt;
                  &lt;/plugin&gt;
              &lt;/plugins&gt;
          &lt;/pluginManagement&gt;
      &lt;/build&gt;
  &lt;/project&gt;
</code></pre></li>
<li><p>接下来在archetype项目下install plugin：mvn clean install.</p></li>
<li><p>利用已有archetype plugin创建项目：</p>

<p>命令行：</p>

<pre class='green'><code>mvn archetype:generate -DarchetypeGroupId=&lt;archetype-groupId&gt;  -DarchetypeArtifactId=&lt;archetype-artifactId&gt; -DarchetypeVersion=&lt;archetype-version&gt;  -DgroupId=&lt;my.groupid&gt; -DartifactId=&lt;my-artifactId&gt;
</code></pre></li>
</ol>


<p>  intellij选择增加archetype plugin：
  <img src="/images/blog_img/Intellij-archetype-plugin.png" alt="/images/blog_img/Intellij-archetype-plugin.png" /></p>

<p>对于删除intellij测试archetype信息，请参见<a href="http://greengerong.github.io/blog/2014/03/16/intellij-remove-archetype-plugin/">Intellij修改archetype Plugin配置</a>.</p>

<p>注意：</p>

<ul>
<li><p>如果你也需要文件名字或者目录名字，则需要用特殊变量__artifactId__(双下划线)作为占位符。</p>

<p> 本文demo,请移到到github <a href="https://github.com/greengerong/maven-archetypes-demo">maven-archetypes-demo</a>.</p></li>
</ul>

=======
  <div class="entry-content"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; html5作为下一代web标准，年前轩起了html5热潮。对于html5我只是本着了解看看。关于html5和RIA（silverlight，flash，JavaFx等）我不想说什么，也没有什么可说的，存在就有其存在的理由。孰优孰劣，留给事实、时间来证明的。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 在html5中出现了一些新特性：</p>

<ul>
<li>canvas 元素</li>
<li>视频 video 和 声频audio 元素 ；</li>
<li>对本地离线存储（localStorage，sessionStorage）的支持 ；</li>
<li>新增特殊内容元素：article、footer、header、nav、section ；</li>
<li>新增表单控件： calendar、date、time、email、url、search 。</li>
<li>其他新特性&nbsp;</li>
</ul>


<p>&nbsp;&nbsp;本博客中几个月前写的关于Html5博客有：</p>

<h2>一：html5基础</h2>

<ol>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/02/28/1967456.html">html5声频audio和视频video</a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/03/02/1968512.html">html5-Canvas绘图</a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/03/02/1969398.html">html5之Canvas坐标变换应用-时钟实例</a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/03/04/1970457.html">html5-web本地存储</a></li>
</ol>


<h2>二：html5应用</h2>

<ol>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/03/02/1969398.html">html5之Canvas坐标变换应用-时钟实例</a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/07/15/2107520.html">Google Chrome 語音辨識</a></li>
</ol>


<p>　　关于html5我仍然时不时的会有些持续，将会更新目录。在这里对于html5表单，特殊内容元素这些，以及一些个别特性，如文件拖拽，还未曾提到。今天只是整理博客加了个目录便于查找，管理。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/08/23/2150145.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
<<<<<<< HEAD
      <h1 class="entry-title"><a href="/blog/2014/03/16/intellij-remove-archetype-plugin/">Intellij修改archetype Plugin配置</a></h1>
=======
      <h1 class="entry-title"><a href="/blog/2011/08/22/dai-ma-sheng-cheng-ji-shu-mu-lu/">代码生成技术-目录</a></h1>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
    
    
      <p class="meta">
        








  


<<<<<<< HEAD
<time datetime="2014-03-16T07:51:08+08:00" pubdate data-updated="true">Mar 16<span>th</span>, 2014</time>
=======
<time datetime="2011-08-22T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/08/22/dai-ma-sheng-cheng-ji-shu-mu-lu/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/08/22/dai-ma-sheng-cheng-ji-shu-mu-lu/">Comments</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
        
      </p>
    
  </header>


<<<<<<< HEAD
  <div class="entry-content"><p>Maven archetype plugin为我们提供了方便的创建
project功能,Archtype指我们项目的骨架，作为项目的脚手架。
如fornt end的yo之类。我们能够通过简单的一行控制台command
line创建你所需要的项目结构：</p>

<pre class='green'><code>mvn archetype:generate
  -DarchetypeGroupId=&lt;archetype-groupId&gt;
  -DarchetypeArtifactId=&lt;archetype-artifactId&gt;
  -DarchetypeVersion=&lt;archetype-version&gt;
  -DgroupId=&lt;my.groupid&gt;
  -DartifactId=&lt;my-artifactId&gt;
</code></pre>

<p>常用的Maven archetype plugin有：</p>

<ul>
<li>org.apache.maven.archetypes:maven-archetype-quickstart</li>
<li>org.apache.maven.archetypes:maven-archetype-site</li>
<li>org.apache.maven.archetypes:maven-archetype-webapp</li>
<li>以及spring或者第三方提供了一些archetype plugin。</li>
</ul>


<p>同时在java世界强大的IDE Intellij也支持按照maven archetype
创建java项目。你只需要选择maven 创建项目，在最后选择你希望的
archetype plugin，然后就可以喝杯coffe等待build success。</p>

<p>关于如何自定义项目的Maven archetype plugin，博主将会
在后续的文章介绍。在此次博文将是记录如果去掉你手动在intellij中添加
的archetype plugin。</p>

<p>mac版本，你可以找到文件：</p>

<pre class='green'><code>~/Library/Caches/IntelliJIdea&lt;version&gt;/Maven/Indices/UserArchetypes.xml
</code></pre>

<p>然后用你喜欢的编辑器打开它(例如博主当前使用的Atom)：</p>

<pre class='green'><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;archetypes&gt;
&lt;archetype groupId="com.github.greengerong" artifactId="components-archetype" version="1.0.0" /&gt;
&lt;/archetypes&gt;
</code></pre>

<p>你可以在xml的archetypes节点增加或者删除修改配置，然后重新启动你的Intellij。</p>
=======
  <div class="entry-content"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这里总结的是本博客中的一些关系代码生成的技术，其中包含&nbsp;CodeDom，CodeSmith，T4，Mono.Cecil&nbsp;MSIL（静态AOP实例）注入，以及一些杂记&nbsp;。</p>

<h2><a href="http://www.cnblogs.com/whitewolf/archive/2010/07/09/1774279.html">一：CodeDom目录</a></h2>

<p>&nbsp;CodeDOM 提供了表示许多常见的源代码元素类型的类型。您可以设计一个生成源代码模型的程序，使用 CodeDOM 元素
构成一个对象图。可以使用受支持的编程语言的 CodeDOM 代码生成器，将该对象图呈现为源代码。CodeDOM 也可以用于将
源代码编译成二进制程序集。</p>

<p>CodeDOM 的一些一般用途包括：</p>

<ol>
<li>模板化代码生成：生成 ASP.NET、XML Web 服务客户端代理、代码向导、设计器或其他代码发出机制的代码。</li>
<li><p>动态编译：支持以一种或多种语言进行代码编译。</p></li>
<li><p><a href="http://www.cnblogs.com/whitewolf/archive/2010/06/19/1760708.html"><font color="#3d81ee">CodeDom系列-开篇HelloWord</font></a></p></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/06/20/1761367.html"><font color="#3d81ee">CodeDom系列二&mdash;-程序基本结构&mdash;符号三角形问题</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/06/22/1762589.html"><font color="#3d81ee">CodeDom系列&mdash;事件（event）定义和反射调用</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/07/05/1771138.html"><font color="#3d81ee">CodeDom系列四&mdash;Code生成</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/07/06/1771868.html"><font color="#3d81ee">CodeDom系列五&mdash;动态编译</font></a>&nbsp;</li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/07/08/1773361.html"><font color="#3d81ee">CodeDom六&mdash;实体类生成示例</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/12/23/1914700.html"><font color="#6699cc">代码生成技术&mdash;CodeDom VS T4</font></a></li>
</ol>


<h2><a href="http://www.cnblogs.com/whitewolf/archive/2010/09/27/1836729.html">二：CodeSimth：</a></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CodeSmith是一个基于模板的代码生成器，它可以生成任何基于ASCII的编程语言代码。生成的代码可以使用属性进行定制。属性可以是任何具有设计器的.NET对象（大多数.NET内置类型已经有设计器），也可以是一个允许你从结果中有条件地添加或移除代码的简单的boolean 属性，或是一个对象，例如能够访问数据库表信息的TableSchema对象（包括在SchemaExplorer中）。CodeSmith完全可扩展，它允许用户创建定制属性类型。CodeSmith中包括多个定制属性类型的例子，例如，定制一个允许选择XML文件（使用XmlSerializer可将其反序列化到对象中）的属性类型。CodeSmith还允许用户在模板中引用和调用指定的外部程序集并且允许从外部程序集的类生成模板。</p>

<ul>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/07/13/1776379.html"><font color="#3d81ee">CodeSmith模板引擎系列一</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/07/14/1777088.html"><font color="#3d81ee">CodeSmith模板引擎系列二&mdash;文件目录树</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/09/25/CodeSimthNamedCMessage.html"><font color="#3d81ee">通过代码生成机制实现强类型编程-CodeSimth版</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/09/27/1836731.html"><font color="#6699cc">Dbml文件提取建表TSql-CodeSmith</font></a></li>
</ul>


<h2>三：MSIL注入：&nbsp;</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp; NET是一门多语言平台，这是我们所众所周知的，其实现原理在于因为了MSIL（微软中间语言）的一种代码指令平台。所以.NET语言的编译就分为了两部分，从语言到MSIL的编译（我喜欢称为预编译），和运行时的从MSIL到本地指令，即时编译（ＪＩＴ）。ＪＩＴ编译分为经济编译器和普通编译器。</p>

<ul>
<li>&nbsp;<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/26/2117661.html"><font color="#6699cc">浅谈.NET编译时注入（C#&mdash;&gt;IL）</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/07/27/2119005.html"><font color="#6699cc">浅谈VS编译自定义编译任务&#8212;MSBuild Task(csproject)</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/07/28/2119969.html"><font color="#6699cc">编译时MSIL注入&mdash;实践Mono Cecil(1)</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/08/09/2132217.html"><font color="#6699cc">MSBuild + MSILInect实现编译时AOP之预览</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/08/09/2133106.html"><font color="#6699cc">MSBuild + MSILInect实现编译时AOP-改变前后对比</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2011/08/18/2144153.html"><font color="#6699cc">PostSharp &ndash; Thread Dispatching（GUI多线程）</font></a></li>
</ul>


<h2>四：其他杂记</h2>

<ul>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/12/23/1914700.html"><font color="#6699cc">代码生成技术&mdash;CodeDom VS T4</font></a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2010/12/22/1913718.html"><font color="#6699cc">Razor Templating Engine</font></a></li>
</ul>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实在.net平台还有很多code生成技术T4（其实现在我更倾向于T4模板，但是园内牛人们已经有很多文章了，所以没写），Razor（ASP.NET MVC3带来的一种语法很漂亮，舒服的模板引擎，我也很喜欢，只是需要4.0，我打大多数工作任在3.5上工作），Mono.Cecil（MSIL程序集静态注入），Emit（MSIL的动态注入），StringTemplate（古老的模板引擎了），以及其他第三方的模板引擎，都没有写完。在以后可能会更侧重于实际应用案例。</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/08/22/2149947.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
<<<<<<< HEAD
      <h1 class="entry-title"><a href="/blog/2014/03/15/ng-html2js-maven-plugins-for-java/">Ng-template寄宿方式</a></h1>
=======
      <h1 class="entry-title"><a href="/blog/2011/08/20/zuo-wang-zhan-ce-hua-yun-ying-bu-de-bu-zhi-di-ji-ge-ding-lv-zhuan-zai/">做网站策划运营不得不知的几个定律(转载)</a></h1>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
    
    
      <p class="meta">
        








  


<<<<<<< HEAD
<time datetime="2014-03-15T13:14:55+08:00" pubdate data-updated="true">Mar 15<span>th</span>, 2014</time>
=======
<time datetime="2011-08-20T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/08/20/zuo-wang-zhan-ce-hua-yun-ying-bu-de-bu-zhi-di-ji-ge-ding-lv-zhuan-zai/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/08/20/zuo-wang-zhan-ce-hua-yun-ying-bu-de-bu-zhi-di-ji-ge-ding-lv-zhuan-zai/">Comments</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
        
      </p>
    
  </header>


<<<<<<< HEAD
  <div class="entry-content"><p>如果你是一个angular的开发者的话，对于ng-html2js你应该
很熟悉。对于angular的指令，我们经常需要定义模板(
directive template/templateUrl),你可以选择讲html page
放在真正的的web容器中寄宿，也可以选择angular的ng-template
放在view的page之上，抑或也可以讲html打成一个js文件和directive
的js文件合并在一起发布。</p>

<ul>
<li><p>对于直接寄宿在web容器.</p>

<p>这很简单，直接放在jetty，tomcat，iis，
抑或node express public目录下。这里没什么可以多说的，所以我们跳过。</p></li>
<li><p>angular ng-template模板:</p>

<p>代码如下：</p>

<pre class='green'><code>    &lt;script type="text/ng-template" id="/tpl.html"&gt;

      Content of the template.

    &lt;/script&gt;
</code></pre>

<p>这将会在angular的compile时候解析，angular将会把它放在angular的$templateCache
中。</p>

<p>对于<a href="http://docs.angularjs.org/api/ng/service/$templateCache">$templateCache</a>，如其名
这是angular对模板的缓存的service。在启用了$templateCache的$http ajax请求，
angular将会首先在$templateCache中查找是否有对此url的缓存：</p>

<pre class='green'><code>      $templateCache.get('templateId.html')
</code></pre>

<p>如果存在缓存，着angular将会直接用缓存中获取，并不会在发送一次ajax。
对于所有的指令和模板angular默认启用了templateCache。</p>

<p>这在于angular所处理的模式开发很有关系的。我们经常提到的SPA(single page application)
我们把view的显示处理等表现逻辑推到了前段，而后端提供只与数据有关的soap/restful service
这样对于一个应用程序业务逻辑来说不变的是处理数据的业务逻辑，这份逻辑你可以共享在不管前端是mobile
app 或者是浏览器，或者winform gui的图形化程序，因为对于同一个业务这是不变的。将view的分离推到各自的客户端
将是更好的解决方案。</p>

<p>回到angular $templateCahce，对于一个应用程序view的分离，之后在对于当前的应用程序平台，html/js/css
这类资源是静态的，最好是不变的，那么你可以自由的缓存在客户端，减少服务器的交互，以及为了更大的性能追求，我们
可以把这类静态资源放在Nginx这里反向代理或者CDN上，让我们的程序获取更大的性能和扩展空间。</p></li>
<li><p>回到angular的ng-html2js：</p>

<p>有了上边对于$templateCache的理解，那你应该很容易理解html2js的方式了，与ng-template不同的
是ng-template是angular在compile的时候自动加入$templateCache的，html2js是我们在开发
时候利用build自己放入$templateCache。</p>

<pre class='green'><code>  angular.module('myApp', [])
  .run(function($templateCache) {
      $templateCache.put('templateId.html',
          'This is the content of the template'
      );
  });
</code></pre></li>
</ul>


<p>形如上面的输出，将html文件打成一个js文件。</p>

<p>这你也许在angular的单元测试karma unit test中看见过，<a href="https://github.com/karma-runner/karma-ng-html2js-preprocessor"> karma-ng-html2js-preprocessor</a>
，还有如果你也希望在build时候做到如此，那么你可以使用grunt plugin <a href="https://github.com/karlgoldstein/grunt-html2js"> grunt-html2js</a>.</p>

<p>但使用grunt plugin的前提是你在你的项目中引入的grunt build的work flow，那么你可以在gruntfile.js中几行代码轻松的搞定。但是如果
你和我一样使用的是java的maven或者是gradle 作为build，那么你可以尝试博主的maven plugin<a href="https://github.com/greengerong/nghtml2js">nghtml2js</a>.
使用方式如下：</p>

<pre class='green'><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.greengerong&lt;/groupId&gt;
    &lt;artifactId&gt;nghtml2js&lt;/artifactId&gt;
    &lt;version&gt;0.0.3&lt;/version&gt;
    &lt;configuration&gt;
        &lt;module&gt;demo.template&lt;/module&gt;
        &lt;html&gt;${project.basedir}&lt;/html&gt;
        &lt;extensions&gt;
            &lt;param&gt;tpl&lt;/param&gt;
            &lt;param&gt;html&lt;/param&gt;
        &lt;/extensions&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;nghtml2js&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;run&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/28/ci-tools-go-open-source/">ThoughtWorks持续集成平台GO开源了</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-28T22:11:34+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk1lR8OseSHNcsAhWTlYia2Ld59ibrwIjwibliaI2ZkghyDhjIibhyl1sqNfA/0" alt="go" /></p>

<p>ThoughtWorks 持续集成平台Go最近宣布开源了。其基于Apache 2.0 开源协议。</p>

<p>Go下载地址为<a href="http://www.go.cd/download/">http://www.go.cd/download/</a>.</p>

<p>下面是几张来自官方的视图：</p>

<p>GO流程图：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkhIEdu6Sm9BeCTvC3ianeMpWF3ibl9uE9GnKiaZhfucjenfpVHdj7ia8dug/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkhIEdu6Sm9BeCTvC3ianeMpWF3ibl9uE9GnKiaZhfucjenfpVHdj7ia8dug/0" /></p>

<p>GO截面图：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk0g8A2LFhCSqo9sV213sbrmIPYx6mico1LOqcPYLgyJgCQce9OibHsRog/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk0g8A2LFhCSqo9sV213sbrmIPYx6mico1LOqcPYLgyJgCQce9OibHsRog/0" /></p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkkYYPxPhy3ZSQugDEvuZkQwXockGPDF75Oia3yvoKAOAFxmHayDYNMIg/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkkYYPxPhy3ZSQugDEvuZkQwXockGPDF75Oia3yvoKAOAFxmHayDYNMIg/0" /></p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk2gON7AZ80zhsSlHZVy8EtT9NUqX3Z6dholdgMgFsyltondWYL2dxlg/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk2gON7AZ80zhsSlHZVy8EtT9NUqX3Z6dholdgMgFsyltondWYL2dxlg/0" /></p>

<p>GO的版本：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKklp3IsiaGMqDswMeKSEno8JmdnasOkwt3bWwQoAmjiaIoeCX2du2SWFlQ/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKklp3IsiaGMqDswMeKSEno8JmdnasOkwt3bWwQoAmjiaIoeCX2du2SWFlQ/0" /></p>

<ul>
<li> <a href="http://www.thoughtworks.com/cn/news/go-continuous-delivery-now-available-as-free-open-source#rd?sukey=910132d0e6ac3190d1e520e951a74f6cec37de934f95c61f6c7069ae1e806ed7d1df5175970e3f6b8a2057979d44cc7c">Thoughtworks官方的宣布文章</a></li>
<li> 你也可以在ThoughtWorks中国微信雷小达看到:<a href="http://mp.weixin.qq.com/s?__biz=MjM5MjY3OTgwMA==&amp;mid=200062098&amp;idx=1&amp;sn=25198a84122904cd113ef010637d27ed&amp;uin=MjA0MjY0NDk0MA%3D%3D">GO！我们开源了！</a></li>
</ul>

=======
  <div class="entry-content"><p><strong>网站策划</strong>从业者要求的知识面较广阔，必须具备市场和销售意识，具备人体工程学的意识，具备较强的沟通能力和文字表达能力，熟悉商业情报收集和信息分析的方法，熟悉网站规划，掌握基本的建站方法，了解网站硬件环境配置，熟悉网络广告投放和搜索引擎优化等方法。一起来看，几个必须知道的定律。</p>

<p><strong>1. 250定律</strong></p>

<p>拉德认为：每一位顾客身后，大体有250名亲朋好友。假如您赢得了一位顾客的好感，就意味着赢得了250个人的好感；反之，假如你得罪了一名顾客， 也就意味着得罪了250 名顾客。 在你的网站访客中，一个访客可能可以带来一群访客，任何网站都有起步和发展的过程，这个过程中此定律尤其重要。</p>

<p><strong>2. 达维多定律</strong></p>

<p>达维多认为，一个企业要想在市场上总是占据主导地位，那么就要做到第一个开发出新产品，又第一个淘汰自己的老产品。 国内网站跟风太严重，比如前段时间的格子网，乞讨网，博客网，一个成功了，大家一拥而上。但实际效果是，第一个出名的往往最成功，所以在网站的定位上，要动自己的脑筋，不是去捡人家剩下的客户。同理，买人家出售的数据来建站效果是很糟糕的。</p>

<p><strong>3. 木桶定律</strong></p>

<p>木桶定律是指，一只木桶能装多少水，完全取决于它最短的那块木板。这就是说任何一个组织都可能面临的一个共同问题，即构成组织的各个部分往往决定了 整个组织的水平。注重审阅自己的网站，是速度最糟糕？美工最糟糕？宣传最糟糕？你首先要做的，不是改进你最强的，而应该是你最薄弱的。</p>

<p><strong>4. 马太效应</strong></p>

<p>《新约》中有这样一个故事，一个国王远行前，交给三个仆人每人一锭银子，吩咐他们：&#8220;你们去做生意，等我回来时，再来见我。&#8221;国王回来时，第一个仆人说：&#8220;主人，你交给我们的一锭银子，我已赚了10锭。&#8221;于是国王奖励他10座城邑。第二个仆人报告说：&#8220;主人，你给我的一锭银子，我已赚了5锭。&#8221; 于是国王例奖励了他5座城邑。第三个仆人报告说：&#8220;主人，你给我的一锭银子，我一直包在手巾里存着，我怕丢失，一直没有拿出来。&#8221;于是国王命令将第三个仆 人的一锭银子也赐给第一个仆人，并且说：&#8220;凡是少的，就连他所有的也要夺过来。凡是多的，还要给他，叫他多多益善。&#8221;这就是马太效应。 在同类网站中，马太效应是很明显的。一个出名的社区，比一个新建的社区，更轻易吸引到新客户。启示是，假如你无法把网站做大，那么你要做专。作专之后再做大就更轻易。</p>

<p><strong>5. 手表定理</strong></p>

<p>手表定理是指一个人有一只表时，可以知道现在是几点钟，而当他同时拥有两只表时却无法确定。</p>

<p>一个网站，你只需要关注你特定的用户群需求。不要在意不相干人的看法。</p>

<p><strong>6. 不值得定律</strong></p>

<p>不值得定律：不值得做的事情，就不值得做好 不要过度seo，假如你不是想只做垃圾站。不要把时间浪费在美化再美化页面，优化再优化程序，在你网站能盈利后，这些事情可以交给技术人员完成。</p>

<p><strong>7. 彼得原理</strong></p>

<p>劳伦斯。彼得认为：在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于晋升到其不称职的地位。</p>

<p>不要轻易改变自己网站的定位。如博客网想变门户，盛大想做娱乐，大家拭目以待吧。</p>

<p><strong>8. 零和游戏原理</strong></p>

<p>当你看到两位对弈者时，你就可以说他们正在玩&#8220;零和游戏&#8221;。因为在大多数情况下， 总会有一个赢，一个输，假如我们把获胜计算为得1分，而输棋为-1分，那么，这两人得分之和就是：1 （-1）=0 不要把目光一直盯在你的竞争网站上，不要花太多时间抢它的访客。我们把这些时间用来寻找互补的合作网站，挖掘新访客。</p>

<p><strong>9. 华盛顿合作规律</strong></p>

<p>华盛顿合作规律说的是：一个人敷衍了事，两个人互相推诿，三个人则永无成事之日。</p>

<p>假如你看准一个方向，你自己干，缺人手就招。不要轻易找同伴一起搞网站，否则你会发现，日子似乎越过越快了，事情越做越慢了。</p>

<p><strong>10. 邦尼人力定律</strong></p>

<p>一个人一分钟可以挖一个洞，六十个人一秒种却挖不了一个洞。合作是一个问题，如何合作也是一个问题。你需要有计划。</p>

<p><strong>11. 牛蛙效应</strong></p>

<p>把一只牛蛙放在开水锅里，牛蛙会很快跳出来；但当你把它放在冷水里，它不会跳出来，然后慢慢加热，起初牛蛙出于懒惰，不会有什么动作，当水温高到它无法忍受的时候，想出来，但已经没有了力气。 假如你是soho，注重关注你的财务。不要等到没钱了再想怎么挣，你会发现那时候挣钱更难。</p>

<p><strong>12. 蘑菇治理</strong></p>

<p>蘑菇治理是许多组织对待初出茅庐者的一种治理方法，初学者被置于阴暗的角落（不受重视的部门，或打杂跑腿的工作），浇上一头大粪（无故的批评、指责、代人受过），任其自生自灭（得不到必要的指导和提携）。</p>

<p>做网站究竟要遭遇这样的阶段，搜索引擎不理你，友情链接找不到，访客不上门。这是磨练。</p>

<p><strong>13. 奥卡姆剃刀定律</strong></p>

<p>如无必要，勿增实体。</p>

<p>把网站做得简单，再简单，简单到非常实用，而不是花俏。google的首页为什么比雅虎好？</p>

<p>一个出色的网站策划人员要做的工作不仅仅是一份策划方案书的撰写，而是涵盖了从对客户需求的了解到与美工人员技术开发人员的工作协调到网站发布宣传与推广等多项工作内容。希望本文对你有帮助。</p>

<p>原文：<a href="http://developer.51cto.com/art/201105/261118.htm">http://developer.51cto.com/art/201105/261118.htm</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/08/20/2146929.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
<<<<<<< HEAD
      <h1 class="entry-title"><a href="/blog/2014/02/28/net-4-dot-5-1-ms-rsl-source/">微软开放了.NET 4.5.1的源代码</a></h1>
=======
      <h1 class="entry-title"><a href="/blog/2011/08/09/MSBuild-MSILInect-shi-xian-bian-yi-shi-AOP-gai-bian-qian-hou-dui-bi/">MSBuild + MSILInect实现编译时AOP-改变前后对比</a></h1>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
    
    
      <p class="meta">
        








  


<<<<<<< HEAD
<time datetime="2014-02-28T12:25:25+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2014</time>
=======
<time datetime="2011-08-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/08/09/MSBuild-MSILInect-shi-xian-bian-yi-shi-AOP-gai-bian-qian-hou-dui-bi/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/08/09/MSBuild-MSILInect-shi-xian-bian-yi-shi-AOP-gai-bian-qian-hou-dui-bi/">Comments</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
        
      </p>
    
  </header>


<<<<<<< HEAD
  <div class="entry-content"><p><a href="http://referencesource.microsoft.com/">.NET Reference Source</a>发布了beta版，可以在线浏览.NET Framework 4.5.1的源代码，并且可以通过配置，<a href="http://referencesource-beta.microsoft.com/setup.html">在Visual Studio 2013中调试.NET Framework</a>。</p>

<p>.NET Framework团队的项目经理Alok Shriram在<a href="http://blogs.msdn.com/b/dotnet/archive/2014/02/24/a-new-look-for-net-reference-source.aspx">.NET Framework的博客</a>中撰文介绍了最新的.NET Reference Source。它不仅可以用来浏览最新的.NET代码，而且通过强大的<a href="http://msdn.com/roslyn">Roslyn</a>，改善了“Go to Defination”和“Finding Reference”的在线体验。此外，开发者还可以下载整个源代码包，在Visual Studio中打开并浏览。使用Schabse Laks编写的<a href="http://visualstudiogallery.msdn.microsoft.com/f89b27c5-7d7b-4059-adde-7ccc709fa86e">插件</a>，可以在VS中直接导航到该网站。</p>

<p>通过简单的配置，开发者可以在Visual Studio中单步调试.NET Framework 4.5.1及其后续补丁和更新。这无疑是广大开发者<a href="http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/4083118-allow-developers-to-step-through-net-framework-so">翘首以盼的功能</a>。启动Visual Studio 2013，打开Tools &ndash;> Options &ndash;> Debugging &ndash;> General菜单，进行如下配置：</p>

<ul>
<li>   禁用Just My Code</li>
<li>   禁用Step over properties and operators</li>
<li>   禁用Require source files to exactly match the original version</li>
<li>   选中Enable .NET Framework source stepping</li>
<li>   选中Enable source server support</li>
</ul>


<p>这样，开发者在调试代码时，就可以通过F11直接进入.NET代码。</p>

<p>这并不是微软第一次开放.NET Framework的源代码。早在2007年，他们就第一次公布了<a href="http://weblogs.asp.net/scottgu/archive/2007/10/03/releasing-the-source-code-for-the-net-framework-libraries.aspx">.NET 3.5的源代码</a>并支持Visual Studio调试。并且对于后续的4.0和4.5，也都提供了相应的源代码包。但当框架升级时，这些旧的包就变得毫无价值了。从4.5.1开始，.NET Framework团队彻底改变了符号索引和发布的过程，使其与构建过程同步，这样在新版本发布时，相应的PDB文件也会从Reference Source网站进行更新。</p>

<p>目前的beta站点只是临时的，届时将会取代现在的旧站点。后续微软也会将还未公布源代码的程序集逐步添加进来。新的.NET Reference Source许可协议回归到了<a href="http://referencesource-beta.microsoft.com/license.html">MS-RSL</a>，这也使得像Mono这样的团队可以放心大胆地使用。</p>

<p>正如Scott Hanselman所说：微软可能并不是开源的，但却绝对是源代码开放的。</p>

<p>Infoq原文链接:<a href="http://www.infoq.com/cn/news/2014/02/microsoft-net-source-code?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global&amp;utm_reader=feedly">http://www.infoq.com/cn/news/2014/02/microsoft-net-source-code?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global&amp;utm_reader=feedly</a>.</p>
=======
  <div class="entry-content"><p>&nbsp;&nbsp;&nbsp; 实现静态AOP，就需要我们在预编译时期，修改IL实现对代码逻辑的修改。Mono.Cecil就是一个很好的IL解析和注入框架，参见<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/28/2119969.html">编译时MSIL注入&mdash;实践Mono Cecil(1)</a>。</p>

<p>&nbsp; 我的思路为：在编译时将加有继承制MethodInterceptBaseAttribute标签的原方法，重新组装成一个方法（并加上[<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.Runtime.CompilerServices.CompilerGeneratedAttribute/.ctor(">CompilerGenerated</a>)]标签），在加入横切注入接口前后代码，调用此方法。</p>

<p>比如代码：</p>

<pre><code>[TestAOPAttribute(Order = 1)]

public Class1 TestMethod1(int i, int j, Class1 c) 
        { 
            Console.WriteLine("ok"); 
            return new Class1(); 
        }

public class TestAOPAttribute : Green.AOP.MethodInterceptBase 
    { 

        #region IMethodInject Members 

        public override bool Executeing(Green.AOP.MethodExecutionEventArgs args) 
        { 
            Console.WriteLine(this.GetType() + ":" + "Executeing"); 
            return true; 
        } 

        public override Green.AOP.ExceptionStrategy Exceptioned(Green.AOP.MethodExecutionEventArgs args) 
        { 
            Console.WriteLine(this.GetType() + ":" + "Exceptioned"); 
            return Green.AOP.ExceptionStrategy.Handle; 
        } 

        public override void ExecuteSuccess(Green.AOP.MethodExecutionEventArgs args) 
        { 
            Console.WriteLine(this.GetType() + ":" + "ExecuteSuccess"); 
        } 

        #endregion 

        #region IMethodInject Members 

               #endregion 
    }
</code></pre>

<p>将会转化（实际注入IL，这里反编译为了c#代码，更清晰）为：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313329255.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313392150.png" title="12" alt="12" /></a></p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313397449.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313416379.png" title="image" alt="image" /></a></p>

<p>从这里你就会清晰的明白这里实现静态注入了机制和原理了。我们需要做的目的就是从IL出发改变原来代码逻辑，注入我们的截取代码。使用Mono.Cecil具体代码在程序包MethodILInjectTask中。</p>

<p>MatchedMethodInterceptBase是应用于class上匹配该class多个methodattribute基类。rule为匹配规则。</p>

<pre><code>[TestAOP2Attribute(Rule = "TestMethod1*")]

public class Class1 
</code></pre>

<p>&nbsp;&nbsp; <a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313445558.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313488651.png" title="image" alt="image" /></a></p>

<p>这里需要对于继承制该基类的标示class的所有满足rule的方法进行注入。</p>

<p>PropertyInterceptBase：属性注入，Action属性标识get，set方法。</p>

<pre><code>[TestAOPPropertyGetAttribute(Action = PropertyInterceptAction.Get)] 
   public int TestProperty 
   { 
       get; 
       set; 
   }
</code></pre>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313514766.png"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201108/201108092313565383.png" title="image" alt="image" /></a></p>

<p>属性注入找出标示property，更具action选择get，set方法注入IL逻辑。</p>

<p>现在对于方法中获取attribute通过反射，性能存在一定问题。完全可以在class中注入属性，延时加载，Dictionary类级缓存来减少这方面损失，还暂时没考虑加入。</p>

<p>&nbsp;&nbsp;&nbsp; 不是很会写blog，所以有什么不明白的可留言，上一篇<a href="http://www.cnblogs.com/whitewolf/archive/2011/08/09/2132217.html" title="发布于2011-08-09 14:05"><font color="#3d81ee">MSBuild + MSILInect实现编译时AOP之预览</font></a>，由于时间写的没头没尾的，估计大家都看的很迷茫，迷茫该怎么写。关于IL注入Mono.Cecil可以参见<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/28/2119969.html">编译时MSIL注入&mdash;实践Mono Cecil(1)</a>和官方<a href="http://www.mono-project.com/Cecil">http://www.mono-project.com/Cecil</a>。还有必须对MSIL具有一定了解（相同与Emit的IL注入）</p>

<p>&nbsp;&nbsp; 附带：<a href="http://files.cnblogs.com/whitewolf/ConsoleApplication1.rar" title="源码下载">源码下载</a></a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/08/09/2133106.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
<<<<<<< HEAD
      <h1 class="entry-title"><a href="/blog/2014/02/28/nodejs-get-client-ip/">nodejs获取客户端IP Address</a></h1>
=======
      <h1 class="entry-title"><a href="/blog/2011/07/28/bian-yi-shi-MSIL-zhu-ru-shi-jian-Mono-Cecil-1/">编译时MSIL注入&#8211;实践Mono Cecil(1)</a></h1>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
    
    
      <p class="meta">
        








  


<<<<<<< HEAD
<time datetime="2014-02-28T00:27:22+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2014</time>
=======
<time datetime="2011-07-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/07/28/bian-yi-shi-MSIL-zhu-ru-shi-jian-Mono-Cecil-1/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/07/28/bian-yi-shi-MSIL-zhu-ru-shi-jian-Mono-Cecil-1/">Comments</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
        
      </p>
    
  </header>


<<<<<<< HEAD
  <div class="entry-content"><p>在网上看见很多问node.js如何获取客户端IP,所以记录下来，以供大家参考。</p>

<pre class='green'><code>    function getClientIp(req) {
        return req.headers['x-forwarded-for'] ||
        req.connection.remoteAddress ||
        req.socket.remoteAddress ||
        req.connection.socket.remoteAddress;
    };
</code></pre>

<p>代码，第一段判断是否有反向代理IP(头信息：x-forwarded-for)，在判断connection的远程IP，以及后端的socket的IP。</p>
=======
  <div class="entry-content"><p>&nbsp;&nbsp; 紧接上两篇<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/26/2117661.html">浅谈.NET编译时注入（C#&mdash;&gt;IL）</a>和<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/27/2119005.html">浅谈VS编译自定义编译任务&#8212;MSBuild Task(csproject)</a>，在第一篇中我们简单研究了c#语法糖和PostSharp的MSIl注入，紧接第二篇中我们介绍了自定义MSBuild编译任务（记得有位老兄发链接用 MSBuild自动发布Silverlight xap ，我想说的我做的是自定义编译任务，不是什么发布，MSBuild本就是一个发布工具）。之所以在此前介绍编译Task是因为我讲介绍的就是利用MSBuild和MSILInject制作静态注入式AOP，想成熟的产品PostSharp，当然我也不会去重造轮子，但需要明白起原理和自动化注入时机。废话不多说，今天将请出我们的MSIL注入的好东西：Mono.Cecil.官方网站<a href="http://www.mono-project.com/Cecil" title="http://www.mono-project.com/Cecil">http://www.mono-project.com/Cecil</a>，他是一个强大的MSIL 注入工具，在我们的Reflector插件Reflexil（动态修改程序集插件，很好用，我已经尝试多次）就有他的身影出现。还有如大名鼎鼎的<a href="http://www.icsharpcode.net/OpenSource/SD/">SharpDevelop</a>，<a href="http://www.linqpad.net/">LINQPad</a>，<a href="http://www.janetdev.org/">Ja.NET</a>等等（可以参见<a href="https://github.com/jbevain/cecil/wiki/Users" title="https://github.com/jbevain/cecil/wiki/Users">https://github.com/jbevain/cecil/wiki/Users</a>）。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在本节我们需要看看这个Mono.Cecil，先来一个简单的认识。</p>

<p>我来在我们的方法执行前后加入我们的输出信息：</p>

<p>原来代码：</p>

<pre><code> class Program 
   { 
       static void Main(string[] args) 
       { 
           Console.WriteLine("破浪Blog：http://www.cnblogs.com/whitewolf/"); 
       } 
   }
</code></pre>

<p>任务：</p>

<p>1我将在方法执行前后添加一个Console.WriteLine(&ldquo;Method start&#8230;&rdquo;);</p>

<p>2方法最后添加Console.WriteLine(&ldquo;Method finish&#8230;&#8220;）；</p>

<p>具体Mono.Cecil Code：</p>

<pre><code>using System; 
  using System.Collections.Generic; 
  using System.Linq; 
  using System.Text; 
  using Mono.Cecil; 
  using Mono.Cecil.Cil; 

  namespace BlogSample 
  { 
      class Program 
      { 
          static void Main(string[] args) 
          { 
              AssemblyDefinition assembiy = AssemblyFactory.GetAssembly(args[0]); 
              foreach (Mono.Cecil.TypeDefinition item in assembiy.MainModule.Types) 
              { 
                  foreach (MethodDefinition method in item.Methods) 
                  { 
                      if (method.Name.Equals("Main")) 
                      { 

                          var ins = method.Body.Instructions[0]; 
                          var worker = method.Body.CilWorker; 
                          worker.InsertBefore(ins, worker.Create(OpCodes.Ldstr, "Method start…")); 
                          worker.InsertBefore(ins, worker.Create(OpCodes.Call, 
                              assembiy.MainModule.Import(typeof(Console).GetMethod("WriteLine", new Type[] { typeof(string) })))); 
                          ins = method.Body.Instructions[method.Body.Instructions.Count - 1]; 

                          worker.InsertBefore(ins, worker.Create(OpCodes.Ldstr, "Method finish…")); 
                          worker.InsertBefore(ins, worker.Create(OpCodes.Call, 
                              assembiy.MainModule.Import(typeof(Console).GetMethod("WriteLine", new Type[] { typeof(string) })))); 
                          break; 
                      } 
                  } 

              } 

              AssemblyFactory.SaveAssembly(assembiy, "IL_" + args[0]); 
              Console.Read(); 
          } 
      } 
  }
</code></pre>

<p>DOS运行结果：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107282128456040.jpg" title="无标题" alt="image" /></p>

<p>我们在来看看反编译后的MSIL</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107282128509350.png" title="image" alt="image" />
C#：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107282128529675.png" title="image" alt="image" />
&nbsp;&nbsp;&nbsp; 在这最后我们可以想一下，如果我们利用Mono.Cecil可以干些什么事情，能做的当然很多，我首先想尝试的了与上一节<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/27/2119005.html">浅谈VS编译自定义编译任务&#8212;MSBuild Task(csproject)</a>结合PostSharp一样的静态注入AOP框架。还能做什么的就要靠大家发挥大家聪明的才智。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/28/2119969.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
<<<<<<< HEAD
      <h1 class="entry-title"><a href="/blog/2014/02/21/angular-form-addControl/">细说angular Form addControl方法</a></h1>
=======
      <h1 class="entry-title"><a href="/blog/2011/07/26/qian-tan-NET-bian-yi-shi-zhu-ru-C-IL/">浅谈.NET编译时注入（C#&#8211;&gt;IL）</a></h1>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
    
    
      <p class="meta">
        








  


<<<<<<< HEAD
<time datetime="2014-02-21T17:24:37+08:00" pubdate data-updated="true">Feb 21<span>st</span>, 2014</time>
=======
<time datetime="2011-07-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2011/07/26/qian-tan-NET-bian-yi-shi-zhu-ru-C-IL/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2011/07/26/qian-tan-NET-bian-yi-shi-zhu-ru-C-IL/">Comments</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
        
      </p>
    
  </header>


<<<<<<< HEAD
  <div class="entry-content"><p>在本篇博文中，我们将接触angular的验证。angular的验证是由form 指令和ngModel协调完成的。今天博主在这里想要说的是在验证在的一种特殊情况，当验证控件没有没有name属性这是不会被form捕获的。或者是你希望在ngRepeat中使用动态表达式。</p>

<p>下面且让我们先来从angular源码中看起如下：</p>

<p>首先是ngModel：</p>

<pre class='green'><code>    var ngModelDirective = function() {
      return {
        require: ['ngModel', '^?form'],
        controller: NgModelController,
        link: function(scope, element, attr, ctrls) {
          // notify others, especially parent forms

          var modelCtrl = ctrls[0],
              formCtrl = ctrls[1] || nullFormCtrl;

          formCtrl.$addControl(modelCtrl);

          scope.$on('$destroy', function() {
            formCtrl.$removeControl(modelCtrl);
          });
        }
      };
    };
</code></pre>

<p>从上面我们能够看出ngModel指令会在编译时期的post link阶段会通过form的 <strong>addControl</strong>方法把自己的controller注册到父节点上的form的formController中。</p>

<p>在看看ngModel controller初始化代码：</p>

<pre class='green'><code>    var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',
        function($scope, $exceptionHandler, $attr, $element, $parse) {
     ....
      this.$pristine = true;
      this.$dirty = false;
      this.$valid = true;
      this.$invalid = false;
      this.$name = $attr.name;
</code></pre>

<p>我们从上面我们可以看到 <strong>ngModel的$name属性并不支持表达式计算</strong>。</p>

<p>而FormController的addControl代码则是：</p>

<pre class='green'><code>    /**
     * @ngdoc function
     * @name ng.directive:form.FormController#$addControl
     * @methodOf ng.directive:form.FormController
     *
     * @description
     * Register a control with the form.
     *
     * Input elements using ngModelController do this automatically when they are linked.
     */
    form.$addControl = function(control) {
      // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
      // and not added to the scope.  Now we throw an error.
      assertNotHasOwnProperty(control.$name, 'input');
      controls.push(control);

      if (control.$name) {
        form[control.$name] = control;
      }
    };
</code></pre>

<p>从上面我们可以清楚的看见虽然ngModel注册了自己，但是这里也不一定能注册成功，<strong>ngModel心必须有自己的$name才能被注册成功</strong>。</p>

<p>从上面的代码中可以得出，当我们的验证失效的时候，我们可以有一个万能的方式就是 <strong>手动注册到form controller</strong></p>

<h3>手动注册form controller</h3>

<p>为了我写了一个dy-name的插件，其会在post link阶段解析表达式，并把自己注册到父form controller。</p>

<p>如下：</p>

<pre class='green'><code>    .directive("dyName", [

        function() {
          return {
            require: "ngModel",
            link: function(scope, elm, iAttrs, ngModelCtr) {
              ngModelCtr.$name = scope.$eval(iAttrs.dyName)
              var formController = elm.controller('form') || {
                $addControl: angular.noop
              };
              formController.$addControl(ngModelCtr);

              scope.$on('$destroy', function() {
                formController.$removeControl(ngModelCtr);
              });

            }
          };
        }
      ])
</code></pre>

<p>使用方式：</p>

<pre class='green'><code>    &lt;div ng-repeat="item in demo.fields"&gt;
      &lt;div class="control-group"&gt;
        &lt;label class="control-label"&gt; : &lt;/label&gt;
        &lt;div class="controls"&gt;
          &lt;input type="number"  dy-name="item.field" ng-model="demo.data[item.field]" min="10" max="500" ng-required="true"/&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre>

<p>其实实现为在post link阶段获取到form controller，并把自己注册到form controller，而且为了消除对象的级联，将会在scope摧毁阶段remove自己。</p>

<p>其效果请看<a href="http://jsbin.com/docow/1/edit?html,js,output">jsbin $addControl</a></p>

<p><strong>注意</strong>:在formController.$addControl方法的参数传入的不是界面控件，而是ngModelController.或者名字为$addController更合适。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/16/angularjs-chinese-guide-public/">Angularjs中文版本开发指南发布</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-16T02:02:17+08:00" pubdate data-updated="true">Feb 16<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://angularjs.org/img/AngularJS-large.png" alt="http://angularjs.org/img/AngularJS-large.png" /></p>

<p>从本人开始在写关于Angularjs的文章开始，也算是见证了Angularjs在国内慢慢的火起来，如今的Angularjs正式如日中天。想知道为什么Angularjs会这么火，请移步<a href="http://www.cnblogs.com/whitewolf/p/angularjs-remove-unused-watch.html">angularjs移除不必要的$watch</a>.</p>

<p>也是一次偶然的机会，在Angular.js中文社区群里相遇一群Angular的爱好者，在一次巧妙的交谈，大家对于Angular官方的Guide最新版本没有中文版本表示无助，所以为了诸君更好的了解学习Angularjs，大家临时组织了一个Angular 开发指南翻译团队。</p>

<p>在经过一段时间的协调和大家付出工作之外的业余时间，如今Angularjs的中文本学习指南终于上线出炉</p>

<p>地址为：</p>

<pre class='green'><code>[http://www.ngnice.com/](http://www.ngnice.com/)
</code></pre>

<p>在翻译过程中大家力求准确，但也并不是逐字翻译，也会加上一些&#8221;译者注&#8221;之类，让大家能够更好的学习，使用Angularjs。同时在Angular开发指南首页我们也收集了很多很好的Angularjs学习资料供大家学习。</p>

<p>最后虽然大家都很努力的翻译力求精准，但也会难免有些issue，请不辞指出，可以提交在github repo issue,或者本文后边加上评论。</p>

<p>同时在本博客中也会很多关于Angularjs实践方面的博客，欢迎大家不辞指教。</p>
=======
  <div class="entry-content"><p>&nbsp;&nbsp;&nbsp;&nbsp; .NET是一门多语言平台，这是我们所众所周知的，其实现原理在于因为了MSIL（微软中间语言）的一种代码指令平台。所以.NET语言的编译就分为了两部分，从语言到MSIL的编译（我喜欢称为预编译），和运行时的从MSIL到本地指令，即时编译（ＪＩＴ）。ＪＩＴ编译分为经济编译器和普通编译器，在这里就不多说了，不是本文的重点。本文主要讨论下预编译过程中我们能做的改变编译情况，改变生成的ＩＬ，从编译前后看看微软Ｃ＃３．０一些语法糖，PostSharp的静态注入等等。</p>

<p>１：我们先来看看最简单的var:</p>

<p>Ｃ#:</p>

<pre><code>public void TestVar() { 
    var i = 0;    Console.WriteLine(i); }
</code></pre>

<p>使用Reflector查看生成</p>

<p>ＩＬ：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124334478.jpg"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/20110726212434999.jpg" title="clip_image001" alt="clip_image001" /></a></p>

<p>反编译后的Ｃ＃：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124353474.jpg"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124359853.jpg" title="clip_image002" alt="clip_image002" /></a></p>

<p>这里ＶＳ在编译的时候将ｖａｒ为我们转变为了ｉｎｔ类型。</p>

<p>２：Action&lt;int&gt;：</p>

<p>Ｃ＃：</p>

<pre><code>public void TestAction() { var i = 1; Func&lt;int,int&gt; f = t =&gt; t+1; i=10; f(i); }
</code></pre>

<p>反编译后Ｃ＃：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124351772.jpg"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124364737.jpg" title="clip_image004" alt="clip_image004" /></a></p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124369164.jpg"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124379131.jpg" title="clip_image005" alt="clip_image005" /></a></p>

<p>编译器为我们在这里生成了代理方法。</p>

<p>总结：</p>

<p>关于lambda表达式的编译规则：</p>

<p>当一个lambda expression被赋值给一个delegate类型，例如<a href="http://msdn2.microsoft.com/en-us/library/018hxwa8.aspx">Action&lt;T&gt;</a>或者<a href="http://msdn2.microsoft.com/en-us/library/bb549151.aspx">Func&lt;T, TResult&gt;</a>等，这个lambda expression会被编译器直接编译为
1) 当lambda expression没有使用闭包内的非局部引用也没有使用到this时，编译为一个私有静态方法；
2) 当lambda expression没有使用闭包内的非局部引用，但用到了this时，编译为一个私有成员方法；
3) 当lambda expression中引用到非局部变量，则编译为一个私有的内部类，将引用到的非局部变量提升为内部类的。</p>

<p>３：PostSharp：</p>

<p>PostSharp是结合了 MSBuild Task 和 MSIL Injection 技术，编译时静态注入实现 AOP 编程。在编译时候改变VS的编译行为。更详细的信息，请访问 <a href="http://www.postsharp.org/">PostSharp</a> 网站</p>

<p>原ｃ＃：</p>

<pre><code>    using System;

  using System.Collections.Generic;

  using System.Linq;

  using System.Text;

  namespace ConsoleApplication1

  {

  class Program

  {

  static void Main(string[] args)

  {

  new Program().TestPostSharp();

  }

  [ErrorHandler()]

  public void TestPostSharp()

  {

  throw new Exception("I will throw a exception!");

  }

  }

  [Serializable]

  public class ErrorHandlerAttribute : PostSharp.Laos.OnMethodBoundaryAspect

  {

  public override void OnException(PostSharp.Laos.MethodExecutionEventArgs eventArgs)

  {

  //do some AOP operation!

  Console.WriteLine(eventArgs.Method+":" +eventArgs.Exception.Message);

  eventArgs.FlowBehavior = PostSharp.Laos.FlowBehavior.Continue;

  }

  }

  }
</code></pre>

<p>反编译后：</p>

<p><a href="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124385030.jpg"><img src="http://images.cnblogs.com/cnblogs_com/whitewolf/201107/201107262124418146.jpg" title="clip_image007" alt="clip_image007" /></a></p>

<p>今天就到此为至,只是简单的了解下IL注入实例,在后面会利用<strong>MSBuild Task+Mono Cecil</strong> 和<strong>PostSharp</strong>实现一些简单的注入实例.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过程序<a href="https://github.com/greengerong/cnblogs-blogs2markdown" title="cnblogs-blogs2markdown">cnblogs-blogs2markdown</a>转换的,如质量有问题<a href="http://www.cnblogs.com/whitewolf/archive/2011/07/26/2117661.html" title="原文首发">原文首发请看这里</a></p>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/8/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/6/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>破 狼</h1>
  <p>    那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息。 那一月，我转过所有经轮，不为超度，只为触摸你的指纹。 那一年，我磕长头拥抱尘埃，不为朝佛，只为贴着了你的温暖。 那一世，我翻遍十万大山，不为修来世，只为路中能与你相遇。 那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。<a href="http://greengerong.github.io/blog/2009/12/24/cang-yang-jia-cuo-na-yi-tian-na-yi-yue-na-yi-nian-na-yi-shi/">《那一天，那一月，那一年，那一世》&#8211;仓央嘉措。</a></p>
</section>
<section>
  <p style="align: center"><a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3158890&amp;c=9476983" alt="count web site visits"/></a></p>
<<<<<<< HEAD
</section>
<section>
    <h1>博客友情链接</h1>
    <ul>
        <li><a href="http://www.cnblogs.com/whitewolf/">博客园-破狼</a></li>
        <li><img src="http://greengerong.com/self/wei-xin-wolf-er-wei-ma.jpg" alt="破狼微信号订阅号" /></li>
    </ul>
=======
  <div style="display: none;">
    <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa24b16b917fd5e88f6d6dd10dc673619' type='text/javascript'%3E%3C/script%3E"));
</script>

  </div>
</section>
<section>
<h1>博客友情链接</h1>
  <ul>
    <li><a href="http://www.cnblogs.com/whitewolf/">博客园-破狼</a></li>
    <li><a href="http://whitewolfblog.blog.51cto.com/">51CTO&#8211;破狼</a></li>
  </ul>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
<<<<<<< HEAD
        <a href="/blog/2016/01/30/zone-dot-js-bao-li-zhi-mei/">zone.js - 暴力之美</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/30/angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie/">《AngularJS深度剖析与最佳实践》简介</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/20/ni-ying-gai-zhi-dao-de-jqueryji-qiao/">(译)你应该知道的jQuery技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/18/javascript-duo-xian-cheng-zhi-html5-web-worker/">JavaScript多线程之HTML5 Web Worker</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/11/angular-remove-unnecessary-watch-to-improve-performance/">Angular移除不必要的$watch之性能优化</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/">JavaScript单线程和浏览器事件循环简述</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/22/promisede-miao-yong/">Promise的前世今生和妙用技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian/">自定义Angular插件 - 网站用户引导</a>
=======
        <a href="/blog/2014/02/28/nodejs-get-client-ip/">nodejs获取客户端IP Address</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/21/angular-form-addControl/">细说angular Form addControl方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/16/angularjs-chinese-guide-public/">Angularjs中文版本开发指南发布</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/15/index-for-ng-options/">为Angularjs ngOptions加上index解决方案</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/11/angular-ngclick-stoppropagation/">Angular ngClick阻止冒泡,默认行为</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/27/angular-ngcloak-new/">ngCloak 实现 Angular 初始化闪烁最佳实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/27/angular-ngcloak/">ngCloak 实现 Angular 初始化闪烁最佳实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/24/angular-controller-as-syntax-vs-scope/">Angular Controller as Syntax vs Scope</a>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/greengerong">@greengerong</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'greengerong',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
<<<<<<< HEAD
  Copyright &copy; 2016 - 破 狼 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress
</a></span>
=======
  Copyright &copy; 2014 - 破 狼 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0
</p>

</footer>
  
<<<<<<< HEAD
 
 
=======

<script type="text/javascript">
      var disqus_shortname = 'greengerong';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>









>>>>>>> 0bab7647fe4f4f5795aed418af9d97aabf2983a0


</body>
</html>
