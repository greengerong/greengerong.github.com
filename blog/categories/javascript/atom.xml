<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | 破狼 Blog]]></title>
  <link href="http://greengerong.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2015-06-16T11:46:12+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    <email><![CDATA[grzx2210@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[angular中的MVVM模式]]></title>
    <link href="http://greengerong.github.io/blog/2015/06/16/angularzhong-de-mvvmmo-shi/"/>
    <updated>2015-06-16T11:33:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/06/16/angularzhong-de-mvvmmo-shi</id>
    <content type="html"><![CDATA[<p> 在开始介绍angular原理之前，我们有必要先了解下mvvm模式在angular中运用。虽然在angular社区一直将angular统称为前端MVC框架，同时angular团队也称它为MVW（Whatever）框架，但angular框架整体上更接近MVVM模式。下面是Igor Minar发布在Google+ <a href="https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV">https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV</a>的文章内容：</p>

<p> MVC vs MVVM vs MVP. What a controversial topic that many developers can spend hours and hours debating and arguing about.</p>

<p>For several years +AngularJS was closer to MVC (or rather one of its client-side variants), but over time and thanks to many refactorings and api improvements, it&rsquo;s now closer to MVVM – the $scope object could be considered the ViewModel that is being decorated by a function that we call a Controller.</p>

<p>Being able to categorize a framework and put it into one of the MV* buckets has some advantages. It can help developers get more comfortable with its apis by making it easier to create a mental model that represents the application that is being built with the framework. It can also help to establish terminology that is used by developers.</p>

<p>Having said, I&rsquo;d rather see developers build kick-ass apps that are well-designed and follow separation of concerns, than see them waste time arguing about MV* nonsense. And for this reason, I hereby declare AngularJS to be MVW framework &ndash; Model-View-Whatever. Where Whatever stands for &ldquo;whatever works for you&rdquo;.</p>

<p>Angular gives you a lot of flexibility to nicely separate presentation logic from business logic and presentation state. Please use it fuel your productivity and application maintainability rather than heated discussions about things that at the end of the day don&rsquo;t matter that much.</p>

<p>在文中特别指出angular在多次的API重构和改善，它越来越接近于MVVM模式，$scope可以被认为是ViewModl，而Controller则是装饰、加工处理这个ViewModel的JavaScript函数。作者更希望大家关注于实现一个成功的，具有好的设计以及遵循“分离关注点”原则的应用程序，而不是去争论MV*，所以他将angular称为MVW框架，是什么并不重要，只要适合你的应用就行。</p>

<p> MVVM模式是Model-View-ViewMode（模型-视图-视图模型）模式的简称，其最早出现在微软的WPF和Silverlight框架中。MVVM模式利用框架内置的双向绑定技术对MVP（Model-View-Presenter）模式的变型，引入了专门的ViewModel（视图模型）来实现View和Model的粘合，让View和Model的进一步分离和解耦。MVVM模式的优势有如下四点：</p>

<ol>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ol>


<p>下面是angular中关于MVVM模式的运用：</p>

<p><img src="/images/blog_img/angular-mvvm.png" alt="angular mvvm" /></p>

<p>在angular中MVVM模式主要分为四部分：</p>

<ol>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。</li>
</ol>


<p>View不能直接与Model交互，而是通过$scope这个ViewModel来实现与Model的交互。对于界面表单的交互，通过ngModel指令来实现View和ViewModel的同步。ngModelController包含$parsers和$formatters两个转换器管道，它们分别实现View表单输入值到Model数据类型转换和Model数据到View表单数据的格式化。对于用户界面的交互Command事件（如ngClick、ngChange等）则会转发到ViewModel对象上，通过ViewModel来实现对于Model的改变。然而对于Model的任何改变，也会反应在ViewModel之上，并且会通过$scope的“脏检查机制”（$digest）来更新到View。从而实现View和Model的分离，达到对前端逻辑MVVM的分层架构。</p>

<p>angular中MVVM模式的实现，以领域Model为中心思维，遵循“分离关注点”设计原则，这也是与jQuery以DOM驱动的思维所不同之处。所以我们在做angular开发的时候应该谨记下面几点：</p>

<h4>绝不要先设计你的页面，然后用DOM操作去改变它</h4>

<p>在以往的jQuery开发中，我们会首先设计页面DOM结构，然后在利用jQuery来改变DOM结构或者实现动态交互效果。因为jQuery是为DOM驱动而设计的，对于拥有大量复杂的前端交互的项目，JavaScript的逻辑变得越来越臃肿，交互逻辑分散各处。</p>

<p>在MVVM模式下的angular开发中， 我们首先需要在脑子里挂着Model的弦。不能老想着“我有XXX这个DOM，我希望让它做XXX这种动态效果”，我们需要从要完成的目标开始思考我们需要或拥有怎么样的Model数据，然后设计我们的应用， 最后才是设计视图，并用$scope来粘合它们。</p>

<h4>Directive不是封装jQuery代码的“天堂”</h4>

<p>如上条所述，我们不能一开始就去想如何利用DOM操作的方法去实现应用目标，然后“冠冕堂皇”的写上一堆jQuery的代码，并将其封装到angular的directive中，最后不得不加上$scope.$apply()来通知angular你的ViewModel的改变，需要启动“脏检查机制”来更新你的改变到View。作者在多个客户项目中看见这种将Directive作为封装jQuery代码“天堂”的例子，其实对于这类问题，大部分情况下，我们都可以用很少了angular代码将其重构为真正的angular way。特别在ng社区经常看见在angular directive中利用jQuery的on方法绑定click、keydown、blur等事件的代码，大部分情况我们都能以对应的ng事件（ngClick、ngChange、ngBlur）来重构它们。</p>

<p>对于这类问题，首先我们应该尽量尝试复用angular的内置指令，以真正的angular way去思考我们的问题，请慎重的引入jQuery的DOM方法和操作。</p>

<p>关于angular MVVM模式的资料，你还可以参考视频：<a href="https://frontendmasters.com/courses/angularjs-mvc-mvvm-mvwhatever/#v=ypur7bfbcq">https://frontendmasters.com/courses/angularjs-mvc-mvvm-mvwhatever/#v=ypur7bfbcq</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript函数柯里化]]></title>
    <link href="http://greengerong.github.io/blog/2015/05/11/jshan-shu-ke-li-hua/"/>
    <updated>2015-05-11T19:37:18+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/05/11/jshan-shu-ke-li-hua</id>
    <content type="html"><![CDATA[<h4>函数式</h4>

<p>JavaScript是以函数为一等公民的函数式语言。函数在JavaScript中也是一个对象（继承制Function），函数也可以作为参数传递成函数变量。最近几年函数式也因为其无副作用的特性、透明性、惰性计算等在高并发，大数据领域火起来了。</p>

<p>JavaScript中也有如Underscore、lodash之类的函数式库，如lodash的使用方式：</p>

<p>```javascript</p>

<pre><code>var names = _.chain(users)
  .map(function(user){
    return user.user;
  })
  .join(" , ")
  .value();
console.log(names);
</code></pre>

<p>```</p>

<p>关于lodash更多内容请参考<a href="http://www.cnblogs.com/whitewolf/p/4417873.html">JavaScript工具库之Lodash</a>.</p>

<h4>柯里化</h4>

<p>今天文章将以高阶函数中的柯里化方式来，看看JavaScript的函数式能力。</p>

<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>

<p>在理论计算机科学中，柯里化提供了在简单的理论模型中比如只接受一个单一参数的lambda 演算中研究带有多个参数的函数的方式。</p>

<h4>JavaScript的柯里化实现</h4>

<p>下边的例子，我们将把柯里化方式泛化为接受任意个参数，直到声明的方法参数个数饱和才执行，所以根据参数个数可以有多种柯里化函数产生。</p>

<p>代码如下：</p>

<p>```javascript</p>

<pre><code>(function(global) {
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
        FN_ARG_SPLIT = /,/,
        FN_ARG = /^\s*(_?)(\S+?)\1\s*$/,
        STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

    var getArgLength = function(func) {
        var fnText = func.toString().replace(STRIP_COMMENTS, '');
        var argDecl = fnText.match(FN_ARGS);
        var params = [];
        argDecl[1].split(FN_ARG_SPLIT).forEach(function(arg) {
            arg.replace(FN_ARG, function(all, underscore, name) {
                params.push(name);
            });
        });
        return params.length;
    };

    var curryFunc = function(func, len) {
        len = len || getArgLength(func);
        var args = [];
        if (len === 0) {
            return func.apply(null);
        }

        return function() {
            [].push.apply(args, [].slice.apply(arguments));
            if (args.length &gt;= len) {
                return func.apply(null, args);
            }

            return arguments.callee;
        };
    };

    global.curryFunc = curryFunc;
})(this);

function add(x, y, z) {
    return x + y + z;
}

console.log("result 1:", curryFunc(add)(1, 2)(3));
console.log("result 2:", curryFunc(add)(1)(2, 3));
console.log("result 3:", curryFunc(add)(1)(3)(2));

function add(x, y, z) {
    return x * y * z;
}

console.log("result 1:", curryFunc(add)(2, 4)(6));
console.log("result 2:", curryFunc(add)(2)(4, 6));
console.log("result 3:", curryFunc(add)(2)(6)(4));

function sayHello() {
    return "hello";
}
console.log(curryFunc(sayHello));
</code></pre>

<p>```</p>

<p>首先上面会利用正则来获取传入函数的参数个数。再返回一个函数的代理，每次的调用都会将传入参数缓存在args临时变量中，直到参数个数饱和才会立即执行。代码比较冗长，慢慢品味，当然有不足之处，也希望大家指出来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScript - Modules(模块)]]></title>
    <link href="http://greengerong.github.io/blog/2015/04/12/typescript-modules-mo-kuai/"/>
    <updated>2015-04-12T16:52:50+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/04/12/typescript-modules-mo-kuai</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>在TypeScript中提供了module(模块)的方式管理和组织代码结构。这里覆盖了内部和外部的模块，以及在何时怎么使用它。当然也有一些高级话题如何使用外部模块以及如何组织公用模块。</p>

<h2>第一步</h2>

<p>让我们从下面的例子开始，这个例子将会贯通本文。首先我们写了一段字符串验证的例子，用来验证用户在web页面form表单输入的信息，或者是外部文件导出的数据信息。</p>

<h4>单文件的验证逻辑</h4>

<pre><code>interface StringValidator {
    isAcceptable(s: string): boolean;
}

var lettersRegexp = /^[A-Za-z]+$/;
var numberRegexp = /^[0-9]+$/;

class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}

class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}

// Some samples to try
var strings = ['Hello', '98052', '101'];
// Validators to use
var validators: { [s: string]: StringValidator; } = {};
validators['ZIP code'] = new ZipCodeValidator();
validators['Letters only'] = new LettersOnlyValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log('"' + s + '" ' + (validators[name].isAcceptable(s) ? ' matches ' : ' does not match ') + name);
    }
});
</code></pre>

<h4>增加模块化</h4>

<p>我们将会增加更多的验证逻辑，并且我们希望有个好的代码组织来避免全部的污染和命名冲突。所以更好的方式是给一个命名空间来  组织我们的对象在一个模块中。</p>

<p>在下面我们将把所有的验证逻辑移到一个叫‘Validation’的模块来组织我们的代码逻辑。因为我们希望interface和class在外部模块可见，所以我们加上了‘export’关键字导出成员。相反lettersRegexp和numberRegexp的逻辑是你不实现，我们并不希望暴露给外部模块。在文件最后的测试代码是放在外部模块，例如Validation.LettersOnlyValidator之类的。</p>

<h4>模块化的Validators</h4>

<pre><code>module Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }

    var lettersRegexp = /^[A-Za-z]+$/;
    var numberRegexp = /^[0-9]+$/;

    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }

    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}

// Some samples to try
var strings = ['Hello', '98052', '101'];
// Validators to use
var validators: { [s: string]: Validation.StringValidator; } = {};
validators['ZIP code'] = new Validation.ZipCodeValidator();
validators['Letters only'] = new Validation.LettersOnlyValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log('"' + s + '" ' + (validators[name].isAcceptable(s) ? ' matches ' : ' does not match ') + name);
    }
});
</code></pre>

<h2>分离模块文件</h2>

<p>随之项目代码的增加，我们希望能够分离文件，让项目更好的维护和开发。</p>

<p>在下面我们将分离我们的验证逻辑为多个文件。虽然分离在多个文件，但是我们仍然可以共享一个命名空间，因为需要告诉编译器文件之间的关系，所以我在文件开始加入了reference tags得标记。再对于我们的测试代码没有什么改变。</p>

<h4>多文件的内部模块</h4>

<h6>Validation.ts</h6>

<pre><code>module Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }
}
</code></pre>

<h6>LettersOnlyValidator.ts</h6>

<pre><code>/// &lt;reference path="Validation.ts" /&gt;
module Validation {
    var lettersRegexp = /^[A-Za-z]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
}
</code></pre>

<h6>ZipCodeValidator.ts</h6>

<pre><code>/// &lt;reference path="Validation.ts" /&gt;
module Validation {
    var numberRegexp = /^[0-9]+$/;
    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}
</code></pre>

<h6>Test.ts</h6>

<pre><code>/// &lt;reference path="Validation.ts" /&gt;
/// &lt;reference path="LettersOnlyValidator.ts" /&gt;
/// &lt;reference path="ZipCodeValidator.ts" /&gt;

// Some samples to try
var strings = ['Hello', '98052', '101'];
// Validators to use
var validators: { [s: string]: Validation.StringValidator; } = {};
validators['ZIP code'] = new Validation.ZipCodeValidator();
validators['Letters only'] = new Validation.LettersOnlyValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log('"' + s + '" ' + (validators[name].isAcceptable(s) ? ' matches ' : ' does not match ') + name);
    }
});
</code></pre>

<p>如果存在多文件的依赖，我们需要保证编译器能加载各个文件。这里有两种方式做到：</p>

<p>第一种方式：可以利用 &mdash;out 连接多个输入文件让编译器编译成一个单一js文件（）。这样编译器会自动根据 reference tags 自动组织多个文件编译成一个js文件。我们也可以组织个别的文件如：。</p>

<p>第二种方式：我们也可以采用预先文件的编辑来加载多个文件，我们可以使用script tag在web页面加载来控制文件顺序，例如：</p>

<h6>#MyTestPage.html (excerpt)</h6>

<pre><code>&lt;script src="Validation.js" type="text/javascript" /&gt;
&lt;script src="LettersOnlyValidator.js" type="text/javascript" /&gt;
&lt;script src="ZipCodeValidator.js" type="text/javascript" /&gt;
&lt;script src="Test.js" type="text/javascript" /&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript工具库之Lodash]]></title>
    <link href="http://greengerong.github.io/blog/2015/04/11/qian-duan-ku-zhi-lodash/"/>
    <updated>2015-04-11T14:53:27+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/04/11/qian-duan-ku-zhi-lodash</id>
    <content type="html"><![CDATA[<p>你还在为JavaScript中的数据转换、匹配、查找等烦恼吗？一堆看似简单的foreach，却冗长无趣，可仍还在不停的repeat it！也许你已经用上了Underscore.js，不错，你已经进步很大一步了。然而今天我希望你能更进一步，利用lodash替换掉Underscore。</p>

<p>lodash一开始是Underscore.js库的一个fork，因为和其他(Underscore.js的)贡献者意见相左。John-David Dalton的最初目标，是提供更多“一致的跨浏览器行为……，并改善性能”。之后，该项目在现有成功的基础之上取得了更大的成果。最近lodash也发布了3.5版，成为了npm包仓库中依赖最多的库。它正在摆脱屌丝身份，成为开发者的常规选择之一。</p>

<p>现在我们所熟知的很多开源项目都已经使用或者转到了lodash阵营之上。比如JavaScript转译器Babel、博客平台Ghost，和项目脚手架工具Yeoman。特别Ghost是从Underscore迁移到了lodash，Ghost的创始人John O'Nolan对于此曾评价到：“这是一个非常明智的选择，它几乎完全是由我们开源开发社区推动的。我们发现lodash包含更多的功能，更好的性能、恰到好处地使用了semver，并且在Node.js社区（以及其他依赖）中越来越抢眼“。</p>

<h2>lodash演练</h2>

<p>lodash主要使用了延迟计算，使得lodash其性能远远超过Underscore。在lodash中延迟计算意味着在我们的链式方法在显示或隐式的value()调用之前是不会执行的。由于这种执行的延后，因此lodash可以进行shortcut fusion这样的优化，通过合并链式iteratee大大降低迭代的次数。从而大大提供其执行性能。</p>

<p>百说不如一练，下面我们以用户信息为例：</p>

<pre><code>var users = [
  { 'user': 'barney',  'age': 36 },
  { 'user': 'fred',    'age': 40 },
  { 'user': 'pebbles', 'age': 18 }
];
</code></pre>

<h4>1. 获取所有用户名字，并以”，“分割</h4>

<pre><code>var names = _.chain(users)
  .map(function(user){
    return user.user;
  })
  .join(" , ")
  .value();
console.log(names);
</code></pre>

<p>个人比较喜欢lodash延迟计算的现实value，以及JavaScript的函数式风格。在这里首先将users对象包装成为lodash对象，再map获取所有用户的名称，并最后利用join将用户名称以”，“连接在一起。注意这里只是一串方法链，如果你没有显样的调用value方法，使其立即执行的化，你将会得到如下的LodashWrapper延迟表达式：</p>

<pre><code> LodashWrapper {__wrapped__: LazyWrapper, __actions__: Array[1], __chain__: true, constructor: function, after: function…}
</code></pre>

<p> 因为延迟表达式的存在，因此我们可以多次增加方法链，但这并不会被执行，所以不会存在性能的问题，最后知道我们需要使用的时候，使用value显式立即执行即可。</p>

<h4>2. 获取最年轻的用户</h4>

<pre><code> var youngest = _.chain(users)
  .min(function(user){
    return user.age;
  })
  .value();
console.log(youngest);
</code></pre>

<p>这里利用了lodash提供的min函数可以轻易的解决。</p>

<p>在这里博主还希望用另外一个方式解释lodash方法链的优化,上面的方法可以等价为下面的方式，以age排序的第一个user：</p>

<pre><code>var youngest2 = _.chain(users)
  .sortBy("age")
  .map(function(user){
    console.log("map", user);
    return user;
  })
  .first()
  .value();
console.log(youngest2);
</code></pre>

<p>在这里博主多加了一个map作为log输出，如果你执行这行代码的时候，你会惊奇的看见这里只会有一个user的输出，这点可以证明在立即执行的时候lodash为我们的方法链做了可靠的优化；如果我们去掉first函数你则会看见有3个user对象的输出。</p>

<h4>3. 获取最年长的用户</h4>

<pre><code>var oldest  = _.chain(users)
  .max(function(user){
    return user.age;
  })
  .value();

console.log(oldest );
</code></pre>

<p>这里则使用lodash的max函数。</p>

<h4>4. 用户数组到用户Map的转换</h4>

<p>在开发中我们经常会有把一堆素组形式的数据转换为Object形式的数组，便于根据属性key值查找，下面将以user对象来演示：</p>

<pre><code>var userObj = _.chain(users)
  .map(function(user){
    return [user.user, user.age];
  })
  .zipObject()
  .value();
console.log(userObj);
</code></pre>

<p>利用lodash首先将user数组map为[key, value]的数组集合，最后利用zipObject将结果转换为Object对象，zipObject会利用结果集的第一项作为key，第二项作为value生产Object。</p>

<h2>结尾</h2>

<p>我们在这里展示知识lodash中很小一部分的API，正如随笔开始所说：lodash是为了提供更多“一致的跨浏览器行为……，并改善性能”API。所有的lodash API你可以在这里<a href="https://lodash.com/docs#matches">https://lodash.com/docs#matches</a>查找。</p>

<p>本文的所演示的demo，你也可以在jsbin <a href="http://jsbin.com/xocixubaru/1/edit?html,js,output">http://jsbin.com/xocixubaru/1/edit?html,js,output</a>演示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(转)Babel-现在开始使用 ES6]]></title>
    <link href="http://greengerong.github.io/blog/2015/03/22/babel-kai-shi-es6ti-yan/"/>
    <updated>2015-03-22T20:11:07+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/03/22/babel-kai-shi-es6ti-yan</id>
    <content type="html"><![CDATA[<p>在 2 月 20 号 ECMAScript 第六版就正式推出了，这门语言一直保持稳定快速的发展而且新功能也在慢慢被现在主流的 JavaScript 引擎所接受。不过要想在浏览器端或者 Node 端直接运行 ES6 代码还得等上一些日子。幸好 TC39 (负责研究开发 EMCAScript 规格的组织) 做了大量工作让我们现在可以使用 ES6 中的大部分特性了。</p>

<h2>代码转换</h2>

<p>能够实现 ES6 到 ES5 的代码转换多亏了 <a href="https://babeljs.io/">Babel</a> (以前叫 6to5) 以及 Traceur 之类的项目。这些转换器 (更准确地说是源代码到源代码的编译器) 可以把你写的符合 ECMAScript 6 标准的代码完美地转换为 ECMAScript 5 标准的代码，并且可以确保良好地运行在所有主流 JavaScript 引擎中。</p>

<p>我们这里目前在使用 Babel，主要是因为它对 ES6 的支持程度比其它同类更高，而且 Babel 拥有完善的文档和一个很棒的<a href="https://babeljs.io/repl/">在线交互式编程环境</a>。</p>

<h2>起步</h2>

<p>在用 ES6 标准开始一个新项目的时候我们会建立一个目录结构来确保用 ES6 编写的代码能和编译出的 ES5 代码区分开。原始的 ES6 代码我们放在 src 目录下，而编译好的文件就是 lib 目录。这样的命名我们会在本文一直使用。（补充一点，lib 目录应该被加入 .gitignore 文件中）</p>

<h2>安装 Babel</h2>

<p>如果你还没安装 Babel 可以使用 npm 来安装：</p>

<pre><code>npm install -g babel
</code></pre>

<p>Babel 一旦安装完成就可以开始编译你的 ES6 代码了。再确认一遍你已经在 src 目录放入了一些 ES6 文件，下面的命令将会把这个目录下所有 .es6, .es 和 .js 后缀的文件编译成符合 ES5 规范的代码到 lib 目录下：</p>

<pre><code>babel -d lib/ src/
</code></pre>

<p>如果你想在文件有改动的时候自动完成这些编译工作可以使用这些常用的 JavaScript 构建工具：<a href="https://github.com/babel/grunt-babel">Grunt</a>, <a href="https://github.com/babel/gulp-babel">Gulp</a> 和 <a href="https://github.com/babel/broccoli-babel-transpiler">Brocolli</a>.</p>

<h2>给 ES6 标准库一个"腻子"</h2>

<p>Babel 作为一个源到源的编译器不可能呈现所有 ES6 标准库中的新特性，例如 Map 和 Set 构造器和 Array 下的一些新方法。要使用这些我们需要一个"腻子"来填补这些不足。现在有很多 ES6 的腻子比如 core-js，它适用与 Node, io.js 和浏览器。</p>

<p>译者注: 本节原始标题为 Polyfilling the standard library，术语 polyfill 来自于一个家装产品Polyfilla:</p>

<p>Polyfilla 是一个英国产品，在美国称之为 Spackling Paste (刮墙的,在中国称为腻子)。记住这一点就行: 把旧的浏览器想象成为一面有了裂缝的墙.这些 polyfill 会帮助我们把这面墙的裂缝抹平,还我们一个更好的光滑的墙壁 (浏览器)</p>

<h2>编写 ES6 代码</h2>

<p>现在构建 ES6 代码的工具已经备齐了那我们就开始真正有趣的部分。我们不会过多着眼于某个新特性，如果你有需要可以阅读 <a href="https://github.com/lukehoban">Luke Hoban</a> 的 <a href="https://github.com/lukehoban/es6features">feature list</a>.</p>

<p>我们先在 src 目录下创建一个叫 person.es6 的文件：</p>

<pre><code>import 'core-js/shim';

export default class Person {

  constructor( name ) {
    this.name = name;
  }

  sayHello() {
    return `Hello ${ this.name }!`;
  }

  sayHelloThreeTimes() {
    let hello = this.sayHello();
    return `${ hello } `.repeat(3);
  }
}
</code></pre>

<p>在这个很简单的例子中我们用了数个需要 Babel 来解决兼容性的语法，还有一个新的方法 String#repeat 须要由 core-js 处理。你可以用本文开头给出的 Babel 命令行代码或者用 <a href="http://ow.ly/JJyhz">REPL</a> 得到运行结果。</p>

<h2>发布到 npm</h2>

<p>目前为止我们可以编写、编译和运行 ES6 代码，不过你也许还想把你的代码发布到 npm 上。你显然不能直接发布然后期望每个人都来自己编译一次。</p>

<p>幸好，npm 允许你在发布前用 <a href="https://docs.npmjs.com/misc/scripts">prepublish script</a> 选项来修改，这个特性在 CoffeeScript 项目中已经被广泛使用了。</p>

<p>现在把 package.json 文件加入到项目根目录中：</p>

<pre><code>{
  "name": "person",
  "version": "0.1.0",
  "scripts": {
    "compile": "babel -d lib/ src/",
    "prepublish": "npm run compile"
  },
  "main": "lib/person.js",
  "dependencies": {
    "core-js": "^0.6.0"
  },
  "devDependencies": {
    "babel": "^4.6.0"
  }
}
</code></pre>

<p>注意这个 compile script 会直接运行你在右边提供 Babel 命令，这样你就可以直接运行 npm run compile 来编译而不需要键入文件目录了，而 prepublish script 会在你每次执行 npm publish 的时候自动运行。</p>

<p>还有就是为什么 Babel 会被加入 development dependencies 中，这样如果有人想参与这个项目就不用全局安装 Babel 了，npm 会把你项目下包含可执行文件的 node_modules 目录加入到系统环境变量 path 中。</p>

<h2>.npmignore 文件</h2>

<p>最后你需要确保发布的是编译出的文件而不是原始的 ES6 文件。如果你的项目根目录有 .gitignore 而没有 .npmignore 那 npm 就会自动忽略你项目中包含在 .gitignore 里所有的 文件和目录。添加 .npmignore 这样你发布的包里就是编译好的文件：</p>

<pre><code>src/
</code></pre>

<h2>总结</h2>

<p>编写 ES6 代码并使用源到源的编译器如 <a href="https://babeljs.io/">Babel</a> 或者 <a href="https://github.com/google/traceur-compiler">Traceur</a> 来转换成标准 ES5 代码
使用 ES6 标准库腻子如 <a href="https://github.com/zloirock/core-js">core-js</a>
记得在发布到 npm 的时候添加 .npmignore 文件
你可以在我们的 <a href="https://github.com/mammaldev/update-couch-designs">update-couch-designs</a> 项目中看到一个完整的例子，这个项目是我们用于更新和新建 CouchDB 设计文档的简单脚本。</p>

<p>原文：<a href="http://www.kchanzen.com/using-es6-today/">懂香&mdash;《现在开始使用 ES6》</a>
翻译自 <a href="http://mammal.io/articles/using-es6-today/">Using ES6 with npm today</a></p>
]]></content>
  </entry>
  
</feed>
