<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | 破狼 Blog]]></title>
  <link href="http://greengerong.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2014-11-12T15:05:57+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    <email><![CDATA[grzx2210@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[karma作为jQuery单元测试Runner]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/03/karma-for-jquery-unit-test/"/>
    <updated>2014-09-03T22:27:20+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/03/karma-for-jquery-unit-test</id>
    <content type="html"><![CDATA[<p>karma作为angular测试runner出现，如果你使用过karma一定感受到这很不错的javascript测试runner。简单干净的配置文件karma.config.js，以及karma init一些快捷的配置command。以及整套测试套件，如html2js,coverage。对于angular单元测试karma就是一个全生态的测试套件，能够简洁快速的搭建整个测试流程。</p>

<p>本文将尝试运用karma作为jQuery单元测试runner。对于jQuery这种DOM操作的框架，有时难于分离view逻辑，以及ajax这种外部资源的mock，所以比较难于实施对jQuery程序的TDD开发。</p>

<h4>jasmime测试套件</h4>

<p>对于jasmine测试框架为了解决这些问题有两个插件jasmine-jquery和jasmine-ajax。</p>

<h4>jasmine-jquery</h4>

<p>jasmine-jQuery主要解决加载测试所需的DOM元素，为单元测试构建前置环境。jasmine-jQuery加载DOM方法：</p>

<pre><code>jasmine.getFixtures().fixturesPath = 'base path';
loadFixtures('myfixture.html');
jasmine.getFixtures().load(...);
</code></pre>

<p>这里的loadFixtures需要真实ajax获取html fixtures所以我们需要提前host html fixtures。jasmine-jQuery还框架了一些有用的matchers，如toBeChecked， toBeDisabled， toBeFocused，toBeInDOM&hellip;&hellip;</p>

<h4>jasmine-ajax</h4>

<p>jasmine-ajax则是对于一般ajax测试的mock框架，其从底层xmlhttprequest实施mock。所以让我们能偶很容易实施对于jQuery的$.ajax,$.get&hellip;mock。如</p>

<pre><code> beforeEach(function() {
    jasmine.Ajax.requests.when = function (url) {
      return this.filter("/jquery/ajax")[0];
    };
    jasmine.Ajax.install();
});

it("jquery ajax success with getResponse", function() {
    var result;

    $.get("/jquery/ajax").success(function(data) {
        result = data;
    });

    jasmine.Ajax.requests.when("/jquery/ajax").response({
      "status": 200,
      "contentType": 'text/plain',
      "responseText": 'data from mock ajax'
    });

    expect(result).toEqual('data from mock ajax');
});


afterEach(function() {
    jasmine.Ajax.uninstall();
});
</code></pre>

<p>对于jasmine-ajax是实施mock之前一定需要jasmine.Ajax.install()，以及测试完成后需要jasmine.Ajax.uninstall();jasmine-ajax在install后会把所有的ajax mock掉，所以如果有需要真实ajax的需要在install之前完成，如jasmine-jQuery加载view loadFixtures。</p>

<h4>运用karma runner</h4>

<p>我们已经了解了jasmine测试的两个框架jasmine-jQuery和jasmine-ajax，所以运用karma作为runner，我们需要解决的问题就是把他们和karma集成在一起。</p>

<p>所以分为以下几步：
1：karma中引入jasmine-jQuery和jasmine-ajax(可以利用bowerinstall)
2：host 测试的html fixtures。
3：加载html fixtures 与install ajax之前。</p>

<p>对于host 文件karma提供了pattern模式，所以karma配置为：</p>

<pre><code>files: [
    {
      pattern: 'view/**/*.html',
      watched: true,
      included: false,
      served: true
    },
    'bower_components/jquery/dist/jquery.js',
    'bower_components/jasmine-jquery/lib/jasmine-jquery.js',
    'bower_components/jasmine-ajax/lib/mock-ajax.js',
    'src/*.js',
    'test/*.js'
],
</code></pre>

<p>这里需要注意karma自带的jasmine是低版本的，所以我们需要npm install karma-jasmine@2.0获取最新的karma-jasmine插件。</p>

<p>我们就可以完成了karma的配置，我们可以简单测试我们的配置：<a href="https://github.com/greengerong/karma-jasmine-jquery/">demo on github</a>.</p>

<p>测试html fixtures加载：</p>

<pre><code>describe('console html content', function() {

  beforeEach(function() {
    jasmine.getFixtures().fixturesPath = 'base/view/';
    loadFixtures("index.html");
  });

  it('index html', function() {
    expect($("h2")).toBeInDOM();
    expect($("h2")).toContainText("this is index page");
  });

})
</code></pre>

<p>测试mock ajax：</p>

<pre><code>describe('console html content', function() {

  beforeEach(function() {
     jasmine.Ajax.requests.when = function(url) {
         return this.filter("/jquery/ajax")[0];
     };
     jasmine.Ajax.install();
 });


  it('index html', function() {
    expect($("h2")).toBeInDOM();
    expect($("h2")).toContainText("this is index page");
  });

  it("ajax mock", function() {
    var doneFn = jasmine.createSpy("success");

    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function(args) {
      if (this.readyState == this.DONE) {
        doneFn(this.responseText);
      }
    };

    xhr.open("GET", "/some/cool/url");
    xhr.send();

    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/some/cool/url');
    expect(doneFn).not.toHaveBeenCalled();

    jasmine.Ajax.requests.mostRecent().response({
      "status": 200,
      "contentType": 'text/plain',
      "responseText": 'awesome response'
    });

    expect(doneFn).toHaveBeenCalledWith('awesome response');
  });

  it("jquery ajax success with getResponse", function() {
    var result;
    getResponse().then(function(data){
      result = data;
    });

    jasmine.Ajax.requests.when("/jquery/ajax").response({
      "status": 200,
      "contentType": 'text/plain',
      "responseText": 'data from mock ajax'
    });

    expect(result).toEqual('data from mock ajax');
  });

  it("jquery ajax error", function() {
    var status;
    $.get("/jquery/ajax").error(function(response) {
      status = response.status;
    });

    jasmine.Ajax.requests.when("/jquery/ajax").response({
      "status": 400
    });

    expect(status).toEqual(400);
  });

  afterEach(function() {
    jasmine.Ajax.uninstall();
  });
})      
</code></pre>

<p>更多请参见<a href="https://github.com/greengerong/karma-jasmine-jquery/">demo on github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[angularjs之browserTrigger]]></title>
    <link href="http://greengerong.github.io/blog/2014/06/24/angularjs-browsertrigger/"/>
    <updated>2014-06-24T20:42:33+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/06/24/angularjs-browsertrigger</id>
    <content type="html"><![CDATA[<p>今天推荐一款来自angularjs源码的单元测试辅助库browserTrigger，这是来自于ngScenario的一段代码。主要用户触发浏览器型行为更新ng中scope view model的值。</p>

<p>这是angularjs源码中单元测试的使用browserTrigger的实例：</p>

<pre><code>it('should set the model to empty string when empty option is selected', function() {
    scope.robot = 'x';
    compile('&lt;select ng-model="robot"&gt;' +
              '&lt;option value=""&gt;--select--&lt;/option&gt;' +
              '&lt;option value="x"&gt;robot x&lt;/option&gt;' +
              '&lt;option value="y"&gt;robot y&lt;/option&gt;' +
            '&lt;/select&gt;');
    expect(element).toEqualSelect('', ['x'], 'y');

    browserTrigger(element.find('option').eq(0));
    expect(element).toEqualSelect([''], 'x', 'y');
    expect(scope.robot).toBe('');
  });
</code></pre>

<p>在这段代码中给browserTrigger传入你希望选择的select option，则它会帮助你tigger change，选中当前option，更触发更新ng select的viewmodel。</p>

<p>在browserTrigger中还为我们做了很多其他输入框或者html控件的触发接口，同时也加入了浏览器的兼容性。使得我们的测试更加方便不用考虑浏览器兼容性或者不同的html控件trigger不同的事件去更新scope的值。</p>

<p>具体更多信息请参考<a href="https://github.com/angular/angular.js/blob/accd35b7471bbf58cd5b569a004824fa60fa640a/test/ng/directive/selectSpec.js">ng的官方测试</a>和<a href="https://raw.githubusercontent.com/angular/angular.js/dafb8a3cd12e7c3247838f536c25eb796331658d/src/ngScenario/browserTrigger.js">browserTrigger源码</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ng-template寄宿方式]]></title>
    <link href="http://greengerong.github.io/blog/2014/03/15/ng-html2js-maven-plugins-for-java/"/>
    <updated>2014-03-15T13:14:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/03/15/ng-html2js-maven-plugins-for-java</id>
    <content type="html"><![CDATA[<p>如果你是一个angular的开发者的话，对于ng-html2js你应该
很熟悉。对于angular的指令，我们经常需要定义模板(
directive template/templateUrl),你可以选择讲html page
放在真正的的web容器中寄宿，也可以选择angular的ng-template
放在view的page之上，抑或也可以讲html打成一个js文件和directive
的js文件合并在一起发布。</p>

<ul>
<li><p>对于直接寄宿在web容器.</p>

<p>这很简单，直接放在jetty，tomcat，iis，
抑或node express public目录下。这里没什么可以多说的，所以我们跳过。</p></li>
<li><p>angular ng-template模板:</p>

<p>代码如下：</p>

<pre><code>    &lt;script type="text/ng-template" id="/tpl.html"&gt;

      Content of the template.

    &lt;/script&gt;
</code></pre>

<p>这将会在angular的compile时候解析，angular将会把它放在angular的$templateCache
中。</p>

<p>对于<a href="http://docs.angularjs.org/api/ng/service/$templateCache">$templateCache</a>，如其名
这是angular对模板的缓存的service。在启用了$templateCache的$http ajax请求，
angular将会首先在$templateCache中查找是否有对此url的缓存：</p>

<pre><code>      $templateCache.get('templateId.html')
</code></pre>

<p>如果存在缓存，着angular将会直接用缓存中获取，并不会在发送一次ajax。
对于所有的指令和模板angular默认启用了templateCache。</p>

<p>这在于angular所处理的模式开发很有关系的。我们经常提到的SPA(single page application)
我们把view的显示处理等表现逻辑推到了前段，而后端提供只与数据有关的soap/restful service
这样对于一个应用程序业务逻辑来说不变的是处理数据的业务逻辑，这份逻辑你可以共享在不管前端是mobile
app 或者是浏览器，或者winform gui的图形化程序，因为对于同一个业务这是不变的。将view的分离推到各自的客户端
将是更好的解决方案。</p>

<p>回到angular $templateCahce，对于一个应用程序view的分离，之后在对于当前的应用程序平台，html/js/css
这类资源是静态的，最好是不变的，那么你可以自由的缓存在客户端，减少服务器的交互，以及为了更大的性能追求，我们
可以把这类静态资源放在Nginx这里反向代理或者CDN上，让我们的程序获取更大的性能和扩展空间。</p></li>
<li><p>回到angular的ng-html2js：</p>

<p>有了上边对于$templateCache的理解，那你应该很容易理解html2js的方式了，与ng-template不同的
是ng-template是angular在compile的时候自动加入$templateCache的，html2js是我们在开发
时候利用build自己放入$templateCache。</p>

<pre><code>  angular.module('myApp', [])
  .run(function($templateCache) {
      $templateCache.put('templateId.html',
          'This is the content of the template'
      );
  });
</code></pre></li>
</ul>


<p>形如上面的输出，将html文件打成一个js文件。</p>

<p>这你也许在angular的单元测试karma unit test中看见过，<a href="https://github.com/karma-runner/karma-ng-html2js-preprocessor"> karma-ng-html2js-preprocessor</a>
，还有如果你也希望在build时候做到如此，那么你可以使用grunt plugin <a href="https://github.com/karlgoldstein/grunt-html2js"> grunt-html2js</a>.</p>

<p>但使用grunt plugin的前提是你在你的项目中引入的grunt build的work flow，那么你可以在gruntfile.js中几行代码轻松的搞定。但是如果
你和我一样使用的是java的maven或者是gradle 作为build，那么你可以尝试博主的maven plugin<a href="https://github.com/greengerong/nghtml2js">nghtml2js</a>.
使用方式如下：</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.greengerong&lt;/groupId&gt;
    &lt;artifactId&gt;nghtml2js&lt;/artifactId&gt;
    &lt;version&gt;0.0.3&lt;/version&gt;
    &lt;configuration&gt;
        &lt;module&gt;demo.template&lt;/module&gt;
        &lt;html&gt;${project.basedir}&lt;/html&gt;
        &lt;extensions&gt;
            &lt;param&gt;tpl&lt;/param&gt;
            &lt;param&gt;html&lt;/param&gt;
        &lt;/extensions&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;nghtml2js&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;run&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
]]></content>
  </entry>
  
</feed>
