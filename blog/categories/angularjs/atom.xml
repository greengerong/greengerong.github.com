<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Angularjs | 破狼 Blog]]></title>
  <link href="http://greengerong.github.io/blog/categories/angularjs/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2013-12-27T23:04:02+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Angular Controller as Syntax vs Scope]]></title>
    <link href="http://greengerong.github.io/blog/2013/12/24/angular-controller-as-syntax-vs-scope/"/>
    <updated>2013-12-24T00:00:00+08:00</updated>
    <id>http://greengerong.github.io/blog/2013/12/24/angular-controller-as-syntax-vs-scope</id>
    <content type="html"><![CDATA[<p>今天要和大家分享的是angular从1.2版本开始带来了新语法Controller as。再次之前我们对于angular在view上的绑定都必须使用直接的scope对象，对于controller来说我们也得必须注入$scope这个service。如下：</p>

<pre><code>angular.module("app",[])
.controller("demoController",["$scope",function($scope){
    $scope.title = "angualr";
 }])

&lt;div ng-app="app" ng-controller="demoController"&gt;
    hello : {{title}} !
&lt;/div&gt;
</code></pre>

<p>有些人觉得即使这样我们的controller还是不够POJO，以及对于coffescript爱好者不足够友好，所以在angular在1.2给我带来了一个新的语法糖这就是本文将要说的controller as的语法糖，修改上面的demo将会变成：</p>

<pre><code>angular.module("app",[])
.controller("demoController",[function(){
    this.title = "angualr";
}])

&lt;div ng-app="app" ng-controller="demoController as demo"&gt;
     hello : {{demo.title}} !
&lt;/div&gt;
</code></pre>

<p>这里我们可以看见现在controller不再有$scope的注入了，感觉controller就是一个很简单的平面的JavaScript对象了，不存在任何的差别了。再则就是view上多增加了个demoController as demo，给controller起了一个别名，在此后的view模板中靠这个别名来访问数据对象。</p>

<p>或许看到这里你会问为什么需要如此啊，不就是个语法糖而已，先别着急，我们会在后边分析$scope和他的差别。在此之前我们先来看看angular源码的实现这样才会有助于我们的分析：</p>

<p>下面是一段来自angular的code：在1499行开始(行数只能保证在写作的时候有效)</p>

<pre><code>  if (directive.controllerAs) {
          locals.$scope[directive.controllerAs] = controllerInstance;
   }
</code></pre>

<p>如果你希望看更完全的code请猛击这里<a href="https://github.com/angular/angular.js/blob/c7a1d1ab0b663edffc1ac7b54deea847e372468d/src/ng/compile.js">https://github.com/angular/angular.js/blob/c7a1d1ab0b663edffc1ac7b54deea847e372468d/src/ng/compile.js</a>.</p>

<p>从上面的代码我们能看见的是：angular只是把controller这个对象实例以其as的别名在scope上创建了一个新的对象属性。靠，就这么一行代码搞定！</p>

<p>先别急，既然是语法糖，那么它肯定有他出现的原因，让我们来和直接用$scope对比下：</p>

<p>在此文之前我在angularjs的群中和大家讨论了下我的看法，得到大家不错的反馈，所以有了本文，记录和分享下来。</p>

<p>我规定对于controller as的写法如下：</p>

<pre><code>angular.module("app",[])
 .controller("demoController",[function(){
        var vm = this;

        vm.title = "angualr";

        return vm;
 }])
</code></pre>

<p>其优势为：</p>

<ol>
<li>定义vm这样会让我们更好的避免JavaScript的this的坑。</li>
<li>如果某个版本的angular不再支持controller as,可以轻易的注入$scope,修改为 var vm = $scope;</li>
<li>因为不再注入$scope了，controller更加的POJO，就是一个很普通的JavaScript对象。</li>
<li>也因为没有了$scope，而controller实例将会成为scope上的一个属性，所以在controller中我们再也不能使用$watch,$emit,$on之类的特殊方法，因为这些东西往往不该出现在controller中的，给大家一个警告，更好的控制。但是一旦如果没办法必须用的话，可以在征得项目组一致同意，将此controller退回$scope.</li>
<li>因为controller实例将会只是$scope的一个属性，所以view模板上的所有字段都会在一个引用的属性上，这可以避开JavaScript原型链继承对于值类型的坑。参加<a href="https://github.com/angular/angular.js/wiki/Understanding-Scopes">https://github.com/angular/angular.js/wiki/Understanding-Scopes</a>.</li>
<li>controller as 对于 coffescript,liveScript更友好。
7.模板上定义的每个字段方法都会在scope寄存在controller as别名上的引用上，所以在controller继承中，不会在出现命名冲突的问题。</li>
</ol>


<p>注释:对于route，也有个controllerAs的属性可以设置，下面代码来之angular doc文档：</p>

<pre><code>    angular.module('ngViewExample', ['ngRoute', 'ngAnimate'],
     function($routeProvider, $locationProvider) {
    $routeProvider.when('/Book/:bookId', {
      templateUrl: 'book.html',
      controller: BookCntl,
      controllerAs: 'book'
    });
    $routeProvider.when('/Book/:bookId/ch/:chapterId', {
      templateUrl: 'chapter.html',
      controller: ChapterCntl,
      controllerAs: 'chapter'
    });

    // configure html5 to get links working on jsfiddle
         $locationProvider.html5Mode(true);
     });
</code></pre>

<p>今天就到这里，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angularjs组件之input Mask]]></title>
    <link href="http://greengerong.github.io/blog/2013/12/15/jqueryinputmarsk4angular/"/>
    <updated>2013-12-15T00:00:00+08:00</updated>
    <id>http://greengerong.github.io/blog/2013/12/15/jqueryinputmarsk4angular</id>
    <content type="html"><![CDATA[<p>今天将奉献一个在在几个angularjs项目中抽离的angular组件 input mask。在我们开发中经常会对用户的输入进行控制，比如日期，货币格式，或者纯数字格式之类的限制，这就是input mask的使用场景，在项目中也是会经常被提及需的需求之一。</p>

<p>当然在官方的angular-ui ui-utils中有一个相应的组件叫做ui-mask，但是其mask功能是很初级脆弱的。所以我希望能得到一个更强大的mask组件。我所知的<a href="https://github.com/RobinHerbots/jquery.inputmask">jquery.inputmask</a>就是这样一个我所期望的强大的mask组件，所以我不必再去重造轮子，好的软件就是为了不停被重复利用。所以写了一个adapter，<a href="https://github.com/greengerong/green.inputmask4angular">https://github.com/greengerong/green.inputmask4angular</a>.</p>

<p>其使用如下，可以去下载项目查看其中的demo page。</p>

<pre><code>&lt;div class="hero-unit"&gt;
                &lt;h1&gt;'Allo, 'Allo!&lt;/h1&gt;

                &lt;div&gt;
                    &lt;h3&gt;mask&lt;/h3&gt;
                    &lt;p&gt;Mask: 99-9999999&lt;/p&gt;
                    &lt;input type="text" ng-model="test" input-mask="'mask'" mask-option="testoption"/&gt;
                    &lt;pre&gt;{{ test | json }}&lt;/pre&gt;
                &lt;/div&gt;

                &lt;div&gt;
                    &lt;h3&gt;y-m-d&lt;/h3&gt;
                    &lt;p&gt;Date: yyyy-MM-dd&lt;/p&gt;
                    &lt;input type="text" ng-model="test1" input-mask="'y-m-d'" format-option="dateFormatOption"/&gt;
                    &lt;pre&gt;{{ test1 | json }}&lt;/pre&gt;
                &lt;/div&gt;


                &lt;div&gt;
                    &lt;h3&gt;Regex&lt;/h3&gt;
                    &lt;p&gt;Email: "[a-zA-Z0-9._%-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,4}"&lt;/p&gt;
                    &lt;input type="text" ng-model="test3" input-mask="'Regex'"
                     mask-option="regexOption"/&gt;
                    &lt;pre&gt;{{ test3 | json }}&lt;/pre&gt;
                &lt;/div&gt;

                &lt;div&gt;
                    &lt;h3&gt;Function&lt;/h3&gt;
                    &lt;p&gt;"[1-]AAA-999" or  "[1-]999-AAA"&lt;/p&gt;
                    &lt;input type="text" ng-model="test4" input-mask="functionOption"/&gt;
                    &lt;pre&gt;{{ test4 | json }}&lt;/pre&gt;
                &lt;/div&gt;

            &lt;/div&gt;
</code></pre>

<p> controller code:</p>

<pre><code>'use strict';

    angular.module('green.inputmaskApp')
        .controller('MainCtrl', ["$scope", function ($scope) {

            $scope.testoption = {
                "mask": "99-9999999",
                "oncomplete": function () {
                    console.log();
                    console.log(arguments,"oncomplete!this log form controler");
                },
                "onKeyValidation": function () {
                    console.log("onKeyValidation event happend! this log form controler");
                }
            }

            //default value
            $scope.test1 = new Date();

            $scope.dateFormatOption = {
                parser: function (viewValue) {
                    return viewValue ? new Date(viewValue) : undefined;
                },
                formatter: function (modelValue) {
                    if (!modelValue) {
                        return "";
                    }
                    var date = new Date(modelValue);
                    return (date.getFullYear() + "-" + date.getMonth() + "-" + date.getDate()).replace(/\b(\d)\b/g, "0$1");
                },
                isEmpty: function (modelValue) {
                    return !modelValue;
                }
            };


            $scope.mask = { regex: ["999.999", "aa-aa-aa"]};


            $scope.regexOption = {
                regex: "[a-zA-Z0-9._%-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,4}"
            };

            $scope.functionOption = {
             mask: function () { 
                return ["[1-]AAA-999", "[1-]999-AAA"]; 
            }};


        }]);
</code></pre>

<p>这里值列列举了jquery.inputmask的简单实用方式，更复杂的方式请移步到jquery.inputmask查看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web组件化-angularjs实践]]></title>
    <link href="http://greengerong.github.io/blog/2013/12/11/angularjs-web-component/"/>
    <updated>2013-12-11T00:00:00+08:00</updated>
    <id>http://greengerong.github.io/blog/2013/12/11/angularjs-web-component</id>
    <content type="html"><![CDATA[<p>在过去的web标准经历了一个飞速的发展，随着时间的推移，用户对web的体验也越来越重视，从最初的简单静态页面到以ajax标志的web2.0，在这个时代我们所面临的问题是用户的体验和可恶的浏览器的兼容(IE成为了我们所唾弃的产物，IE6的葬礼之类的形式足以表明这点)，所以有了Prototype，Mootools，jQuery这类浏览器兼容和util的库，特别jQuery的出现以其独特的兼容性，一致性和优雅的选择器和链式风格影响了整个业界的发展,作为这个时代的产物jQuery是个很出色的库，正的如它所说，做到了"write less，do more",成为这个时代的标志。然而随着互联网的突增，我们的JavaScript代码量也暴增，是的我们再度陷入到JavaScript的维护管理的困境。JavaScript本来是一门作为浏览器上的脚本语言出身，并不适合于大规模开发。所以在我们所能看见的MDV框架的出现，这个时候前段的JavaScript代码已得到我们越来越注重，MDV框架提出了我们也需要向对待后端系统(spring,web api)一样对前段逻辑进行统一管理，分层(表现逻辑，viewmodel，视图)。所以Backbone，AngularJS，Ember，Spine之类的数据绑定框架横空出世，力求给我们带来代码的模块管理，数据、视图的分离，他们以他们不同的方式解决共同的问题：</p>

<p>1.如何更好地模块化开发</p>

<p>2.业务数据如何组织</p>

<p>3.界面和业务数据，业务逻辑的分离</p>

<p>与此同时其实用户体验的要求html5，ECMAScript也在快速的推进。在这里我想说的是 Web组件化的也在蓬勃的发展起来，以Google额polymer为代表的框架，库也在悄无声息的到来，虽然这需要等到浏览器的大统一，但是我们相信在不久的将来将会到来。在这里我所激动和希望是组件的共享，假设我们能够一个想java maven repo，cdn之类的共有或者私有repo，在你需要的地方只需要import那将是多么美好的事情，这也许是意淫，但也未必不可。</p>

<p>有希望总是好的，在过去一年我所尝试的就是基于angular这优秀的框架directive dsl和maven build去实现我所期望的组件化共享愿景。在基于node的<a href="http://component.io/">component</a>前端管理框架稍有相似之处。</p>

<p>回到正题，在angularjs中如何去做到组件化：</p>

<p><img src="/images/blog_img/web-angular.jpg" alt="/images/blog_img/web-angular.jpg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angularjs位于ng-switch中的ng-option,当select option改变了在IE上不会重新渲染 Issue解决方案]]></title>
    <link href="http://greengerong.github.io/blog/2013/12/08/angualr-ie-select-do-not-render-when-option-change/"/>
    <updated>2013-12-08T00:00:00+08:00</updated>
    <id>http://greengerong.github.io/blog/2013/12/08/angualr-ie-select-do-not-render-when-option-change</id>
    <content type="html"><![CDATA[<p>最近遇见angularjs 在IE上当使用ng-options作为select的选项数据源，并且被套在ng-switch（ng-transclude）之类的，当angular上得ng-options数据源model改变后，在IE上并不渲染。</p>

<p>在一阵的测试和阅读相关文档后最后确认为：因为ng-switch（ng-transclude）是为了使其scope为原来的父scope，在父scope上生成了DOM后才克隆(cloneNode)到指定的指令位置。然而IE在对于select克隆的节点，不会主动去触发重绘，所以才有了上面的issue。</p>

<p>问题确定了，那我们所需要做的就是手动的去触发让IE对Select重绘，尝试了很多办法后最终确认有效的是：首先在options上用原生js去添加一个option，在马上移除掉这个option，所以解决方案如下：</p>

<pre><code>angular.module('ie.select', [])
.directive('ieSelectFix', [
    function () {
        return {
            restrict: 'A',
            require: 'select',
            link: function (scope, element, attributes) {
                var isIE = document.attachEvent;
                if (!isIE) return;

                var control = element[0];
                scope.$watch(attributes.ieSelectFix, function () {
                    //it should be use javascript way, not jquery way.
                    var option = document.createElement("option");
                    control.add(option, null);
                    control.remove(control.options.length - 1);
                });
            }
        }
    }
]);
</code></pre>

<p>使用方式如下：</p>

<pre><code>&lt;select ie-select-fix="options" ng-model="demos" class="form-control"
        ng-options="currOption.value as currOption.text for currOption in options"&gt;
    &lt;option value="" default&gt;Select&lt;/option&gt;
&lt;/select&gt;
</code></pre>

<p>我也在我的github专门创建了一个针对angularjs在IE上issue的项目，收录了这个指令，在后续也会加入我所遇见的angularjs关于ie的issue，也希望大家帮助完善这个项目，让我们的angularjs程序在IE工作的更美好，让我们这些辛苦的程序猿也少一点加班时间，多一点陪家人，泡咖啡的时间。哈哈。</p>

<p>github项目地址：<a href="https://github.com/greengerong/angular-ie-enhancer">https://github.com/greengerong/angular-ie-enhancer</a></p>
]]></content>
  </entry>
  
</feed>
