<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Angular | 破狼 Blog]]></title>
  <link href="http://greengerong.github.io/blog/categories/angular/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2014-11-13T21:29:58+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    <email><![CDATA[grzx2210@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解决ng界面长表达式(ui-set)]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/29/ng-ui-set-for-long-expression/"/>
    <updated>2014-09-29T16:52:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/29/ng-ui-set-for-long-expression</id>
    <content type="html"><![CDATA[<p>本文来自网友sun shine的问题，问题如下：</p>

<pre><code>    您好, 我想求教一个问题.
    在$scope中我的对象名字写的特别深, 在 html中我又多次用到了同一个对象, 对不对在 html中让它绑定到一个临时变量呢?
    比如:
    $scope.this.is.a.very.deep.obj = {
    'name': 'xxx',
    'state': 'active'};

    在 模板中,

    {{this.is.a.very.deep.obj.name}}
    {{this.is.a.very.deep.obj.state}}
    类似于这种, 我能否把 this.is.a.very.deep.obj 预先赋给一个临时的变量, 然后在 两个 span中只需 o.name, o.state 就行了呢? 我觉得这样解析起来是不是快一点.

    但是我试了, 并没有成功. 求指点.
    先谢了.
</code></pre>

<p>在这里首先需要说明的是ng界面的所有引用都需要在$scope这个viewmodel(ui和view的胶水层)，所以如果我们希望能够把表达式变得更可读，更友好，那么我们就必须在$scope上创建这个变量。</p>

<p>再则对于ng其使用使用的一堆的$watch，实现脏检查，如果你理解这些了，那么我们就可以很容易的实现一套如spring的</p>

<pre><code>&lt;c:set var="xxx" expression="xxx" /&gt;
</code></pre>

<p>的tag.</p>

<p>对于实现这类tag，我们最好的方式则是利用ng的directive来实现，代码如下：</p>

<pre><code>        angular.module("greengerong.ui.tag", [])
          .directive("uiSet", [
            function() {
              return {
                restrict: "EA",
                link: function(scope, elm, iAttrs) {
                  scope.$watch(iAttrs.expression, function(val) {
                    scope[iAttrs.
                      var] = val;
                    var apply = !scope.$$phase ? scope.$apply : angular.noop;
                    apply();
                  });
                }
              };
            }
          ]);
</code></pre>

<p>demo效果请移步<a href="http://jsbin.com/neqow/3/edit">jsbin demo</a>;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jasmine测试ng Promises - Provide and Spy]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/29/testing-promises-with-jasmine-provide-and-spy/"/>
    <updated>2014-09-29T15:53:45+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/29/testing-promises-with-jasmine-provide-and-spy</id>
    <content type="html"><![CDATA[<p>jasmine提供了很多些很实用的处理Promises的方法，首先我们来考虑下面的这个例子：</p>

<pre><code>    angular.module("myApp.store").controller("StoresCtrl", function($scope, StoreService, Contact) {
      StoreService.listStores().then(function(branches) {
        Contact.retrieveContactInfo().then(function(userInfo) {
            //more code here crossing user and stores data
        });  
      });
    });
</code></pre>

<p>下面让我们来尝试如何用angular提供的$provide创建一个依赖的实现，以及利用jasmine帮助我们fake方法的返回值：</p>

<p>代码如下，有详细注释帮助你去理解这段代码：</p>

<pre><code>    describe("Store Controller", function() {
      var $controller, Contact, StoreService, createController, scope;

      beforeEach(function() {
        module('myApp.store');

        // Provide will help us create fake implementations for our dependencies
        module(function($provide) {

          // Fake StoreService Implementation returning a promise
          $provide.value('StoreService', {
            listStores: function() {
              return { 
                then: function(callback) {return callback([{ some: "thing", hoursInfo: {isOpen: true}}]);}
              };
            },
            chooseStore: function() { return null;}
          });

          // Fake Contact Implementation return an empty object 
          $provide.value('Contact', {
            retrieveContactInfo: function() {
              return {
                then: function(callback) { return callback({});}
              };
            }
          });

          return null;
        });
      });

      beforeEach(function() {

        // When Angular Injects the StoreService and Contact dependencies, 
        // it will use the implementation we provided above
        inject(function($controller, $rootScope, _StoreService_, _Contact_) {
          scope = $rootScope.$new();
          StoreService = _StoreService_;
          Contact = _Contact_;
          createController = function(params) {
            return $controller("StoresCtrl", {
              $scope: scope,
              $stateParams: params || {}
            });
          };
        });
      });

      it("should call the store service to retrieve the store list", function() {
        var user = { address: {street: 1}};

        // Jasmine spy over the listStores service. 
        // Since we provided a fake response already we can just call through. 
        spyOn(StoreService, 'listStores').and.callThrough();

        // Jasmine spy also allows to call Fake implementations via the callFake function 
        // or we can return our own response via 'and.returnValue
        // Here we can override the response we previously defined and return a promise with a user object
        spyOn(Contact, 'retrieveContactInfo').and.callFake(function() {
          return {
            then: function(callback) { return callback(user); }
          };
        });

        createController();
        // Since we setup a spy we can now expect that spied function to have been called 
        // or to have been called with certain parameters..etc
        expect(StoreService.listStores).toHaveBeenCalled();
      });
    });
</code></pre>

<p>原文地址:<a href="http://ng-learn.org/2014/08/Testing_Promises_with_Jasmine_Provide_Spy/">Testing Promises with Jasmine &ndash; Provide and Spy</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ng Http Request/response格式转换]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/02/ng-http-transformrequest/"/>
    <updated>2014-09-02T22:59:05+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/02/ng-http-transformrequest</id>
    <content type="html"><![CDATA[<p>angular作为Single Page Application推荐的交互方式当然是基于json的ajax调用。但今天要说的是当你不幸工作在一个遗留或者不可控制的服务上，而这服务是基于非json提交方式(或许是常规表单(form)提交，或者其他自定义数据格式)，那么我们只能改变ng内部$http默认request/response格式转化方式。</p>

<p>所幸的是ng $http给我们提供了多种可用方式转化数据格式(下面demo将以form提交方式为例):</p>

<p>***对于部分单独的http request设置：</p>

<p>对于http ajax方式最后一个参数都是关于http的配置信息，其中包括一项transformRequest，我们可以利用transformRequest在ajax发送数据之前改变数据的格式，例如下边的demo:</p>

<pre><code>$http.post("/url", {
      id: 1,
      name: "greengerong"
    }, {
      transformRequest: function(request) {
        return $.param(request);
    }
});
</code></pre>

<p>这里利用jQuery的$.param进行表单提交方式的格式转化，所以我们能够看见的request body 为：</p>

<pre><code>id=1&amp;name=greengerong
</code></pre>

<p>online <a href="http://plnkr.co/edit/hxAb2V">demo</a>;</p>

<p>***对于整个app的http request设置：</p>

<p>如果我们需要对整个http的数据转化格式进行设置，那么可以选用在config阶段对$httpProvider默认行为进行设置：</p>

<pre><code>angular.module("app", [])
.config(["$httpProvider", function($httpProvider) {
      $httpProvider.defaults.transformRequest = [
        function(request) {
          return $.param(request);
        }
      ];
    }
]);
</code></pre>

<p>这样我们就可以轻易的转化为form提交方式。</p>

<p>同样$http也为我们提供了transformResponse方式，我们也可以创建自己的response转化，比如json之前加入自定义前缀防止json array攻击等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ng-template寄宿方式]]></title>
    <link href="http://greengerong.github.io/blog/2014/03/15/ng-html2js-maven-plugins-for-java/"/>
    <updated>2014-03-15T13:14:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/03/15/ng-html2js-maven-plugins-for-java</id>
    <content type="html"><![CDATA[<p>如果你是一个angular的开发者的话，对于ng-html2js你应该
很熟悉。对于angular的指令，我们经常需要定义模板(
directive template/templateUrl),你可以选择讲html page
放在真正的的web容器中寄宿，也可以选择angular的ng-template
放在view的page之上，抑或也可以讲html打成一个js文件和directive
的js文件合并在一起发布。</p>

<ul>
<li><p>对于直接寄宿在web容器.</p>

<p>这很简单，直接放在jetty，tomcat，iis，
抑或node express public目录下。这里没什么可以多说的，所以我们跳过。</p></li>
<li><p>angular ng-template模板:</p>

<p>代码如下：</p>

<pre><code>    &lt;script type="text/ng-template" id="/tpl.html"&gt;

      Content of the template.

    &lt;/script&gt;
</code></pre>

<p>这将会在angular的compile时候解析，angular将会把它放在angular的$templateCache
中。</p>

<p>对于<a href="http://docs.angularjs.org/api/ng/service/$templateCache">$templateCache</a>，如其名
这是angular对模板的缓存的service。在启用了$templateCache的$http ajax请求，
angular将会首先在$templateCache中查找是否有对此url的缓存：</p>

<pre><code>      $templateCache.get('templateId.html')
</code></pre>

<p>如果存在缓存，着angular将会直接用缓存中获取，并不会在发送一次ajax。
对于所有的指令和模板angular默认启用了templateCache。</p>

<p>这在于angular所处理的模式开发很有关系的。我们经常提到的SPA(single page application)
我们把view的显示处理等表现逻辑推到了前段，而后端提供只与数据有关的soap/restful service
这样对于一个应用程序业务逻辑来说不变的是处理数据的业务逻辑，这份逻辑你可以共享在不管前端是mobile
app 或者是浏览器，或者winform gui的图形化程序，因为对于同一个业务这是不变的。将view的分离推到各自的客户端
将是更好的解决方案。</p>

<p>回到angular $templateCahce，对于一个应用程序view的分离，之后在对于当前的应用程序平台，html/js/css
这类资源是静态的，最好是不变的，那么你可以自由的缓存在客户端，减少服务器的交互，以及为了更大的性能追求，我们
可以把这类静态资源放在Nginx这里反向代理或者CDN上，让我们的程序获取更大的性能和扩展空间。</p></li>
<li><p>回到angular的ng-html2js：</p>

<p>有了上边对于$templateCache的理解，那你应该很容易理解html2js的方式了，与ng-template不同的
是ng-template是angular在compile的时候自动加入$templateCache的，html2js是我们在开发
时候利用build自己放入$templateCache。</p>

<pre><code>  angular.module('myApp', [])
  .run(function($templateCache) {
      $templateCache.put('templateId.html',
          'This is the content of the template'
      );
  });
</code></pre></li>
</ul>


<p>形如上面的输出，将html文件打成一个js文件。</p>

<p>这你也许在angular的单元测试karma unit test中看见过，<a href="https://github.com/karma-runner/karma-ng-html2js-preprocessor"> karma-ng-html2js-preprocessor</a>
，还有如果你也希望在build时候做到如此，那么你可以使用grunt plugin <a href="https://github.com/karlgoldstein/grunt-html2js"> grunt-html2js</a>.</p>

<p>但使用grunt plugin的前提是你在你的项目中引入的grunt build的work flow，那么你可以在gruntfile.js中几行代码轻松的搞定。但是如果
你和我一样使用的是java的maven或者是gradle 作为build，那么你可以尝试博主的maven plugin<a href="https://github.com/greengerong/nghtml2js">nghtml2js</a>.
使用方式如下：</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.greengerong&lt;/groupId&gt;
    &lt;artifactId&gt;nghtml2js&lt;/artifactId&gt;
    &lt;version&gt;0.0.3&lt;/version&gt;
    &lt;configuration&gt;
        &lt;module&gt;demo.template&lt;/module&gt;
        &lt;html&gt;${project.basedir}&lt;/html&gt;
        &lt;extensions&gt;
            &lt;param&gt;tpl&lt;/param&gt;
            &lt;param&gt;html&lt;/param&gt;
        &lt;/extensions&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;nghtml2js&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;run&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular Ng-model类型格式转化]]></title>
    <link href="http://greengerong.github.io/blog/2013/12/15/angular-model--format/"/>
    <updated>2013-12-15T00:00:00+08:00</updated>
    <id>http://greengerong.github.io/blog/2013/12/15/angular-model--format</id>
    <content type="html"><![CDATA[<p>在angular开发中我们经常会遇见输入框中的string的值，却想在scope上的model表现为整型、浮点、货币，或者在radio的value是一个true,false的Boolean类型，一组check box的vlue组成一个Array的数组类型，因为我们的后台程序的model设计接口如此。你是否还在后台应用程序或者ajax提交前做mapper，还在重复着着伪angular的做法？</p>

<p>在本人github创建了一个开源项目<a href="https://github.com/greengerong/ngmodel-format">https://github.com/greengerong/ngmodel-format</a>,为了让我们能够轻易的对付这些琐事，你可以在demo下得html或者middle way的测试中看见其使用方法，同时如果不满足你的需求，你仍然可以很简单的扩展你需要的功能：你需要的只是在你的module的run阶段注入modelFormatConfig的constant service 加入所需的key值，加上自己的formatter，parser，isEmpty方法，如果你仍然想继续深入的对用户的输入进行一些控制的话，也可以加入keyDown时间去stopPropagation，preventDefault一些key值。</p>

<p>下面我们看看其相应的使用方式：</p>

<p>请移步到<a href="http://jsbin.com/uJUrANa/1/watch?html,js,output">http://jsbin.com/uJUrANa/1/watch?html,js,output</a>，由于嵌入iframe对样式存在影响，所以暂不嵌入</p>

<p>注意由于在jsbin拒绝引入github text/plain的文件 所以这里是直接把源码贴进去了的，如果使用的话最好是使用github上的，这里的代码是不会更新的。</p>

<p>在jsbin demo上你能够很清楚的看见使用方式。那么我就不用在废话多说了，哈哈。有问题可以提交github issue。</p>
]]></content>
  </entry>
  
</feed>
