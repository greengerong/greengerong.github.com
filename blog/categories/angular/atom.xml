<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Angular | 破狼 Blog]]></title>
  <link href="http://greengerong.github.io/blog/categories/angular/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2015-10-19T21:49:49+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    <email><![CDATA[grzx2210@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义Angular插件 - 网站用户引导]]></title>
    <link href="http://greengerong.github.io/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian/"/>
    <updated>2015-10-18T19:47:51+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian</id>
    <content type="html"><![CDATA[<p>最近由于项目进行了较大的改版，为了让用户能够适应这次新的改版，因此在系统中引入了“用户引导”功能，对于初次进入系统的用户一些简单的使用培训training。对于大多数网站来说，这是一个很常见的功能。所以在开发这个任务之前，博主尝试将其抽象化，独立于现有系统的业务逻辑，将其封装为一个通用的插件，使得代码更容易扩展和维护。</p>

<p>无图无真相，先上图：</p>

<p><img src="/images/blog_img/training-demo.png" alt="training demo" /></p>

<p>关于这款trainning插件的使用很简单，它采用了类似Angular路由一样的配置，只需要简单的配置其每一步training信息。</p>

<ul>
<li>title：step的标题信息；</li>
<li>template/templateUrl: step的内容模板信息。这类可以配置html元素，或者是模板的url地址，同时templateUrl也支持Angular route一样的function语法；</li>
<li>controller: step的控制器配置；可注入当前step信息currentStep、所有step的配置trainnings、当前step的配置信息currentTrainning、以及下一步的操作回调trainningInstance（其中nextStep：为下一步的回调，cancel为取消用户引导回调）；</li>
<li>controllerAs: controller的别名；</li>
<li>resolve：在controller初始化前的数据配置，同Angular路由中的resolve；</li>
<li>locals：本地变量，和resolve相似，可以传递到controller中。区别之处在于它不支持function调用，对于常量书写会比resolve更方便；</li>
<li>placement: step容器上三角箭头的显示方位，</li>
<li>position: step容器的具体显示位置，这是一个绝对坐标；可以传递<code>{left: 100, top: 100}</code>的绝对坐标，也可以是<code>#stepPanelHost</code>配置相对于此元素的placement位置。同时它也支持自定义function和注入Angular的其他组件语法。默认会引入所有step配置trainnings变量,当前步骤step，当前step的配置信息currentTrainning，以及step容器节点stepPanel；</li>
<li>backdrop：是否需要显示遮罩层，默认显示，除非显示声明为false配置，则不会显示遮罩层；</li>
<li>stepClass：每一个step容器的样式信息；</li>
<li>backdropClass： 每一个遮罩层的样式信息。</li>
</ul>


<p>了解了这些配置后，并根据特定需求定制化整个用户引导的配置信息后，我们就可以使用trainningService的trainning方法来在特定实际启动用户引导，传入参数为每一步step的配置信息。并可以注册其done或者cancel事件：</p>

<pre><code>trainningService.trainning(trainningCourses.courses)
    .done(function() {
        vm.isDone = true;
    });
</code></pre>

<p>下面是一个演示的配置信息：</p>

<pre><code>    .constant('trainningCourses', {
                courses: [{
                    title: 'Step 1:',
                    templateUrl: 'trainning-content.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    placement: 'left',
                    position: '#blogControl'
                },{
                    title: 'Step 3:',
                    templateUrl: 'trainning-content.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    placement: 'top',
                    position: {
                        top: 200,
                        left: 100
                    }
                },
                    ...
                {
                    stepClass: 'last-step',
                    backdropClass: 'last-backdrop',
                    templateUrl: 'trainning-content-done.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    position: ['$window', 'stepPanel', function($window, stepPanel) {
                        // 自定义函数，使其屏幕居中
                        var win = angular.element($window);
                        return {
                            top: (win.height() - stepPanel.height()) / 2,
                            left: (win.width() - stepPanel.width()) / 2
                        }
                    }]
                }]
            })
</code></pre>

<p>本文插件源码和演示效果唯一codepen上，效果如下：</p>

<p data-height="385" data-theme-id="0" data-slug-hash="pjwXQW" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/pjwXQW/'>ng-trainning</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://greengerong.github.io//assets.codepen.io/assets/embed/ei.js"></script>


<p>在trainning插件的源码设计中，包含如下几个要点：</p>

<ul>
<li>提供service api。因为关于trainning这个插件，它是一个全局的插件，正好在Angular中所有的service也是单例的，所以将用户引导逻辑封装到Angular的service中是一个不错的设计。但对于trainning的每一步展示内容信息则是DOM操作，在Angular的处理中它不该存在于service中，最佳的方式是应该把他封装到Directive中。所以这里采用Directive的定义，并在service中compile，然后append到body中。</li>
<li>对于每一个这类独立的插件应该封装一个独立的scope，这样便于在后续的销毁，以及不会与现有的scope变量的冲突。</li>
<li>$q对延时触发的结果包装。对于像该trainning插件或者modal这类操作结果采用promise的封装，是一个不错的选择。它取代了回调参数的复杂性，并以流畅API的方式展现，更利于代码的可读性。同时也能与其他Angular service统一返回API。</li>
<li>对于controller、controllerAs、resolve、template、templateUrl这类类似路由的处理代码，完全可以移到到你的同类插件中去。它们可以增加插件的更多定制化扩展。关于这部分代码的解释，博主将会在后续文章中为大家推送。</li>
<li>利用$injector.invoke动态注入和调用Angular service，这样既能获取Angular其他service注入的扩展性，也能获取到函数的动态性。如上例中的屏幕居中的自定义扩展方式。</li>
</ul>


<p>这类设计要点，同样可以运用到想modal、alert、overload这类全局插件中。有兴趣的读者，你可以在博主的codepen笔记中阅读这段代码<a href="http://codepen.io/greengerong/pen/pjwXQW#0">http://codepen.io/greengerong/pen/pjwXQW#0</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular遇上CoffeeScript - NgComponent封装]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/"/>
    <updated>2015-09-12T22:09:23+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang</id>
    <content type="html"><![CDATA[<p><img src="/images/blog_img/Angular-meetting-CoffeeScript.jpg" alt="angualr meet coffeescript" /></p>

<p>CoffeeScript是基于JavaScript的一门扩展小巧语言，它需要编译成JavaScript，然后再运行与浏览器或者Nodejs平台。JavaScript由于商业原因10天时间就匆忙诞生，所以存在很多弊病。但如《JavaScript精粹》一书中所说：JavaScript也存在着一颗华丽的心脏，如果我们能避开JavaScript中的“坑”，使用其精华的部分，这将是一门令人爱不释手的语言. 而CoffeeScript则是尝试使用这部分简洁的方式展示JavaScript的这部分优秀的精华，避免那些困扰JavaScript开发者的“坑”.CoffeeScript借鉴于Python和Ruby这两门语言，函数式风格、鸭子类型、OO风格一体的一门简洁语言。</p>

<p>Angularjs从2012年以来是火极一时的前端MVVM框架，它引入了module、双向绑定、依赖注入、Directive、MVVM等机制。更多资料参见博主其他博文。当Angular遇见CoffeeScript这门语言，将会发生什么呢？</p>

<p>想让我们来看一眼笔者利用CoffeeScript对Angular1.x代码的封装后效果。</p>

<pre><code>## controller
class DemoController extends NgComponent
   @inject 'demoService'
   @controller 'ng.green.demo'   

   __init__: =&gt;
      @demoService.getLang().then (data) =&gt;
        @lang = data 

## service  
class DemoService extends NgComponent
   @inject '$q'
   @service 'ng.green.demo' 

   getLang: =&gt;
      data = data : ['JavaScript', 'CoffeeScript', 'TypeScript', 'ES6']
      @$q.when(data)

## directive controller   
class JsonDumpController extends NgComponent
   @inject '$log'
   @controller 'ng.green.demo'   

   __init__: =&gt;
      @$log.info('This is form directive controller')

## directive       
class JsonDumpDirective extends NgComponent
  @inject '$timeout', '$http', '$cacheFactory', '$log'
  @directive 'ng.green.demo' 
  restrict: 'EA'
  templateUrl: '/jsonDump.html'
  scope: 
    json: "="
  controller: 'JsonDumpController'
  link: (scope, elm, iAttrs) =&gt;
    @$timeout (() =&gt; @$log.info '$timeout &amp; $log injector worked on link function!' ), 100
</code></pre>

<p>有了上面的对controller、service、directive的定义，则我们可以如下方式使用：</p>

<pre><code>&lt;div ng-app="ng.green.demo" ng-controller="DemoController as demo" class="container"&gt;
  &lt;json-dump json="demo.lang"&gt;&lt;/json-dump&gt;
  &lt;script type="text/ng-template" id="/jsonDump.html"&gt; 
  &lt;hr /&gt;
  &lt;pre&gt;&lt;/pre&gt;
&lt;/script&gt; 
&lt;/div&gt;
</code></pre>

<p>不知各位看官对如上代码感觉如何？是不是更简化、语义化、有点ng的感觉。其中笔者还有意模仿Python，如<strong>init</strong>作为初始化方式。在这里每个class会自声明组件类型，以及声明式注入，module自注册。</p>

<p>不管如何看，下面我来看看NgComponent到底做了什么？</p>

<pre><code>class NgComponent
    @controller: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName(true)
      angular.module(moduleName, moduleResolver).controller componentName, @      

    @service: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName()
      angular.module(moduleName, moduleResolver).service componentName, @

    @directive: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName().replace('Directive','')
      directiveClass = @
      directiveFactory = (args...) -&gt;
          new directiveClass(args...)          
      directiveFactory.$inject = @$inject
      angular.module(moduleName, moduleResolver).directive componentName, directiveFactory    

    @$$componentName: (upperCaseFirstLetter = false) -&gt;
      # regex for ie
      componentName = @name || @toString().match(/function\s*(.*?)\(/)?[1]
      if upperCaseFirstLetter
       firstLetter =  componentName.substr(0,1).toUpperCase()
      else
        firstLetter = componentName.substr(0,1).toLowerCase()
      (componentName = "#{firstLetter}#{componentName.substr(1)}") unless upperCaseFirstLetter
      componentName

    @inject: (args...) -&gt;
      @$inject = args

    constructor: (args...) -&gt;
      for key, index in @constructor.$inject
        @[key] = args[index]

      @__init__?()
</code></pre>

<p>在NgComponent中定义了controller、service、directive注册接口，这里可以是声明创建module，也可以是在已声明的module上注册这些组件类型。对于组件命名也才采用了约定胜于配置，它们都以class类型为基础，controller为首字母大写的驼峰命名，service则首字母小写驼峰命名，directive则会去掉Directive标记并首字母小写注册。</p>

<p>同时这里也声明了@inject方法，使得我们可以在定义在类型之上定义$inejct属性，Angular的注入声明。对于Angular的注入服务，在构造函数中会将他们一一添加到当前类实例对象之上。在依赖添加完毕后，也会调用对象初始化方法，这里是模拟Python的<strong>init</strong>。</p>

<p>Demo效果可以在codepen查看 <a href="http://codepen.io/greengerong/pen/EVVQZg?editors=101">http://codepen.io/greengerong/pen/EVVQZg?editors=101</a>：</p>

<p data-height="268" data-theme-id="0" data-slug-hash="EVVQZg" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/EVVQZg/'>Angular meet CoffeeScript</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://greengerong.github.io//assets.codepen.io/assets/embed/ei.js"></script>


<p>本文笔者的突发奇想，希望能给读者一些启发，也许你还有更好的DSL封装，欢迎多多交流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端获取元素定位位置的法宝]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao/"/>
    <updated>2015-09-08T07:09:23+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao</id>
    <content type="html"><![CDATA[<p><img src="/images/blog_img/box-chrome.png" alt="box chrome" /></p>

<p>在前端开发中，我们经常需要定位一个元素。如tooltip、popover或者modal等，或许是我们需要将它们定位在依赖元素的周围或屏幕滚动屏幕中心位置。这对于前端开发的码农来说并不是难事。算出和依赖元素的offset，设置元素的left、right。对于稍复杂的场景我们可能需要考虑被positioned的祖先元素。</p>

<p>但往往不是所有的事情都是这么简单的。笔者最新在项目开发中就遇见这样一个问题：这里的HTML是嵌入的，其来自jpedal商业软件从PDF文件自动生成的；为了展示的样式，jpedal统一使用了 position:absolute和relative来定位PDF元素。然而由于业务的需求，我们需要操作这类HTML。其中一个需求就是需要在每段文字附近显示操作工具条。</p>

<p>对于这类未知的DOM定位，那么我们就需要遍历它的DOM树来计算它的相对位置了。行为下面的这段代码：</p>

<pre><code>    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent &amp;&amp; offsetParent !== docDomEl &amp;&amp; isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };
</code></pre>

<p>在这里，我们会根据元素递归查询它所在的的DOM树中被positioned的最接近的祖先元素，然后才计算它们的相对位置。</p>

<p>这是一段来自Angular-UI bootstrap的$position服务的源码。这也是本文将要提到的获取定位元素位置的法宝。其源码位置在<a href="https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js">https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js</a>。</p>

<p>在$position服务中为我们提供了3个有用的位置服务：position、offset和positionElements。position是计算具体元素的定位位置，返回一个带有width、height、top、left的对象；positionElements则是返回某元素相对于其依赖容器元素的定位位置，一个带有top、left的对象。</p>

<p>笔者为了测试这写API，在jsbin中写了一个特定的指令：</p>

<p>JavaScript:</p>

<pre><code>angular.module("com.ngbook.demo", ['ui.bootstrap.position'])
.directive('position', ['$position', function($position){
    return {
        restrict: 'EA',
        templateUrl: '/position.html',
        scope:{
            title:"@"
        },
        link:function(scope, elm, iAttrs){
        scope.data =  $position.position(elm);
       }
    };
}]);
</code></pre>

<p>HTML:</p>

<pre><code>&lt;script type="text/ng-template" id="/position.html"&gt;
   &lt;table class="table"&gt;
       &lt;thead&gt;
           &lt;th colspan="2"&gt;{{title}}&lt;/th&gt;
       &lt;/thead&gt;
    &lt;tbody&gt;
       &lt;tr ng-repeat="field in ['width', 'height', 'left', 'top']"&gt;
       &lt;td&gt;{{field}}&lt;/td&gt;
       &lt;td&gt;{{data[field] | number}}&lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
 &lt;/script&gt;
</code></pre>

<p>所以我们可以如下测试这类API：</p>

<pre><code>&lt;position title ="no positioned parent"&gt;&lt;/position&gt;

&lt;div style="position: relative;padding:50px;"&gt;
    &lt;position title ="relative parent"&gt;&lt;/position&gt;

     &lt;div style="position: absolute;top:250px; padding:50px;"&gt;
         &lt;position title="relative-&gt;absolute parent"&gt;&lt;/position&gt;
     &lt;/div&gt;
 &lt;/div&gt;

 &lt;div style="position: absolute;top:0px;left:250px; padding:50px;"&gt;
         &lt;position title="absolute parent"&gt;&lt;/position&gt;
 &lt;/div&gt;
</code></pre>

<p>其效果可以在<a href="http://jsbin.com/deximu/edit?html,js,output">jsbin demo</a>:</p>

<p><img src="/images/blog_img/ng-$position-example.png" alt="$position demo" /></p>

<p>同样你也可以在官方的文档中看见对它的测试: <a href="https://github.com/angular-ui/bootstrap/blob/master/src/position/test/test.html">https://github.com/angular-ui/bootstrap/blob/master/src/position/test/test.html</a>。</p>

<p>简单的说：如果我们需要获取某个元素的定位信息，则我们可以用 $position.position(element)；获取相对于固定元素的定位，则可以使用$position.positionElements(hostEl, targetEl, positionStr, appendToBody)。其中positionStr是一个横向和纵向的字符串，如："top-left"、"bottom-left"。其默认值为center。如笔者项目所期望的在某文字段落的左上角显示工具条：</p>

<pre><code>$position.after($toolbar);
var elPosition = $position.positionElements($paragraph, $toolbar, “top-left”);
$toolbar.css({left: elPosition.left + 'px', top: elPosition.top + 'px'});
</code></pre>

<p>当然也不要忘记为toolbar元素设置position: absolute;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular Input格式化]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/03/angular-inputge-shi-hua/"/>
    <updated>2015-09-03T16:29:35+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/03/angular-inputge-shi-hua</id>
    <content type="html"><![CDATA[<p>今天在Angular中文群有位同学问到：如何实现对input box的格式化。如下的方式对吗？</p>

<pre><code> &lt;input type="text" ng-model="demo.text | uppercase" /&gt;
</code></pre>

<p>这当然是不对的。在Angular中filter（过滤器）是为了显示数据的格式，它将$scope上的Model数据格式化View显示的数据绑定到DOM之上。它并不会负责ngModel的绑定值的格式化。</p>

<p>在Angular中ngModel作为Angular双向绑定中的重要组成部分，负责View控件交互数据到$scope上Model的同步。当然这里存在一些差异，View上的显示和输入都是字符串类型，而在Model上的数据则是有特定数据类型的，例如常用的Number、Date、Array、Object等。ngModel为了实现数据到Model的类型转换，在ngModelController中提供了两个管道数组$formatters和$parsers，它们分别是将Model的数据转换为View交互控件显示的值和将交互控件得到的View值转换为Model数据。它们都是一个数组对象，在ngModel启动数据转换时，会以UNIX管道式传递执行这一系列的转换。Angular允许我们手动的添加$formatters和$parsers的转换函数（unshift、push）。同时在这里也是做数据验证的最佳时机，能够转换意味应该是合法的数据。</p>

<p><img src="/images/blog_img/ngModelController-%E7%94%9F%E5%91%BD%E7%8E%AF.png" alt="ngModel" /></p>

<p>同时，我们也可以利用Angular指令的reuqire来获取到这个ngModelController。如下方式来使用它的$parses和$formaters：</p>

<pre><code>.directive('textTransform', [function() {

    return {
        require: 'ngModel',
        link: function(scope, element, iAttrs, ngModelCtrl) {
            ngModelCtrl.$parsers.push(function(value) {
                ...
            });

            ngModelCtrl.$formatters.push(function(value) {
                ...
            });
        }
    };
}]);
</code></pre>

<p>因此，开篇所描述的输入控件的大写格式化，则可以利用ngModelController实现，在对于View文字大小的格式化，这个特殊的场景下，利用css特性text-transform会更简单。所以实现如下：</p>

<pre><code> .directive('textTransform', function() {
     var transformConfig = {
         uppercase: function(input){
             return input.toUpperCase();
         },
         capitalize: function(input){
             return input.replace(
                 /([a-zA-Z])([a-zA-Z]*)/gi,
                 function(matched, $1, $2){
                    return $1.toUpperCase() + $2;
                });
         },
         lowercase: function(input){
             return input.toLowerCase();
         }
     };
    return {
        require: 'ngModel',
        link: function(scope, element, iAttrs, modelCtrl) {
            var transform = transformConfig[iAttrs.textTransform];
            if(transform){
                modelCtrl.$parsers.push(function(input) {
                    return transform(input || "");
                }); 

                element.css("text-transform", iAttrs.textTransform);
            }
        }
    };
});
</code></pre>

<p>则，在HTML就可以如下方式使用指令, demo效果参见<a href="http://jsbin.com/baqaso/edit?html,js,output">jsbin demo</a>：</p>

<pre><code>&lt;input type="text" ng-model="demo.text" text-transform="capitalize" /&gt;
&lt;input type="text" ng-model="demo.text" text-transform="uppercase" /&gt;
&lt;input type="text" ng-model="demo.text" text-transform="lowercase" /&gt;
</code></pre>

<p>在这里利用了css text-transform特性，对于其它的方式，我们可以使用keydown、keyup、keypress等来实现。如<a href="https://github.com/greengerong/green.inputmask4angular">inputMask</a>和<a href="https://github.com/greengerong/ngmodel-format">ngmodel-format</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular实现递归指令 - Tree View]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view/"/>
    <updated>2015-09-02T07:47:21+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view</id>
    <content type="html"><![CDATA[<p>在层次数据结构展示中，树是一种极其常见的展现方式。比如系统中目录结构、企业组织结构、电子商务产品分类都是常见的树形结构数据。</p>

<p>这里我们采用Angular的方式来实现这类常见的tree view结构。</p>

<p>首先我们定义数据结构，采用以children属性来挂接子节点方式来展现树层次结构，示例如下：</p>

<pre><code>[
   {
      "id":"1",
      "pid":"0",
      "name":"家用电器",
      "children":[
         {
            "id":"4",
            "pid":"1",
            "name":"大家电"
         }
      ]
   },
   {
     ...
   }
   ...
]
</code></pre>

<p>则我们对于ng way的tree view可以实现为：</p>

<p>JavaScript:</p>

<pre><code>angular.module('ng.demo', [])
.directive('treeView',[function(){

     return {
          restrict: 'E',
          templateUrl: '/treeView.html',
          scope: {
              treeData: '=',
              canChecked: '=',
              textField: '@',
              itemClicked: '&amp;',
              itemCheckedChanged: '&amp;',
              itemTemplateUrl: '@'
          },
         controller:['$scope', function($scope){
             $scope.itemExpended = function(item, $event){
                 item.$$isExpend = ! item.$$isExpend;
                 $event.stopPropagation();
             };

             $scope.getItemIcon = function(item){
                 var isLeaf = $scope.isLeaf(item);

                 if(isLeaf){
                     return 'fa fa-leaf';
                 }

                 return item.$$isExpend ? 'fa fa-minus': 'fa fa-plus';   
             };

             $scope.isLeaf = function(item){
                return !item.children || !item.children.length; 
             };

             $scope.warpCallback = function(callback, item, $event){
                  ($scope[callback] || angular.noop)({
                     $item:item,
                     $event:$event
                 });
             };
         }]
     };
 }]);
</code></pre>

<p>HTML:</p>

<p>树内容主题HTML： /treeView.html</p>

<pre><code>&lt;ul class="tree-view"&gt;
       &lt;li ng-repeat="item in treeData" ng-include="'/treeItem.html'" &gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>每个item节点的HTML：/treeItem.html</p>

<pre><code>&lt;i ng-click="itemExpended(item, $event);" class=""&gt;&lt;/i&gt;

&lt;input type="checkbox" ng-model="item.$$isChecked" class="check-box" ng-if="canChecked" ng-change="warpCallback('itemCheckedChanged', item, $event)"&gt;

&lt;span class='text-field' ng-click="warpCallback('itemClicked', item, $event);"&gt;&lt;/span&gt;
&lt;ul ng-if="!isLeaf(item)" ng-show="item.$$isExpend"&gt;
   &lt;li ng-repeat="item in item.children" ng-include="'/treeItem.html'"&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>这里的技巧在于利用ng-include来加载子节点和数据，以及利用一个warpCallback方法来转接函数外部回调函数，利用angular.noop的空对象模式来避免未注册的回调场景。对于View交互的数据隔离采用了直接封装在元数据对象的方式，但它们都以$$开头，如$$isChecked、$$isExpend。在Angular程序中以$$开头的对象会被认为是内部的私有变量，在angular.toJson的时候，它们并不会被序列化，所以利用$http发回服务端更新的时候，它们并不会影响服务端传送的数据。同时，在客户端，我们也能利用对象的这些$$属性来控制View的状态，如item.$$isChecked来默认选中某一节点。</p>

<p>我们就可以如下方式来使用这个tree-view：</p>

<pre><code>&lt;tree-view tree-data="demo.tree" text-field="name" value-field='id' item-clicked="demo.itemClicked($item)" item-checked-changed="demo.itemCheckedChanged($item)" can-checked="true"&gt;&lt;/tree-view&gt;
</code></pre>

<p>效果如下，当然你也可以在<a href="http://jsbin.com/vefuqu/edit?html,js,output">jsbin中体验它</a>：</p>

<p> <img src="/images/blog_img/ng-tree-view-sample.png" alt="ng-tree-view" /></p>
]]></content>
  </entry>
  
</feed>
