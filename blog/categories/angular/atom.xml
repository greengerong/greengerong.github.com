<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Angular | 破狼 Blog]]></title>
  <link href="http://greengerong.github.io/blog/categories/angular/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2015-06-16T11:46:12+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    <email><![CDATA[grzx2210@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[angular中的MVVM模式]]></title>
    <link href="http://greengerong.github.io/blog/2015/06/16/angularzhong-de-mvvmmo-shi/"/>
    <updated>2015-06-16T11:33:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/06/16/angularzhong-de-mvvmmo-shi</id>
    <content type="html"><![CDATA[<p> 在开始介绍angular原理之前，我们有必要先了解下mvvm模式在angular中运用。虽然在angular社区一直将angular统称为前端MVC框架，同时angular团队也称它为MVW（Whatever）框架，但angular框架整体上更接近MVVM模式。下面是Igor Minar发布在Google+ <a href="https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV">https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV</a>的文章内容：</p>

<p> MVC vs MVVM vs MVP. What a controversial topic that many developers can spend hours and hours debating and arguing about.</p>

<p>For several years +AngularJS was closer to MVC (or rather one of its client-side variants), but over time and thanks to many refactorings and api improvements, it&rsquo;s now closer to MVVM – the $scope object could be considered the ViewModel that is being decorated by a function that we call a Controller.</p>

<p>Being able to categorize a framework and put it into one of the MV* buckets has some advantages. It can help developers get more comfortable with its apis by making it easier to create a mental model that represents the application that is being built with the framework. It can also help to establish terminology that is used by developers.</p>

<p>Having said, I&rsquo;d rather see developers build kick-ass apps that are well-designed and follow separation of concerns, than see them waste time arguing about MV* nonsense. And for this reason, I hereby declare AngularJS to be MVW framework &ndash; Model-View-Whatever. Where Whatever stands for &ldquo;whatever works for you&rdquo;.</p>

<p>Angular gives you a lot of flexibility to nicely separate presentation logic from business logic and presentation state. Please use it fuel your productivity and application maintainability rather than heated discussions about things that at the end of the day don&rsquo;t matter that much.</p>

<p>在文中特别指出angular在多次的API重构和改善，它越来越接近于MVVM模式，$scope可以被认为是ViewModl，而Controller则是装饰、加工处理这个ViewModel的JavaScript函数。作者更希望大家关注于实现一个成功的，具有好的设计以及遵循“分离关注点”原则的应用程序，而不是去争论MV*，所以他将angular称为MVW框架，是什么并不重要，只要适合你的应用就行。</p>

<p> MVVM模式是Model-View-ViewMode（模型-视图-视图模型）模式的简称，其最早出现在微软的WPF和Silverlight框架中。MVVM模式利用框架内置的双向绑定技术对MVP（Model-View-Presenter）模式的变型，引入了专门的ViewModel（视图模型）来实现View和Model的粘合，让View和Model的进一步分离和解耦。MVVM模式的优势有如下四点：</p>

<ol>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ol>


<p>下面是angular中关于MVVM模式的运用：</p>

<p><img src="/images/blog_img/angular-mvvm.png" alt="angular mvvm" /></p>

<p>在angular中MVVM模式主要分为四部分：</p>

<ol>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。</li>
</ol>


<p>View不能直接与Model交互，而是通过$scope这个ViewModel来实现与Model的交互。对于界面表单的交互，通过ngModel指令来实现View和ViewModel的同步。ngModelController包含$parsers和$formatters两个转换器管道，它们分别实现View表单输入值到Model数据类型转换和Model数据到View表单数据的格式化。对于用户界面的交互Command事件（如ngClick、ngChange等）则会转发到ViewModel对象上，通过ViewModel来实现对于Model的改变。然而对于Model的任何改变，也会反应在ViewModel之上，并且会通过$scope的“脏检查机制”（$digest）来更新到View。从而实现View和Model的分离，达到对前端逻辑MVVM的分层架构。</p>

<p>angular中MVVM模式的实现，以领域Model为中心思维，遵循“分离关注点”设计原则，这也是与jQuery以DOM驱动的思维所不同之处。所以我们在做angular开发的时候应该谨记下面几点：</p>

<h4>绝不要先设计你的页面，然后用DOM操作去改变它</h4>

<p>在以往的jQuery开发中，我们会首先设计页面DOM结构，然后在利用jQuery来改变DOM结构或者实现动态交互效果。因为jQuery是为DOM驱动而设计的，对于拥有大量复杂的前端交互的项目，JavaScript的逻辑变得越来越臃肿，交互逻辑分散各处。</p>

<p>在MVVM模式下的angular开发中， 我们首先需要在脑子里挂着Model的弦。不能老想着“我有XXX这个DOM，我希望让它做XXX这种动态效果”，我们需要从要完成的目标开始思考我们需要或拥有怎么样的Model数据，然后设计我们的应用， 最后才是设计视图，并用$scope来粘合它们。</p>

<h4>Directive不是封装jQuery代码的“天堂”</h4>

<p>如上条所述，我们不能一开始就去想如何利用DOM操作的方法去实现应用目标，然后“冠冕堂皇”的写上一堆jQuery的代码，并将其封装到angular的directive中，最后不得不加上$scope.$apply()来通知angular你的ViewModel的改变，需要启动“脏检查机制”来更新你的改变到View。作者在多个客户项目中看见这种将Directive作为封装jQuery代码“天堂”的例子，其实对于这类问题，大部分情况下，我们都可以用很少了angular代码将其重构为真正的angular way。特别在ng社区经常看见在angular directive中利用jQuery的on方法绑定click、keydown、blur等事件的代码，大部分情况我们都能以对应的ng事件（ngClick、ngChange、ngBlur）来重构它们。</p>

<p>对于这类问题，首先我们应该尽量尝试复用angular的内置指令，以真正的angular way去思考我们的问题，请慎重的引入jQuery的DOM方法和操作。</p>

<p>关于angular MVVM模式的资料，你还可以参考视频：<a href="https://frontendmasters.com/courses/angularjs-mvc-mvvm-mvwhatever/#v=ypur7bfbcq">https://frontendmasters.com/courses/angularjs-mvc-mvvm-mvwhatever/#v=ypur7bfbcq</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ngnice-国内ng学习网站]]></title>
    <link href="http://greengerong.github.io/blog/2015/01/25/ngnice-showcase-he-guide/"/>
    <updated>2015-01-25T10:43:40+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/01/25/ngnice-showcase-he-guide</id>
    <content type="html"><![CDATA[<p><img src="/images/blog_img/ng-logo.png" alt="angular" /></p>

<p>今天给angular新手介绍一个国内开源的ng学习网站<a href="http://www.ngnice.com/">http://www.ngnice.com/</a>这是由一批ng爱好者在雪狼大叔的带领下共同开发完成，致力于帮助更多的ng新人，他们分别是:</p>

<pre><code>ckken，grahamle，NigelYao，asnowwolf，lightma，joeylin，FrankyYang，lrrluo， why520crazy，破狼,二当家, Ken, zxsoft, why520crazy, playing，天猪、jacobdong、以及一批后加入或审校未记名的社区爱好者功能完成的。[这里排名不分先后]
</code></pre>

<p>再ngnice还在逐步完善中，目前完成的重要模块主要分为3栏：ng文章、angular中文指南、ng案例展示。</p>

<p>ng文章：这里主要由一批国内早期的ng高手组成，在这里记录ng的坑、使用方式、以及ng原理之类的文章,方便更多人查看。地址为：<a href="http://www.ngnice.com/">http://www.ngnice.com/</a></p>

<p><img src="/images/blog_img/ng-%E6%96%87%E7%AB%A0.png" alt="ng文章" /></p>

<p>angular中文指南：这是在Angular.js中文社区群里相遇一群Angular的爱好者，在一次巧妙的交谈，大家对于Angular官方的Guide最新版本没有中文版本表示无助，所以为了诸君更好的了解学习Angularjs，大家临时组织了一个Angular 开发指南翻译团队。现已经完成：地址为<a href="http://www.ngnice.com/docs/guide">http://www.ngnice.com/docs/guide</a>。</p>

<p><img src="/images/blog_img/ng-%E6%8C%87%E5%8D%97.png" alt="ng文章" /></p>

<p>ng案例展示：这也是ngnice中对大家最有帮助的一块，这里收集了大家日常开发中会遇见的很多案例，如：进度条、html5表单、ng报表、数据表格展示等更多的有用案例。ng案例展示的目的是在线展示angular的各种常见案例，并能方便大家直接copy到自己的项目中应用。地址为：<a href="http://www.ngnice.com/showcase/#/home/about">http://www.ngnice.com/showcase/#/home/about</a>。</p>

<p><img src="/images/blog_img/ng-showcase.png" alt="ng文章" /></p>

<p>目前由于进入年底等各种原因我们暂停了这些开发，我们希望在后面的时间能继续完善更多的案例和文章分享。同时也希望爱好分享、喜欢交流、也愿意帮助更多ng新人的你能加入我们的ngShowcase开发组(qq群：278252889，注：这里不会给你解决任何ng问题，只供开发组使用)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决ng界面长表达式(ui-set)]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/29/ng-ui-set-for-long-expression/"/>
    <updated>2014-09-29T16:52:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/29/ng-ui-set-for-long-expression</id>
    <content type="html"><![CDATA[<p>本文来自网友sun shine的问题，问题如下：</p>

<pre><code>    您好, 我想求教一个问题.
    在$scope中我的对象名字写的特别深, 在 html中我又多次用到了同一个对象, 对不对在 html中让它绑定到一个临时变量呢?
    比如:
    $scope.this.is.a.very.deep.obj = {
    'name': 'xxx',
    'state': 'active'};

    在 模板中,

    {{this.is.a.very.deep.obj.name}}
    {{this.is.a.very.deep.obj.state}}
    类似于这种, 我能否把 this.is.a.very.deep.obj 预先赋给一个临时的变量, 然后在 两个 span中只需 o.name, o.state 就行了呢? 我觉得这样解析起来是不是快一点.

    但是我试了, 并没有成功. 求指点.
    先谢了.
</code></pre>

<p>在这里首先需要说明的是ng界面的所有引用都需要在$scope这个viewmodel(ui和view的胶水层)，所以如果我们希望能够把表达式变得更可读，更友好，那么我们就必须在$scope上创建这个变量。</p>

<p>再则对于ng其使用使用的一堆的$watch，实现脏检查，如果你理解这些了，那么我们就可以很容易的实现一套如spring的</p>

<pre><code>&lt;c:set var="xxx" expression="xxx" /&gt;
</code></pre>

<p>的tag.</p>

<p>对于实现这类tag，我们最好的方式则是利用ng的directive来实现，代码如下：</p>

<pre><code>        angular.module("greengerong.ui.tag", [])
          .directive("uiSet", [
            function() {
              return {
                restrict: "EA",
                link: function(scope, elm, iAttrs) {
                  scope.$watch(iAttrs.expression, function(val) {
                    scope[iAttrs.
                      var] = val;
                    var apply = !scope.$$phase ? scope.$apply : angular.noop;
                    apply();
                  });
                }
              };
            }
          ]);
</code></pre>

<p>demo效果请移步<a href="http://jsbin.com/neqow/3/edit">jsbin demo</a>;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jasmine测试ng Promises - Provide and Spy]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/29/testing-promises-with-jasmine-provide-and-spy/"/>
    <updated>2014-09-29T15:53:45+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/29/testing-promises-with-jasmine-provide-and-spy</id>
    <content type="html"><![CDATA[<p>jasmine提供了很多些很实用的处理Promises的方法，首先我们来考虑下面的这个例子：</p>

<pre><code>    angular.module("myApp.store").controller("StoresCtrl", function($scope, StoreService, Contact) {
      StoreService.listStores().then(function(branches) {
        Contact.retrieveContactInfo().then(function(userInfo) {
            //more code here crossing user and stores data
        });  
      });
    });
</code></pre>

<p>下面让我们来尝试如何用angular提供的$provide创建一个依赖的实现，以及利用jasmine帮助我们fake方法的返回值：</p>

<p>代码如下，有详细注释帮助你去理解这段代码：</p>

<pre><code>    describe("Store Controller", function() {
      var $controller, Contact, StoreService, createController, scope;

      beforeEach(function() {
        module('myApp.store');

        // Provide will help us create fake implementations for our dependencies
        module(function($provide) {

          // Fake StoreService Implementation returning a promise
          $provide.value('StoreService', {
            listStores: function() {
              return { 
                then: function(callback) {return callback([{ some: "thing", hoursInfo: {isOpen: true}}]);}
              };
            },
            chooseStore: function() { return null;}
          });

          // Fake Contact Implementation return an empty object 
          $provide.value('Contact', {
            retrieveContactInfo: function() {
              return {
                then: function(callback) { return callback({});}
              };
            }
          });

          return null;
        });
      });

      beforeEach(function() {

        // When Angular Injects the StoreService and Contact dependencies, 
        // it will use the implementation we provided above
        inject(function($controller, $rootScope, _StoreService_, _Contact_) {
          scope = $rootScope.$new();
          StoreService = _StoreService_;
          Contact = _Contact_;
          createController = function(params) {
            return $controller("StoresCtrl", {
              $scope: scope,
              $stateParams: params || {}
            });
          };
        });
      });

      it("should call the store service to retrieve the store list", function() {
        var user = { address: {street: 1}};

        // Jasmine spy over the listStores service. 
        // Since we provided a fake response already we can just call through. 
        spyOn(StoreService, 'listStores').and.callThrough();

        // Jasmine spy also allows to call Fake implementations via the callFake function 
        // or we can return our own response via 'and.returnValue
        // Here we can override the response we previously defined and return a promise with a user object
        spyOn(Contact, 'retrieveContactInfo').and.callFake(function() {
          return {
            then: function(callback) { return callback(user); }
          };
        });

        createController();
        // Since we setup a spy we can now expect that spied function to have been called 
        // or to have been called with certain parameters..etc
        expect(StoreService.listStores).toHaveBeenCalled();
      });
    });
</code></pre>

<p>原文地址:<a href="http://ng-learn.org/2014/08/Testing_Promises_with_Jasmine_Provide_Spy/">Testing Promises with Jasmine &ndash; Provide and Spy</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ng Http Request/response格式转换]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/02/ng-http-transformrequest/"/>
    <updated>2014-09-02T22:59:05+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/02/ng-http-transformrequest</id>
    <content type="html"><![CDATA[<p>angular作为Single Page Application推荐的交互方式当然是基于json的ajax调用。但今天要说的是当你不幸工作在一个遗留或者不可控制的服务上，而这服务是基于非json提交方式(或许是常规表单(form)提交，或者其他自定义数据格式)，那么我们只能改变ng内部$http默认request/response格式转化方式。</p>

<p>所幸的是ng $http给我们提供了多种可用方式转化数据格式(下面demo将以form提交方式为例):</p>

<p>***对于部分单独的http request设置：</p>

<p>对于http ajax方式最后一个参数都是关于http的配置信息，其中包括一项transformRequest，我们可以利用transformRequest在ajax发送数据之前改变数据的格式，例如下边的demo:</p>

<pre><code>$http.post("/url", {
      id: 1,
      name: "greengerong"
    }, {
      transformRequest: function(request) {
        return $.param(request);
    }
});
</code></pre>

<p>这里利用jQuery的$.param进行表单提交方式的格式转化，所以我们能够看见的request body 为：</p>

<pre><code>id=1&amp;name=greengerong
</code></pre>

<p>online <a href="http://plnkr.co/edit/hxAb2V">demo</a>;</p>

<p>***对于整个app的http request设置：</p>

<p>如果我们需要对整个http的数据转化格式进行设置，那么可以选用在config阶段对$httpProvider默认行为进行设置：</p>

<pre><code>angular.module("app", [])
.config(["$httpProvider", function($httpProvider) {
      $httpProvider.defaults.transformRequest = [
        function(request) {
          return $.param(request);
        }
      ];
    }
]);
</code></pre>

<p>这样我们就可以轻易的转化为form提交方式。</p>

<p>同样$http也为我们提供了transformResponse方式，我们也可以创建自己的response转化，比如json之前加入自定义前缀防止json array攻击等等。</p>
]]></content>
  </entry>
  
</feed>
