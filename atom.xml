<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[破狼 Blog]]></title>
  <link href="http://greengerong.github.io/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2014-09-29T17:02:40+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    <email><![CDATA[grzx2210@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解决ng界面长表达式(ui-set)]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/29/ng-ui-set-for-long-expression/"/>
    <updated>2014-09-29T16:52:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/29/ng-ui-set-for-long-expression</id>
    <content type="html"><![CDATA[<p>本文来自网友sun shine的问题，问题如下：</p>

<pre><code>    您好, 我想求教一个问题.
    在$scope中我的对象名字写的特别深, 在 html中我又多次用到了同一个对象, 对不对在 html中让它绑定到一个临时变量呢?
    比如:
    $scope.this.is.a.very.deep.obj = {
    'name': 'xxx',
    'state': 'active'};

    在 模板中,



    类似于这种, 我能否把 this.is.a.very.deep.obj 预先赋给一个临时的变量, 然后在 两个 span中只需 o.name, o.state 就行了呢? 我觉得这样解析起来是不是快一点.

    但是我试了, 并没有成功. 求指点.
    先谢了.
</code></pre>

<p>在这里首先需要说明的是ng界面的所有引用都需要在$scope这个viewmodel(ui和view的胶水层)，所以如果我们希望能够把表达式变得更可读，更友好，那么我们就必须在$scope上创建这个变量。</p>

<p>再则对于ng其使用使用的一堆的$watch，实现脏检查，如果你理解这些了，那么我们就可以很容易的实现一套如spring的</p>

<pre><code>&lt;c:set var="xxx" expression="xxx" /&gt;
</code></pre>

<p>的tag.</p>

<p>对于实现这类tag，我们最好的方式则是利用ng的directive来实现，代码如下：</p>

<pre><code>        angular.module("greengerong.ui.tag", [])
          .directive("uiSet", [
            function() {
              return {
                restrict: "EA",
                link: function(scope, elm, iAttrs) {
                  scope.$watch(iAttrs.expression, function(val) {
                    scope[iAttrs.
                      var] = val;
                    var apply = !scope.$$phase ? scope.$apply : angular.noop;
                    apply();
                  });
                }
              };
            }
          ]);
</code></pre>

<p>demo效果请移步<a href="http://jsbin.com/neqow/3/edit">jsbin demo</a>;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jasmine测试ng Promises - Provide and Spy]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/29/testing-promises-with-jasmine-provide-and-spy/"/>
    <updated>2014-09-29T15:53:45+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/29/testing-promises-with-jasmine-provide-and-spy</id>
    <content type="html"><![CDATA[<p>jasmine提供了很多些很实用的处理Promises的方法，首先我们来考虑下面的这个例子：</p>

<pre><code>    angular.module("myApp.store").controller("StoresCtrl", function($scope, StoreService, Contact) {
      StoreService.listStores().then(function(branches) {
        Contact.retrieveContactInfo().then(function(userInfo) {
            //more code here crossing user and stores data
        });  
      });
    });
</code></pre>

<p>下面让我们来尝试如何用angular提供的$provide创建一个依赖的实现，以及利用jasmine帮助我们fake方法的返回值：</p>

<p>代码如下，有详细注释帮助你去理解这段代码：</p>

<pre><code>    describe("Store Controller", function() {
      var $controller, Contact, StoreService, createController, scope;

      beforeEach(function() {
        module('myApp.store');

        // Provide will help us create fake implementations for our dependencies
        module(function($provide) {

          // Fake StoreService Implementation returning a promise
          $provide.value('StoreService', {
            listStores: function() {
              return { 
                then: function(callback) {return callback([{ some: "thing", hoursInfo: {isOpen: true}}]);}
              };
            },
            chooseStore: function() { return null;}
          });

          // Fake Contact Implementation return an empty object 
          $provide.value('Contact', {
            retrieveContactInfo: function() {
              return {
                then: function(callback) { return callback({});}
              };
            }
          });

          return null;
        });
      });

      beforeEach(function() {

        // When Angular Injects the StoreService and Contact dependencies, 
        // it will use the implementation we provided above
        inject(function($controller, $rootScope, _StoreService_, _Contact_) {
          scope = $rootScope.$new();
          StoreService = _StoreService_;
          Contact = _Contact_;
          createController = function(params) {
            return $controller("StoresCtrl", {
              $scope: scope,
              $stateParams: params || {}
            });
          };
        });
      });

      it("should call the store service to retrieve the store list", function() {
        var user = { address: {street: 1}};

        // Jasmine spy over the listStores service. 
        // Since we provided a fake response already we can just call through. 
        spyOn(StoreService, 'listStores').and.callThrough();

        // Jasmine spy also allows to call Fake implementations via the callFake function 
        // or we can return our own response via 'and.returnValue
        // Here we can override the response we previously defined and return a promise with a user object
        spyOn(Contact, 'retrieveContactInfo').and.callFake(function() {
          return {
            then: function(callback) { return callback(user); }
          };
        });

        createController();
        // Since we setup a spy we can now expect that spied function to have been called 
        // or to have been called with certain parameters..etc
        expect(StoreService.listStores).toHaveBeenCalled();
      });
    });
</code></pre>

<p>原文地址:<a href="http://ng-learn.org/2014/08/Testing_Promises_with_Jasmine_Provide_Spy/">Testing Promises with Jasmine &ndash; Provide and Spy</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android setTag方法的key问题]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/29/android-settag-key/"/>
    <updated>2014-09-29T10:22:25+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/29/android-settag-key</id>
    <content type="html"><![CDATA[<p>android在设计View类时，为了能储存一些辅助信息，设计一个一个setTag/getTag的方法。这让我想起在Winform设计中每个Control同样存在一个Tag。</p>

<p>今天要说的是我最近学习android遇见的setTag的坑。一般情况下我们只需要使用唯一参数的setTag方法。但有时我们需要存储多个数据，所以这个时候我们就需要使用带key的重载。</p>

<p>文档是描述：“ The specified key should be an id declared in the resources of the application to ensure it is unique (see the ID resource type). Keys identified as belonging to the Android framework or not associated with any package will cause an IllegalArgumentExceptionto be thrown.”</p>

<p>这里说明必须保证key的唯一，但是如果我们使用java常量定义key（private static final int TAG_ID = 1;）这样你任然会遇见如下错误：</p>

<pre><code>java.lang.IllegalArgumentException: The key must be an application-specific resource id
</code></pre>

<p>正确的解决方案是：</p>

<p>在res/values/strings.xml中定义这个key常量，如下：</p>

<pre><code>    &lt;resources&gt;
        &lt;item type="id" name="tag_first"&gt;&lt;/item&gt;
        &lt;item type="id" name="tag_second"&gt;&lt;/item&gt;
    &lt;/resources&gt;
</code></pre>

<p>使用如下：</p>

<pre><code>    imageView.setTag(R.id.tag_first, "Hello");
    imageView.setTag(R.id.tag_second, "Success");
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[karma作为jQuery单元测试Runner]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/03/karma-for-jquery-unit-test/"/>
    <updated>2014-09-03T22:27:20+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/03/karma-for-jquery-unit-test</id>
    <content type="html"><![CDATA[<p>karma作为angular测试runner出现，如果你使用过karma一定感受到这很不错的javascript测试runner。简单干净的配置文件karma.config.js，以及karma init一些快捷的配置command。以及整套测试套件，如html2js,coverage。对于angular单元测试karma就是一个全生态的测试套件，能够简洁快速的搭建整个测试流程。</p>

<p>本文将尝试运用karma作为jQuery单元测试runner。对于jQuery这种DOM操作的框架，有时难于分离view逻辑，以及ajax这种外部资源的mock，所以比较难于实施对jQuery程序的TDD开发。</p>

<h4>jasmime测试套件</h4>

<p>对于jasmine测试框架为了解决这些问题有两个插件jasmine-jquery和jasmine-ajax。</p>

<h4>jasmine-jquery</h4>

<p>jasmine-jQuery主要解决加载测试所需的DOM元素，为单元测试构建前置环境。jasmine-jQuery加载DOM方法：</p>

<pre><code>jasmine.getFixtures().fixturesPath = 'base path';
loadFixtures('myfixture.html');
jasmine.getFixtures().load(...);
</code></pre>

<p>这里的loadFixtures需要真实ajax获取html fixtures所以我们需要提前host html fixtures。jasmine-jQuery还框架了一些有用的matchers，如toBeChecked， toBeDisabled， toBeFocused，toBeInDOM&hellip;&hellip;</p>

<h4>jasmine-ajax</h4>

<p>jasmine-ajax则是对于一般ajax测试的mock框架，其从底层xmlhttprequest实施mock。所以让我们能偶很容易实施对于jQuery的$.ajax,$.get&hellip;mock。如</p>

<pre><code> beforeEach(function() {
    jasmine.Ajax.requests.when = function (url) {
      return this.filter("/jquery/ajax")[0];
    };
    jasmine.Ajax.install();
});

it("jquery ajax success with getResponse", function() {
    var result;

    $.get("/jquery/ajax").success(function(data) {
        result = data;
    });

    jasmine.Ajax.requests.when("/jquery/ajax").response({
      "status": 200,
      "contentType": 'text/plain',
      "responseText": 'data from mock ajax'
    });

    expect(result).toEqual('data from mock ajax');
});


afterEach(function() {
    jasmine.Ajax.uninstall();
});
</code></pre>

<p>对于jasmine-ajax是实施mock之前一定需要jasmine.Ajax.install()，以及测试完成后需要jasmine.Ajax.uninstall();jasmine-ajax在install后会把所有的ajax mock掉，所以如果有需要真实ajax的需要在install之前完成，如jasmine-jQuery加载view loadFixtures。</p>

<h4>运用karma runner</h4>

<p>我们已经了解了jasmine测试的两个框架jasmine-jQuery和jasmine-ajax，所以运用karma作为runner，我们需要解决的问题就是把他们和karma集成在一起。</p>

<p>所以分为以下几步：
1：karma中引入jasmine-jQuery和jasmine-ajax(可以利用bowerinstall)
2：host 测试的html fixtures。
3：加载html fixtures 与install ajax之前。</p>

<p>对于host 文件karma提供了pattern模式，所以karma配置为：</p>

<pre><code>files: [
    {
      pattern: 'view/**/*.html',
      watched: true,
      included: false,
      served: true
    },
    'bower_components/jquery/dist/jquery.js',
    'bower_components/jasmine-jquery/lib/jasmine-jquery.js',
    'bower_components/jasmine-ajax/lib/mock-ajax.js',
    'src/*.js',
    'test/*.js'
],
</code></pre>

<p>这里需要注意karma自带的jasmine是低版本的，所以我们需要npm install karma-jasmine@2.0获取最新的karma-jasmine插件。</p>

<p>我们就可以完成了karma的配置，我们可以简单测试我们的配置：<a href="https://github.com/greengerong/karma-jasmine-jquery/">demo on github</a>.</p>

<p>测试html fixtures加载：</p>

<pre><code>describe('console html content', function() {

  beforeEach(function() {
    jasmine.getFixtures().fixturesPath = 'base/view/';
    loadFixtures("index.html");
  });

  it('index html', function() {
    expect($("h2")).toBeInDOM();
    expect($("h2")).toContainText("this is index page");
  });

})
</code></pre>

<p>测试mock ajax：</p>

<pre><code>describe('console html content', function() {

  beforeEach(function() {
     jasmine.Ajax.requests.when = function(url) {
         return this.filter("/jquery/ajax")[0];
     };
     jasmine.Ajax.install();
 });


  it('index html', function() {
    expect($("h2")).toBeInDOM();
    expect($("h2")).toContainText("this is index page");
  });

  it("ajax mock", function() {
    var doneFn = jasmine.createSpy("success");

    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function(args) {
      if (this.readyState == this.DONE) {
        doneFn(this.responseText);
      }
    };

    xhr.open("GET", "/some/cool/url");
    xhr.send();

    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/some/cool/url');
    expect(doneFn).not.toHaveBeenCalled();

    jasmine.Ajax.requests.mostRecent().response({
      "status": 200,
      "contentType": 'text/plain',
      "responseText": 'awesome response'
    });

    expect(doneFn).toHaveBeenCalledWith('awesome response');
  });

  it("jquery ajax success with getResponse", function() {
    var result;
    getResponse().then(function(data){
      result = data;
    });

    jasmine.Ajax.requests.when("/jquery/ajax").response({
      "status": 200,
      "contentType": 'text/plain',
      "responseText": 'data from mock ajax'
    });

    expect(result).toEqual('data from mock ajax');
  });

  it("jquery ajax error", function() {
    var status;
    $.get("/jquery/ajax").error(function(response) {
      status = response.status;
    });

    jasmine.Ajax.requests.when("/jquery/ajax").response({
      "status": 400
    });

    expect(status).toEqual(400);
  });

  afterEach(function() {
    jasmine.Ajax.uninstall();
  });
})      
</code></pre>

<p>更多请参见<a href="https://github.com/greengerong/karma-jasmine-jquery/">demo on github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ng Http Request/response格式转换]]></title>
    <link href="http://greengerong.github.io/blog/2014/09/02/ng-http-transformrequest/"/>
    <updated>2014-09-02T22:59:05+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/09/02/ng-http-transformrequest</id>
    <content type="html"><![CDATA[<p>angular作为Single Page Application推荐的交互方式当然是基于json的ajax调用。但今天要说的是当你不幸工作在一个遗留或者不可控制的服务上，而这服务是基于非json提交方式(或许是常规表单(form)提交，或者其他自定义数据格式)，那么我们只能改变ng内部$http默认request/response格式转化方式。</p>

<p>所幸的是ng $http给我们提供了多种可用方式转化数据格式(下面demo将以form提交方式为例):</p>

<p>***对于部分单独的http request设置：</p>

<p>对于http ajax方式最后一个参数都是关于http的配置信息，其中包括一项transformRequest，我们可以利用transformRequest在ajax发送数据之前改变数据的格式，例如下边的demo:</p>

<pre><code>$http.post("/url", {
      id: 1,
      name: "greengerong"
    }, {
      transformRequest: function(request) {
        return $.param(request);
    }
});
</code></pre>

<p>这里利用jQuery的$.param进行表单提交方式的格式转化，所以我们能够看见的request body 为：</p>

<pre><code>id=1&amp;name=greengerong
</code></pre>

<p>online <a href="http://plnkr.co/edit/hxAb2V">demo</a>;</p>

<p>***对于整个app的http request设置：</p>

<p>如果我们需要对整个http的数据转化格式进行设置，那么可以选用在config阶段对$httpProvider默认行为进行设置：</p>

<pre><code>angular.module("app", [])
.config(["$httpProvider", function($httpProvider) {
      $httpProvider.defaults.transformRequest = [
        function(request) {
          return $.param(request);
        }
      ];
    }
]);
</code></pre>

<p>这样我们就可以轻易的转化为form提交方式。</p>

<p>同样$http也为我们提供了transformResponse方式，我们也可以创建自己的response转化，比如json之前加入自定义前缀防止json array攻击等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[angularjs之browserTrigger]]></title>
    <link href="http://greengerong.github.io/blog/2014/06/24/angularjs-browsertrigger/"/>
    <updated>2014-06-24T20:42:33+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/06/24/angularjs-browsertrigger</id>
    <content type="html"><![CDATA[<p>今天推荐一款来自angularjs源码的单元测试辅助库browserTrigger，这是来自于ngScenario的一段代码。主要用户触发浏览器型行为更新ng中scope view model的值。</p>

<p>这是angularjs源码中单元测试的使用browserTrigger的实例：</p>

<pre><code>it('should set the model to empty string when empty option is selected', function() {
    scope.robot = 'x';
    compile('&lt;select ng-model="robot"&gt;' +
              '&lt;option value=""&gt;--select--&lt;/option&gt;' +
              '&lt;option value="x"&gt;robot x&lt;/option&gt;' +
              '&lt;option value="y"&gt;robot y&lt;/option&gt;' +
            '&lt;/select&gt;');
    expect(element).toEqualSelect('', ['x'], 'y');

    browserTrigger(element.find('option').eq(0));
    expect(element).toEqualSelect([''], 'x', 'y');
    expect(scope.robot).toBe('');
  });
</code></pre>

<p>在这段代码中给browserTrigger传入你希望选择的select option，则它会帮助你tigger change，选中当前option，更触发更新ng select的viewmodel。</p>

<p>在browserTrigger中还为我们做了很多其他输入框或者html控件的触发接口，同时也加入了浏览器的兼容性。使得我们的测试更加方便不用考虑浏览器兼容性或者不同的html控件trigger不同的事件去更新scope的值。</p>

<p>具体更多信息请参考<a href="https://github.com/angular/angular.js/blob/accd35b7471bbf58cd5b569a004824fa60fa640a/test/ng/directive/selectSpec.js">ng的官方测试</a>和<a href="https://raw.githubusercontent.com/angular/angular.js/dafb8a3cd12e7c3247838f536c25eb796331658d/src/ngScenario/browserTrigger.js">browserTrigger源码</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件架构设计模式简述]]></title>
    <link href="http://greengerong.github.io/blog/2014/03/18/ddd-practice/"/>
    <updated>2014-03-18T19:07:08+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/03/18/ddd-practice</id>
    <content type="html"><![CDATA[<p>在软件开发设计中我们经常会面对业务分析，提取领域问题，从而实现软件架构设计。关于
软件架构设计Martin Fowler在2004出版的<a href="http://book.douban.com/subject/4826290/">《企业应用架构模式》</a>中
概括了四种方式的架构模式。它们分别为事务性脚本，表驱动模式，活动记录模式，领域驱动设计。前两者事务性脚本，表驱动模式作为
面向过程方式架构设计，后两者为面向对象架构设计。它们适合于不同的业务场景，它们也各有长短。</p>

<h4>事务脚本模式</h4>

<p>事务脚本模式是架构设计中最简单的架构模式，面向过程模式。该模式以用户的操作，UI表现为起点，设计业务组件，
即业务逻辑将直接映射到用户界面的操作。这通常是从表现层逻辑出发，表现层需要什么那么业务层就提供什么，
直到数据层。针对每一个用户的新功能都需要新增一个从UI到关系数据库的分支流程。其适用于逻辑不是
很复杂或者变化不会太大的稳定的应用系统开发。其不需要付出与业务无关的额外代价，并且在现代可见即可得的IDE
结合，能够很快的进行快速应用开发（RAD）。但是这种优势，也是其最大的劣势，程序中充满了IF-else，
switch-case之类的逻辑或者大量的static的方法，每个功能都是一个程序分支，这对代码无法重用。
编码不易于维护，对复杂项目和变化需求不适应。</p>

<h4>表驱动模式</h4>

<p>表驱动模式为每个数据库表定义一个表模块类，包含操作该数据的所有行为方法。作为一个容器，将数据
和行为组织在一起。其对数据的粒度针对于数据表，而非数据行，因此需要以集合或者表(DataTable)传递数据信息。
表驱动模式基于对象但是完全由数据库驱动开发，在业务模型和数据库关系模型显著差异的情况下，应对需求，
并不是那么适合。但是在.net中提供的一些列如强类型DataSet等IDE的辅助下自动生成大量的代码，
也是一个不错的选择，因为部分数据库的操作趋于自动化。表驱动模式没有太过于关注业务逻辑，而是关注数据库
表结构。而业务逻辑和领域问题才是软件核心，所以对于复杂的场景也存在不能很好的胜任。</p>

<h4>活动记录模式</h4>

<p>活动记录模式是一个以数据库表一行Row为对象，并且对象中包含行为和数据的模式方法。其数据对象
很大程度的接近数据库表结构。在活动记录模式中对象通常也包含架构设计和扩展对象的CRUD(增删改查)的行为，以及数据验证等业
务规则。对于业务不是很复杂，对象关系与关系模型映射不具有很大差异情况，活动记录模式会运用的
很好。活动模式比较简单化设计，在现行的如Linq to sql，ActiveRecord框架，
spring JDBC(Active Record),Ruby On Rails之类的框架之下，
将针对问题领域不是太过复杂的中小型项目十分有用，而且能做到快速，并且有较好设计的架构设计和扩展。
但是其模式和数据库表结构的过度的相互依赖，导致若你修改
数据库结构，你不得不同时修改对象以及相关逻辑。如果不能保证数据库关系模型和对象模式的很大程度
的相似这就进入的困境，无法解决对象和数据库结构的映射。</p>

<h4>领域驱动设计(DDD)</h4>

<p>在我们所述前面的几种架构模式都是在项目开始站在了以数据为中心的角度，而不是业务本身的问题领域。
而领域驱动设计模式是着重关注于系统的业务问题领域，首先开始为领域对象设计。与活动记录模式来说，
领域模型完全反映于问题领域业务概念模型逻辑，与数据库，持久化机制完成独立，其推崇持久化透明（POCO）。
其可以充分利用面向对象设计，不受持久化机制的任何约束。其为完全由业务驱动出来的。但是其最大的优势如上
各个模式一样也是其最大的劣势领域对象模型与关系模型具有天然的阻抗，领域实体对象早晚会需要映射到
持久化机制，有时我们必须等为了这种阻抗而让步。在当前有NHibearnate,EF,Fluent NHibearnate这类
ORM(Object Relation Mapping)框架辅助。</p>

<p>领域驱动设计是Eric Evans于2004年在<a href="http://book.douban.com/subject/5344973/">《领域驱动设计：软件核心复杂性应对之道》</a>
首先提出的，简称DDD.其实际为面向对象分析设计(OOAD)的延伸，利用面向对象思想进行分析设计，对系统逻辑严格
分层，对领域对象的的职责划分。领域逻辑按照职责和内聚的划分在不同的领域对象上，对象不再是单纯的数据载体，而应该
是一个具有行为，逻辑的富对象。</p>

<p>同时领域驱动设计中分层架构也是很重要的一部分，这是分离关注点(SOC)的体现。按照职责对每一层次划分。大体分为
表现层，业务逻辑层，仓储层，领域层，以及基本出设施层。以及后来所倡导的CQRS(读写分离).在层次之间为了应对面向对象设计
所有存在领域模型(DO)，然而我们常用的存储却是关系类型(PO),所以还存在ORM(Object Relation Mapping).以及为了更好的
适应UI的表现存在视图对象(VO，有时我们简单VO的存在直接用数据传输对象(DTO)代替)，所以存在DTO Mapping，在这里的VO或者DTO，往往
都是一层简单getter,setter的数据载体。</p>

<p>在领域驱动设计中还包含工作单元(UOW))，仓储，值类型,实体，聚合根，领域事件，领域边界，以及领域跟踪一类的概念，关于这些更多的知识
请参考<a href="http://book.douban.com/subject/4826290/">《企业应用架构模式》</a>，以及<a href="http://book.douban.com/subject/25844633/">实现领域驱动设计</a></p>

<p>最后推荐最新的领域驱动设计书籍资料：此书被DDD鼻祖Eric Evans誉为继其开山之作后，近十年内第一本将DDD落到具体(接地气)的经典书籍。</p>

<p><img src="http://img5.douban.com/lpic/s27236377.jpg" alt="实现领域驱动设计" /></p>

<ul>
<li><a href="http://www.amazon.cn/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E6%B2%83%E6%81%A9%E2%80%A2%E5%BC%97%E5%86%9C/dp/B00IYTVWA6/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1395749901&amp;sr=1-1">亚马逊</a></li>
<li><a href="http://product.dangdang.com/23439300.html#ddclick?act=click&amp;pos=23439300_0_1_p&amp;cat=01.00.00.00.00.00&amp;key=%CE%D6%B6%F7.%B8%A5%C5%A9&amp;qinfo=&amp;pinfo=1_1_72&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140309205553118327545287259908607&amp;ref=http%3A%2F%2Fproduct.dangdang.com%2F23439300.html&amp;rcount=&amp;type=&amp;t=1395231961000">当当</a></li>
<li><a href="http://item.jd.com/1100303441.html">京东</a></li>
<li><a href="http://book.douban.com/subject/25844633/">豆瓣</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译]docker生态圈Mindmap]]></title>
    <link href="http://greengerong.github.io/blog/2014/03/18/docker-ecosystem-mapped-out/"/>
    <updated>2014-03-18T05:01:09+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/03/18/docker-ecosystem-mapped-out</id>
    <content type="html"><![CDATA[<p>Docker是一个开源的Linux容器，其被业界所接受，很快成为了一个产业标准。Docker可以减少应用程序启动
时候的大量资源的筹备。docker很快的成为了新兴的应用程序容器标准。现在有很多项目正围绕着它处于开发中。
下面将是Mindmap出我所知道的一些项目。你可以在这里访问<a href="http://www.mindmeister.com/389671722/docker-ecosystem">Mindmap</a>.</p>

<p><a href="http://www.mindmeister.com/389671722/docker-ecosystem"><img src="http://i0.wp.com/allthingsplatforms.com/wp-content/uploads/2014/03/Docker-Ecosystem-v0.1.png?resize=717%2C432" alt="docker mindmap" /></a></p>

<p>英语原文链接<a href="http://allthingsplatforms.com/platforms/docker-ecosystem-mapped-out/">http://allthingsplatforms.com/platforms/docker-ecosystem-mapped-out/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义项目脚手架- Maven Archetypes]]></title>
    <link href="http://greengerong.github.io/blog/2014/03/17/create-yourself-archetypes-plugin/"/>
    <updated>2014-03-17T05:14:21+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/03/17/create-yourself-archetypes-plugin</id>
    <content type="html"><![CDATA[<p>在上篇<a href="http://greengerong.github.io/blog/2014/03/16/intellij-remove-archetype-plugin/">Intellij修改archetype Plugin配置</a>
中我们已经简单介绍了关于archetype的作用。</p>

<p>简单来说maven archetype插件就是创建项目的脚手架,通过命令行或者IDE集成简化项目创建的工作。例如：</p>

<ul>
<li>org.apache.maven.archetypes:maven-archetype-quickstart</li>
<li>org.apache.maven.archetypes:maven-archetype-site</li>
<li>org.apache.maven.archetypes:maven-archetype-webapp</li>
<li>以及spring或者第三方提供了一些archetype plugin。</li>
</ul>


<p>同时maven archetype插件也是一个简单的maven artifact，它包含了创建项目所需要的所有资源。
主要分为几类原型信息：</p>

<ul>
<li>archetype描述文件(src/main/resources/META-INF/maven/archetype.xml),这为<a href="http://maven.apache.org/plugins/maven-archetype-plugin-1.0-alpha-7/">archetype 1.0</a>,
包含所有创建项目的文件信息和路径信息。在(archetype 2.0)[<a href="http://maven.apache.org/archetype/maven-archetype-plugin/">http://maven.apache.org/archetype/maven-archetype-plugin/</a>]增加了更灵活的archetype-metadata.xml(src/main/resources/META-INF/maven/下),
archetype元数据信息，并且完全支持1.0.</li>
<li>项目的原型文件(src/main/resources/archetype-resources/之下)，将会被archetype插件
copy到项目目录结构去。</li>
<li>创建项目的pom文件(src/main/resources/archetype-resources下)</li>
<li>archetype pom文件，在archetype项目根目录下。</li>
</ul>


<h4>创建archetype插件</h4>

<ol>
<li><p>首先在archetype中加入一个pom文件，如下：</p>

<pre><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;com.github.greengerong&lt;/groupId&gt;
      &lt;artifactId&gt;component&lt;/artifactId&gt;
      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
      &lt;packaging&gt;jar&lt;/packaging&gt;

      &lt;name&gt;component&lt;/name&gt;
      &lt;url&gt;http://maven.apache.org&lt;/url&gt;

      &lt;properties&gt;
          &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;/properties&gt;

      &lt;dependencies&gt;
      &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre></li>
<li><p>创建archetype-metadata.xml,位于src/main/resources/META-INF/maven/目录下，例如：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;archetype-descriptor name="app-server"&gt;
    &lt;fileSets&gt;
        &lt;fileSet filtered="true" encoding="UTF-8"&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.**&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/fileSet&gt;
        &lt;fileSet filtered="true" encoding="UTF-8"&gt;
            &lt;directory&gt;src/test/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.**&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/archetype-descriptor&gt;
</code></pre></li>
</ol>


<p>更多配置信息参考<a href="https://maven.apache.org/archetype/archetype-common/archetype-descriptor.html">archetype-descriptor</a>.</p>

<ol>
<li><p>为将创建的项目增加pom.xml文件，以${artifactId} / ${groupId} 变量作为占位符，例如：</p>

<pre><code>  &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;${groupId}&lt;/groupId&gt;
      &lt;artifactId&gt;${artifactId}&lt;/artifactId&gt;
      &lt;version&gt;${version}&lt;/version&gt;
      &lt;packaging&gt;jar&lt;/packaging&gt;

      &lt;name&gt;${artifactId}&lt;/name&gt;

      &lt;properties&gt;
          &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;/properties&gt;

      &lt;dependencies&gt;
          &lt;dependency&gt;
              &lt;groupId&gt;junit&lt;/groupId&gt;
              &lt;artifactId&gt;junit&lt;/artifactId&gt;
              &lt;version&gt;4.11&lt;/version&gt;
              &lt;scope&gt;test&lt;/scope&gt;
          &lt;/dependency&gt;
      &lt;/dependencies&gt;

      &lt;build&gt;
          &lt;pluginManagement&gt;
              &lt;plugins&gt;
                  &lt;plugin&gt;
                      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                      &lt;configuration&gt;
                          &lt;source&gt;1.6&lt;/source&gt;
                          &lt;target&gt;1.6&lt;/target&gt;
                      &lt;/configuration&gt;
                  &lt;/plugin&gt;
              &lt;/plugins&gt;
          &lt;/pluginManagement&gt;
      &lt;/build&gt;
  &lt;/project&gt;
</code></pre></li>
<li><p>接下来在archetype项目下install plugin：mvn clean install.</p></li>
<li><p>利用已有archetype plugin创建项目：</p>

<p>命令行：</p>

<pre><code>mvn archetype:generate -DarchetypeGroupId=&lt;archetype-groupId&gt;  -DarchetypeArtifactId=&lt;archetype-artifactId&gt; -DarchetypeVersion=&lt;archetype-version&gt;  -DgroupId=&lt;my.groupid&gt; -DartifactId=&lt;my-artifactId&gt;
</code></pre></li>
</ol>


<p>  intellij选择增加archetype plugin：
  <img src="http://greengerong.github.io/images/blog_img/Intellij-archetype-plugin.png" alt="/images/blog_img/Intellij-archetype-plugin.png" /></p>

<p>对于删除intellij测试archetype信息，请参见<a href="http://greengerong.github.io/blog/2014/03/16/intellij-remove-archetype-plugin/">Intellij修改archetype Plugin配置</a>.</p>

<p>注意：</p>

<ul>
<li><p>如果你也需要文件名字或者目录名字，则需要用特殊变量__artifactId__(双下划线)作为占位符。</p>

<p> 本文demo,请移到到github <a href="https://github.com/greengerong/maven-archetypes-demo">maven-archetypes-demo</a>.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intellij修改archetype Plugin配置]]></title>
    <link href="http://greengerong.github.io/blog/2014/03/16/intellij-remove-archetype-plugin/"/>
    <updated>2014-03-16T07:51:08+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/03/16/intellij-remove-archetype-plugin</id>
    <content type="html"><![CDATA[<p>Maven archetype plugin为我们提供了方便的创建
project功能,Archtype指我们项目的骨架，作为项目的脚手架。
如fornt end的yo之类。我们能够通过简单的一行控制台command
line创建你所需要的项目结构：</p>

<pre><code>mvn archetype:generate
  -DarchetypeGroupId=&lt;archetype-groupId&gt;
  -DarchetypeArtifactId=&lt;archetype-artifactId&gt;
  -DarchetypeVersion=&lt;archetype-version&gt;
  -DgroupId=&lt;my.groupid&gt;
  -DartifactId=&lt;my-artifactId&gt;
</code></pre>

<p>常用的Maven archetype plugin有：</p>

<ul>
<li>org.apache.maven.archetypes:maven-archetype-quickstart</li>
<li>org.apache.maven.archetypes:maven-archetype-site</li>
<li>org.apache.maven.archetypes:maven-archetype-webapp</li>
<li>以及spring或者第三方提供了一些archetype plugin。</li>
</ul>


<p>同时在java世界强大的IDE Intellij也支持按照maven archetype
创建java项目。你只需要选择maven 创建项目，在最后选择你希望的
archetype plugin，然后就可以喝杯coffe等待build success。</p>

<p>关于如何自定义项目的Maven archetype plugin，博主将会
在后续的文章介绍。在此次博文将是记录如果去掉你手动在intellij中添加
的archetype plugin。</p>

<p>mac版本，你可以找到文件：</p>

<pre><code>~/Library/Caches/IntelliJIdea&lt;version&gt;/Maven/Indices/UserArchetypes.xml
</code></pre>

<p>然后用你喜欢的编辑器打开它(例如博主当前使用的Atom)：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;archetypes&gt;
&lt;archetype groupId="com.github.greengerong" artifactId="components-archetype" version="1.0.0" /&gt;
&lt;/archetypes&gt;
</code></pre>

<p>你可以在xml的archetypes节点增加或者删除修改配置，然后重新启动你的Intellij。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ng-template寄宿方式]]></title>
    <link href="http://greengerong.github.io/blog/2014/03/15/ng-html2js-maven-plugins-for-java/"/>
    <updated>2014-03-15T13:14:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/03/15/ng-html2js-maven-plugins-for-java</id>
    <content type="html"><![CDATA[<p>如果你是一个angular的开发者的话，对于ng-html2js你应该
很熟悉。对于angular的指令，我们经常需要定义模板(
directive template/templateUrl),你可以选择讲html page
放在真正的的web容器中寄宿，也可以选择angular的ng-template
放在view的page之上，抑或也可以讲html打成一个js文件和directive
的js文件合并在一起发布。</p>

<ul>
<li><p>对于直接寄宿在web容器.</p>

<p>这很简单，直接放在jetty，tomcat，iis，
抑或node express public目录下。这里没什么可以多说的，所以我们跳过。</p></li>
<li><p>angular ng-template模板:</p>

<p>代码如下：</p>

<pre><code>    &lt;script type="text/ng-template" id="/tpl.html"&gt;

      Content of the template.

    &lt;/script&gt;
</code></pre>

<p>这将会在angular的compile时候解析，angular将会把它放在angular的$templateCache
中。</p>

<p>对于<a href="http://docs.angularjs.org/api/ng/service/$templateCache">$templateCache</a>，如其名
这是angular对模板的缓存的service。在启用了$templateCache的$http ajax请求，
angular将会首先在$templateCache中查找是否有对此url的缓存：</p>

<pre><code>      $templateCache.get('templateId.html')
</code></pre>

<p>如果存在缓存，着angular将会直接用缓存中获取，并不会在发送一次ajax。
对于所有的指令和模板angular默认启用了templateCache。</p>

<p>这在于angular所处理的模式开发很有关系的。我们经常提到的SPA(single page application)
我们把view的显示处理等表现逻辑推到了前段，而后端提供只与数据有关的soap/restful service
这样对于一个应用程序业务逻辑来说不变的是处理数据的业务逻辑，这份逻辑你可以共享在不管前端是mobile
app 或者是浏览器，或者winform gui的图形化程序，因为对于同一个业务这是不变的。将view的分离推到各自的客户端
将是更好的解决方案。</p>

<p>回到angular $templateCahce，对于一个应用程序view的分离，之后在对于当前的应用程序平台，html/js/css
这类资源是静态的，最好是不变的，那么你可以自由的缓存在客户端，减少服务器的交互，以及为了更大的性能追求，我们
可以把这类静态资源放在Nginx这里反向代理或者CDN上，让我们的程序获取更大的性能和扩展空间。</p></li>
<li><p>回到angular的ng-html2js：</p>

<p>有了上边对于$templateCache的理解，那你应该很容易理解html2js的方式了，与ng-template不同的
是ng-template是angular在compile的时候自动加入$templateCache的，html2js是我们在开发
时候利用build自己放入$templateCache。</p>

<pre><code>  angular.module('myApp', [])
  .run(function($templateCache) {
      $templateCache.put('templateId.html',
          'This is the content of the template'
      );
  });
</code></pre></li>
</ul>


<p>形如上面的输出，将html文件打成一个js文件。</p>

<p>这你也许在angular的单元测试karma unit test中看见过，<a href="https://github.com/karma-runner/karma-ng-html2js-preprocessor"> karma-ng-html2js-preprocessor</a>
，还有如果你也希望在build时候做到如此，那么你可以使用grunt plugin <a href="https://github.com/karlgoldstein/grunt-html2js"> grunt-html2js</a>.</p>

<p>但使用grunt plugin的前提是你在你的项目中引入的grunt build的work flow，那么你可以在gruntfile.js中几行代码轻松的搞定。但是如果
你和我一样使用的是java的maven或者是gradle 作为build，那么你可以尝试博主的maven plugin<a href="https://github.com/greengerong/nghtml2js">nghtml2js</a>.
使用方式如下：</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.greengerong&lt;/groupId&gt;
    &lt;artifactId&gt;nghtml2js&lt;/artifactId&gt;
    &lt;version&gt;0.0.3&lt;/version&gt;
    &lt;configuration&gt;
        &lt;module&gt;demo.template&lt;/module&gt;
        &lt;html&gt;${project.basedir}&lt;/html&gt;
        &lt;extensions&gt;
            &lt;param&gt;tpl&lt;/param&gt;
            &lt;param&gt;html&lt;/param&gt;
        &lt;/extensions&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;nghtml2js&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;run&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks持续集成平台GO开源了]]></title>
    <link href="http://greengerong.github.io/blog/2014/02/28/ci-tools-go-open-source/"/>
    <updated>2014-02-28T22:11:34+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/02/28/ci-tools-go-open-source</id>
    <content type="html"><![CDATA[<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk1lR8OseSHNcsAhWTlYia2Ld59ibrwIjwibliaI2ZkghyDhjIibhyl1sqNfA/0" alt="go" /></p>

<p>ThoughtWorks 持续集成平台Go最近宣布开源了。其基于Apache 2.0 开源协议。</p>

<p>Go下载地址为<a href="http://www.go.cd/download/">http://www.go.cd/download/</a>.</p>

<p>下面是几张来自官方的视图：</p>

<p>GO流程图：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkhIEdu6Sm9BeCTvC3ianeMpWF3ibl9uE9GnKiaZhfucjenfpVHdj7ia8dug/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkhIEdu6Sm9BeCTvC3ianeMpWF3ibl9uE9GnKiaZhfucjenfpVHdj7ia8dug/0" /></p>

<p>GO截面图：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk0g8A2LFhCSqo9sV213sbrmIPYx6mico1LOqcPYLgyJgCQce9OibHsRog/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk0g8A2LFhCSqo9sV213sbrmIPYx6mico1LOqcPYLgyJgCQce9OibHsRog/0" /></p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkkYYPxPhy3ZSQugDEvuZkQwXockGPDF75Oia3yvoKAOAFxmHayDYNMIg/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKkkYYPxPhy3ZSQugDEvuZkQwXockGPDF75Oia3yvoKAOAFxmHayDYNMIg/0" /></p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk2gON7AZ80zhsSlHZVy8EtT9NUqX3Z6dholdgMgFsyltondWYL2dxlg/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKk2gON7AZ80zhsSlHZVy8EtT9NUqX3Z6dholdgMgFsyltondWYL2dxlg/0" /></p>

<p>GO的版本：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKklp3IsiaGMqDswMeKSEno8JmdnasOkwt3bWwQoAmjiaIoeCX2du2SWFlQ/0" alt="http://mmbiz.qpic.cn/mmbiz/aaVJqS7LaMKkxxgkibo01eichwVuOmHzKklp3IsiaGMqDswMeKSEno8JmdnasOkwt3bWwQoAmjiaIoeCX2du2SWFlQ/0" /></p>

<ul>
<li> <a href="http://www.thoughtworks.com/cn/news/go-continuous-delivery-now-available-as-free-open-source#rd?sukey=910132d0e6ac3190d1e520e951a74f6cec37de934f95c61f6c7069ae1e806ed7d1df5175970e3f6b8a2057979d44cc7c">Thoughtworks官方的宣布文章</a></li>
<li> 你也可以在ThoughtWorks中国微信雷小达看到:<a href="http://mp.weixin.qq.com/s?__biz=MjM5MjY3OTgwMA==&amp;mid=200062098&amp;idx=1&amp;sn=25198a84122904cd113ef010637d27ed&amp;uin=MjA0MjY0NDk0MA%3D%3D">GO！我们开源了！</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微软开放了.NET 4.5.1的源代码]]></title>
    <link href="http://greengerong.github.io/blog/2014/02/28/net-4-dot-5-1-ms-rsl-source/"/>
    <updated>2014-02-28T12:25:25+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/02/28/net-4-dot-5-1-ms-rsl-source</id>
    <content type="html"><![CDATA[<p><a href="http://referencesource.microsoft.com/">.NET Reference Source</a>发布了beta版，可以在线浏览.NET Framework 4.5.1的源代码，并且可以通过配置，<a href="http://referencesource-beta.microsoft.com/setup.html">在Visual Studio 2013中调试.NET Framework</a>。</p>

<p>.NET Framework团队的项目经理Alok Shriram在<a href="http://blogs.msdn.com/b/dotnet/archive/2014/02/24/a-new-look-for-net-reference-source.aspx">.NET Framework的博客</a>中撰文介绍了最新的.NET Reference Source。它不仅可以用来浏览最新的.NET代码，而且通过强大的<a href="http://msdn.com/roslyn">Roslyn</a>，改善了“Go to Defination”和“Finding Reference”的在线体验。此外，开发者还可以下载整个源代码包，在Visual Studio中打开并浏览。使用Schabse Laks编写的<a href="http://visualstudiogallery.msdn.microsoft.com/f89b27c5-7d7b-4059-adde-7ccc709fa86e">插件</a>，可以在VS中直接导航到该网站。</p>

<p>通过简单的配置，开发者可以在Visual Studio中单步调试.NET Framework 4.5.1及其后续补丁和更新。这无疑是广大开发者<a href="http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/4083118-allow-developers-to-step-through-net-framework-so">翘首以盼的功能</a>。启动Visual Studio 2013，打开Tools &ndash;> Options &ndash;> Debugging &ndash;> General菜单，进行如下配置：</p>

<ul>
<li>   禁用Just My Code</li>
<li>   禁用Step over properties and operators</li>
<li>   禁用Require source files to exactly match the original version</li>
<li>   选中Enable .NET Framework source stepping</li>
<li>   选中Enable source server support</li>
</ul>


<p>这样，开发者在调试代码时，就可以通过F11直接进入.NET代码。</p>

<p>这并不是微软第一次开放.NET Framework的源代码。早在2007年，他们就第一次公布了<a href="http://weblogs.asp.net/scottgu/archive/2007/10/03/releasing-the-source-code-for-the-net-framework-libraries.aspx">.NET 3.5的源代码</a>并支持Visual Studio调试。并且对于后续的4.0和4.5，也都提供了相应的源代码包。但当框架升级时，这些旧的包就变得毫无价值了。从4.5.1开始，.NET Framework团队彻底改变了符号索引和发布的过程，使其与构建过程同步，这样在新版本发布时，相应的PDB文件也会从Reference Source网站进行更新。</p>

<p>目前的beta站点只是临时的，届时将会取代现在的旧站点。后续微软也会将还未公布源代码的程序集逐步添加进来。新的.NET Reference Source许可协议回归到了<a href="http://referencesource-beta.microsoft.com/license.html">MS-RSL</a>，这也使得像Mono这样的团队可以放心大胆地使用。</p>

<p>正如Scott Hanselman所说：微软可能并不是开源的，但却绝对是源代码开放的。</p>

<p>Infoq原文链接:<a href="http://www.infoq.com/cn/news/2014/02/microsoft-net-source-code?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global&amp;utm_reader=feedly">http://www.infoq.com/cn/news/2014/02/microsoft-net-source-code?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global&amp;utm_reader=feedly</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nodejs获取客户端IP Address]]></title>
    <link href="http://greengerong.github.io/blog/2014/02/28/nodejs-get-client-ip/"/>
    <updated>2014-02-28T00:27:22+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/02/28/nodejs-get-client-ip</id>
    <content type="html"><![CDATA[<p>在网上看见很多问node.js如何获取客户端IP,所以记录下来，以供大家参考。</p>

<pre><code>    function getClientIp(req) {
        return req.headers['x-forwarded-for'] ||
        req.connection.remoteAddress ||
        req.socket.remoteAddress ||
        req.connection.socket.remoteAddress;
    };
</code></pre>

<p>代码，第一段判断是否有反向代理IP(头信息：x-forwarded-for)，在判断connection的远程IP，以及后端的socket的IP。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细说angular Form addControl方法]]></title>
    <link href="http://greengerong.github.io/blog/2014/02/21/angular-form-addControl/"/>
    <updated>2014-02-21T17:24:37+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/02/21/angular-form-addControl</id>
    <content type="html"><![CDATA[<p>在本篇博文中，我们将接触angular的验证。angular的验证是由form 指令和ngModel协调完成的。今天博主在这里想要说的是在验证在的一种特殊情况，当验证控件没有没有name属性这是不会被form捕获的。或者是你希望在ngRepeat中使用动态表达式。</p>

<p>下面且让我们先来从angular源码中看起如下：</p>

<p>首先是ngModel：</p>

<pre><code>    var ngModelDirective = function() {
      return {
        require: ['ngModel', '^?form'],
        controller: NgModelController,
        link: function(scope, element, attr, ctrls) {
          // notify others, especially parent forms

          var modelCtrl = ctrls[0],
              formCtrl = ctrls[1] || nullFormCtrl;

          formCtrl.$addControl(modelCtrl);

          scope.$on('$destroy', function() {
            formCtrl.$removeControl(modelCtrl);
          });
        }
      };
    };
</code></pre>

<p>从上面我们能够看出ngModel指令会在编译时期的post link阶段会通过form的 <strong>addControl</strong>方法把自己的controller注册到父节点上的form的formController中。</p>

<p>在看看ngModel controller初始化代码：</p>

<pre><code>    var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',
        function($scope, $exceptionHandler, $attr, $element, $parse) {
     ....
      this.$pristine = true;
      this.$dirty = false;
      this.$valid = true;
      this.$invalid = false;
      this.$name = $attr.name;
</code></pre>

<p>我们从上面我们可以看到 <strong>ngModel的$name属性并不支持表达式计算</strong>。</p>

<p>而FormController的addControl代码则是：</p>

<pre><code>    /**
     * @ngdoc function
     * @name ng.directive:form.FormController#$addControl
     * @methodOf ng.directive:form.FormController
     *
     * @description
     * Register a control with the form.
     *
     * Input elements using ngModelController do this automatically when they are linked.
     */
    form.$addControl = function(control) {
      // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
      // and not added to the scope.  Now we throw an error.
      assertNotHasOwnProperty(control.$name, 'input');
      controls.push(control);

      if (control.$name) {
        form[control.$name] = control;
      }
    };
</code></pre>

<p>从上面我们可以清楚的看见虽然ngModel注册了自己，但是这里也不一定能注册成功，<strong>ngModel心必须有自己的$name才能被注册成功</strong>。</p>

<p>从上面的代码中可以得出，当我们的验证失效的时候，我们可以有一个万能的方式就是 <strong>手动注册到form controller</strong></p>

<h3>手动注册form controller</h3>

<p>为了我写了一个dy-name的插件，其会在post link阶段解析表达式，并把自己注册到父form controller。</p>

<p>如下：</p>

<pre><code>    .directive("dyName", [

        function() {
          return {
            require: "ngModel",
            link: function(scope, elm, iAttrs, ngModelCtr) {
              ngModelCtr.$name = scope.$eval(iAttrs.dyName)
              var formController = elm.controller('form') || {
                $addControl: angular.noop
              };
              formController.$addControl(ngModelCtr);

              scope.$on('$destroy', function() {
                formController.$removeControl(ngModelCtr);
              });

            }
          };
        }
      ])
</code></pre>

<p>使用方式：</p>

<pre><code>    &lt;div ng-repeat="item in demo.fields"&gt;
      &lt;div class="control-group"&gt;
        &lt;label class="control-label"&gt; : &lt;/label&gt;
        &lt;div class="controls"&gt;
          &lt;input type="number"  dy-name="item.field" ng-model="demo.data[item.field]" min="10" max="500" ng-required="true"/&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre>

<p>其实实现为在post link阶段获取到form controller，并把自己注册到form controller，而且为了消除对象的级联，将会在scope摧毁阶段remove自己。</p>

<p>其效果请看<a href="http://jsbin.com/docow/1/edit?html,js,output">jsbin $addControl</a></p>

<p><strong>注意</strong>:在formController.$addControl方法的参数传入的不是界面控件，而是ngModelController.或者名字为$addController更合适。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angularjs中文版本开发指南发布]]></title>
    <link href="http://greengerong.github.io/blog/2014/02/16/angularjs-chinese-guide-public/"/>
    <updated>2014-02-16T02:02:17+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/02/16/angularjs-chinese-guide-public</id>
    <content type="html"><![CDATA[<p><img src="http://angularjs.org/img/AngularJS-large.png" alt="http://angularjs.org/img/AngularJS-large.png" /></p>

<p>从本人开始在写关于Angularjs的文章开始，也算是见证了Angularjs在国内慢慢的火起来，如今的Angularjs正式如日中天。想知道为什么Angularjs会这么火，请移步<a href="http://www.cnblogs.com/whitewolf/p/angularjs-remove-unused-watch.html">angularjs移除不必要的$watch</a>.</p>

<p>也是一次偶然的机会，在Angular.js中文社区群里相遇一群Angular的爱好者，在一次巧妙的交谈，大家对于Angular官方的Guide最新版本没有中文版本表示无助，所以为了诸君更好的了解学习Angularjs，大家临时组织了一个Angular 开发指南翻译团队。</p>

<p>在经过一段时间的协调和大家付出工作之外的业余时间，如今Angularjs的中文本学习指南终于上线出炉</p>

<p>地址为：</p>

<pre><code>[http://www.ngnice.com/](http://www.ngnice.com/)
</code></pre>

<p>在翻译过程中大家力求准确，但也并不是逐字翻译，也会加上一些&#8221;译者注&#8221;之类，让大家能够更好的学习，使用Angularjs。同时在Angular开发指南首页我们也收集了很多很好的Angularjs学习资料供大家学习。</p>

<p>最后虽然大家都很努力的翻译力求精准，但也会难免有些issue，请不辞指出，可以提交在github repo issue,或者本文后边加上评论。</p>

<p>同时在本博客中也会很多关于Angularjs实践方面的博客，欢迎大家不辞指教。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Angularjs ngOptions加上index解决方案]]></title>
    <link href="http://greengerong.github.io/blog/2014/02/15/index-for-ng-options/"/>
    <updated>2014-02-15T21:43:06+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/02/15/index-for-ng-options</id>
    <content type="html"><![CDATA[<p>今天在Angularjs交流群中有位童学问道如何为Angular select的ngOptions像Angularjs的ngRepeat一样加上一个索引$index.</p>

<p>其实对于这个问题来说Angular本身并未提供$index之类的变量供使用。但是也不是说对于这个问题我们就没有解决方案。</p>

<p>把这个问题换成角度来看,我们所需要的就是js数组的下标，所以我们如果我们能够在对象上加入下标，使用表达式作为option的label就能解决了。</p>

<p>但是第一印象让我想起的是js数组本来就是一个key/value的对象，只是key为数组下标而已，所以有了如下之设计：</p>

<p>html:</p>

<pre><code>  &lt;pre&gt;&lt;/pre&gt;

  &lt;select  ng-model="a" ng-options="value.field as getDesc1(key,value) for (key,value) in t"&gt;&lt;/select&gt;
</code></pre>

<p>  js:</p>

<pre><code>$scope.getDesc1 = function(key, value) {
    return (parseInt(key, 10) + 1) + "-&gt;" + value.field;
};
</code></pre>

<p>可是不幸的是如果对于JavaScript你若将他作为key/value对象那么key将是无序的所以，出现了无序的下标如下：</p>

<pre><code>&lt;select ng-model="a" ng-options="l.field as getDesc1(key,value) for (key,value) in t " class="ng-valid ng-dirty"&gt;
  &lt;option value="0"  &gt;1-&amp;gt;jw_companyTalent&lt;/option&gt;
  &lt;option value="1"  &gt;2-&amp;gt;jw_reportgroup&lt;/option&gt;
  &lt;option value="10" &gt;11-&amp;gt;jw_ads&lt;/option&gt;
  &lt;option value="11" &gt;12-&amp;gt;jw_jobcomment&lt;/option&gt;
  &lt;option value="12" &gt;13-&amp;gt;jw_companyInfo&lt;/option&gt;
  ....
&lt;/select&gt;
</code></pre>

<p>所以这样是无法解决的。还好博主还有一招，ngOptions支持Angularjs的filter，所以我们可以对数据源对象上加上一个order字段标示下标作为序号。并且你可以在一个2年前的Angular的issue中看到Angular已经fix issue，option会对数组进行按下标顺序生成。</p>

<p>html:</p>

<pre><code>&lt;pre&gt;&lt;/pre&gt;

&lt;select  ng-model="b" ng-options="l.field as getDesc(l) for l in t | index "&gt;&lt;/select&gt;
</code></pre>

<p>js:</p>

<pre><code>    var app = angular.module('plunker', []);

    app.controller('MainCtrl', function($scope) {
      $scope.t = [{
        "field": "jw_companyTalent"
      }, {
        "field": "jw_reportgroup"
      }];
      $scope.getDesc = function(l) {
        return l.order + "-&gt;" + l.field;
      };
    }).filter("index", [
      function() {
        return function(array) {
          return (array || []).map(function(item, index) {
            item.order = index + 1;
            return item;
          });
        };
      }
    ]);
</code></pre>

<p>这下option是按照有序的生成，最后我们终于能完美解决了,所以本文也将收尾。在最后在附上可运行的demo<a href="http://plnkr.co/edit/tRxzOT?p=preview">plnkr ngOptions index</a>;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular ngClick阻止冒泡,默认行为]]></title>
    <link href="http://greengerong.github.io/blog/2014/02/11/angular-ngclick-stoppropagation/"/>
    <updated>2014-02-11T22:27:29+08:00</updated>
    <id>http://greengerong.github.io/blog/2014/02/11/angular-ngclick-stoppropagation</id>
    <content type="html"><![CDATA[<p>这其实是一个很简单的问题，如果你认真查看过Angular官方的API文档，本来不想记录的。但是这个问题不止一次的被人问起，所以今天在记录在这里。</p>

<p>在Angular中已经对一些ng事件如ngClick,ngBlur,ngCopy,ngCut,ngDblclick&hellip;中加入了一个变量叫做$event.</p>

<p>如ngClick在官方文档是这么描述的：</p>

<pre><code>Expression to evaluate upon click. (Event object is available as $event)
</code></pre>

<p>在查看Angular代码<a href="https://github.com/angular/angular.js/blob/a68624444afcb9e3796b1a751cf3817cafd20240/src/ng/directive/ngEventDirs.js">ngEventDirs.js</a>:</p>

<pre><code>    var ngEventDirectives = {};
    forEach(
      'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
      function(name) {
        var directiveName = directiveNormalize('ng-' + name);
        ngEventDirectives[directiveName] = ['$parse', function($parse) {
          return {
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName]);
              return function(scope, element, attr) {
                element.on(lowercase(name), function(event) {
                  scope.$apply(function() {
                    fn(scope, {$event:event});
                  });
                });
              };
            }
          };
        }];
      }
    );
</code></pre>

<p>在上边代码我们可以得到两个信息：</p>

<ol>
<li>Angular支持的event： click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste</li>
<li>Angular在执行事件函数时候传入了一个名叫$event的常量，该常量即代表当前event对象，如果你在Angular之前引入了jQuery那么这就是jQuery的event.</li>
</ol>


<p>所以我们可以利用event的stopPropagation来阻止事件的冒泡：如下代码：<a href="http://jsbin.com/delow/3/watch?html,js,output">jsbin</a></p>

<p>html 代码</p>

<pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html id="ng-app" ng-app="app"&gt;
    &lt;head&gt;
    &lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"&gt;&lt;/script&gt;
      &lt;meta charset="utf-8"&gt;
      &lt;title&gt;JS Bin&lt;/title&gt;
    &lt;/head&gt;
    &lt;body ng-controller="demo as d"&gt;
       &lt;div ng-click="d.click('parent',$event)"&gt;
         given some text for click
         &lt;hr&gt;
         &lt;input type="checkbox" ng-model="d.stopPropagation" /&gt;Stop Propagation ?
         &lt;hr&gt;
         &lt;button type="button" ng-click="d.click('button',$event)"&gt;button&lt;/button&gt;

       &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;             
</code></pre>

<p>js 代码</p>

<pre><code>angular.module("app",[])
.controller("demo",[function(){
  var vm = this;

  vm.click = function(name,$event){
    console.log(name +" -----called");
    if(vm.stopPropagation){
      $event.stopPropagation();
    }
  };

  return vm;
}]);
</code></pre>

<p>可以在<a href="http://jsbin.com/delow/3/watch?html,js,output">jsbin</a>查看效果。</p>

<p>首先打开你的控制台，然在没选中Stop Propagation的情况下点击button你将会看见两条log记录，相反选中后则只会出现button的log信息。</p>

<p>希望大家已经明白了，不要再问这类问题了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ngCloak 实现 Angular 初始化闪烁最佳实践]]></title>
    <link href="http://greengerong.github.io/blog/2013/12/27/angular-ngcloak-new/"/>
    <updated>2013-12-27T00:00:00+08:00</updated>
    <id>http://greengerong.github.io/blog/2013/12/27/angular-ngcloak-new</id>
    <content type="html"><![CDATA[<p>在做angular的SPA开发时，我们经常会遇见在如Chrome这类能够快速解析的浏览器上出现表达式( {{ express }}  ),或者是模块(div)的闪烁。对于这个问题由于JavaScript去操作DOM，都会等待DOM加载完成（DOM ready）。对于angular会在DOM ready完会才回去解析html view Template，所以对于Chrome这类快速的浏览器你会看见有闪烁的情况出现。而对于IE7，8这类解析稍慢的浏览器大部分情况下是不会出现这个问题的。</p>

<p>在angular中为我们提供了ng-cloak来实现纺织闪烁的方案，我们只需要在需要的地方加上ng-cloak。同时对于bing文字({{ express }} )我们也可以改为ng-bind来实现避免。</p>

<pre><code> &lt;div id="template1" ng-cloak&gt;hello&lt;/div&gt;
 &lt;div id="template2" ng-cloak class="ng-cloak"&gt; {{ 'hello IE7' }}  &lt;/div&gt;
 &lt;div id="template2" ng-bing="'hello IE7'"&gt;&lt;/div&gt;
</code></pre>

<p>angular将ng-cloak实现为一个directive，并会在初始化的时候在DOM的heade增加一行css代码，如下：</p>

<pre><code>&lt;style type="text/css"&gt;@charset "UTF-8";[ng\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\:form{display:block;}.ng-animate-start{clip:rect(0,auto,auto,0);-ms-zoom:1.0001;}.ng-animate-active{clip:rect(-1px,auto,auto,0);-ms-zoom:1;}
&lt;/style&gt;
</code></pre>

<p>从上面我们可以看见angular将带有ng-clock的的元素设置为display:none，隐藏掉，在等到angular解析到带有ng-clock的节点时候，会把attribute和class同时remove掉，这样就可以实现防止节点的闪烁。</p>

<pre><code>var ngCloakDirective = ngDirective({
      compile: function(element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
      }
});
</code></pre>

<p>在angular-bootstrap.js中会看见这样的代码去增加前面所说的css：</p>

<pre><code>  document.write('&lt;link rel="stylesheet" type="text/css" href="' + serverPath + '../css/angular.css"/&gt;');
</code></pre>

<p>好像闪烁的问题好像已经能够被我解决了，恩是否是这样的，理论也改如此，但是现实是残酷的，我们的感性认识经常会被现实一记重重的耳光，我们才能很更深入全面的思考，如果浏览器的速度比angular在head中加入css的速度还快呢？我在给公司的一个项目组解决这个闪烁的问题的时候就遇见了这个问题。怎么办呢？那我们只能使出我们必杀技，自己把css加入我们的css文件引入heade，启动加载，ok这样就可以完美解决了。(如果你也遇见了加了ng-cloak还不起作用的话，那么试试直接引入css文件吧)</p>

<p>到这里关于ng-cloak的原理和解决方案已经完成，欢迎继续关注angular的后续经验篇分享。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular Controller as Syntax vs Scope]]></title>
    <link href="http://greengerong.github.io/blog/2013/12/24/angular-controller-as-syntax-vs-scope/"/>
    <updated>2013-12-24T00:00:00+08:00</updated>
    <id>http://greengerong.github.io/blog/2013/12/24/angular-controller-as-syntax-vs-scope</id>
    <content type="html"><![CDATA[<p>今天要和大家分享的是angular从1.2版本开始带来了新语法Controller as。再次之前我们对于angular在view上的绑定都必须使用直接的scope对象，对于controller来说我们也得必须注入$scope这个service。如下：</p>

<pre><code>angular.module("app",[])
.controller("demoController",["$scope",function($scope){
    $scope.title = "angualr";
 }])

&lt;div ng-app="app" ng-controller="demoController"&gt;
    hello : {{title}} !
&lt;/div&gt;
</code></pre>

<p>有些人觉得即使这样我们的controller还是不够POJO，以及对于coffescript爱好者不足够友好，所以在angular在1.2给我带来了一个新的语法糖这就是本文将要说的controller as的语法糖，修改上面的demo将会变成：</p>

<pre><code>angular.module("app",[])
.controller("demoController",[function(){
    this.title = "angualr";
}])

&lt;div ng-app="app" ng-controller="demoController as demo"&gt;
     hello : {{demo.title}} !
&lt;/div&gt;
</code></pre>

<p>这里我们可以看见现在controller不再有$scope的注入了，感觉controller就是一个很简单的平面的JavaScript对象了，不存在任何的差别了。再则就是view上多增加了个demoController as demo，给controller起了一个别名，在此后的view模板中靠这个别名来访问数据对象。</p>

<p>或许看到这里你会问为什么需要如此啊，不就是个语法糖而已，先别着急，我们会在后边分析$scope和他的差别。在此之前我们先来看看angular源码的实现这样才会有助于我们的分析：</p>

<p>下面是一段来自angular的code：在1499行开始(行数只能保证在写作的时候有效)</p>

<pre><code>  if (directive.controllerAs) {
          locals.$scope[directive.controllerAs] = controllerInstance;
   }
</code></pre>

<p>如果你希望看更完全的code请猛击这里<a href="https://github.com/angular/angular.js/blob/c7a1d1ab0b663edffc1ac7b54deea847e372468d/src/ng/compile.js">https://github.com/angular/angular.js/blob/c7a1d1ab0b663edffc1ac7b54deea847e372468d/src/ng/compile.js</a>.</p>

<p>从上面的代码我们能看见的是：angular只是把controller这个对象实例以其as的别名在scope上创建了一个新的对象属性。靠，就这么一行代码搞定！</p>

<p>先别急，既然是语法糖，那么它肯定有他出现的原因，让我们来和直接用$scope对比下：</p>

<p>在此文之前我在angularjs的群中和大家讨论了下我的看法，得到大家不错的反馈，所以有了本文，记录和分享下来。</p>

<p>我规定对于controller as的写法如下：</p>

<pre><code>angular.module("app",[])
 .controller("demoController",[function(){
        var vm = this;

        vm.title = "angualr";

        return vm;
 }])
</code></pre>

<p>其优势为：</p>

<ol>
<li>定义vm这样会让我们更好的避免JavaScript的this的坑。</li>
<li>如果某个版本的angular不再支持controller as,可以轻易的注入$scope,修改为 var vm = $scope;</li>
<li>因为不再注入$scope了，controller更加的POJO，就是一个很普通的JavaScript对象。</li>
<li>也因为没有了$scope，而controller实例将会成为scope上的一个属性，所以在controller中我们再也不能使用$watch,$emit,$on之类的特殊方法，因为这些东西往往不该出现在controller中的，给大家一个警告，更好的控制。但是一旦如果没办法必须用的话，可以在征得项目组一致同意，将此controller退回$scope.</li>
<li>因为controller实例将会只是$scope的一个属性，所以view模板上的所有字段都会在一个引用的属性上，这可以避开JavaScript原型链继承对于值类型的坑。参加<a href="https://github.com/angular/angular.js/wiki/Understanding-Scopes">https://github.com/angular/angular.js/wiki/Understanding-Scopes</a>.</li>
<li>controller as 对于 coffescript,liveScript更友好。
7.模板上定义的每个字段方法都会在scope寄存在controller as别名上的引用上，所以在controller继承中，不会在出现命名冲突的问题。</li>
</ol>


<p>注释:对于route，也有个controllerAs的属性可以设置，下面代码来之angular doc文档：</p>

<pre><code>    angular.module('ngViewExample', ['ngRoute', 'ngAnimate'],
     function($routeProvider, $locationProvider) {
    $routeProvider.when('/Book/:bookId', {
      templateUrl: 'book.html',
      controller: BookCntl,
      controllerAs: 'book'
    });
    $routeProvider.when('/Book/:bookId/ch/:chapterId', {
      templateUrl: 'chapter.html',
      controller: ChapterCntl,
      controllerAs: 'chapter'
    });

    // configure html5 to get links working on jsfiddle
         $locationProvider.html5Mode(true);
     });
</code></pre>

<p>今天就到这里，谢谢。</p>
]]></content>
  </entry>
  
</feed>
