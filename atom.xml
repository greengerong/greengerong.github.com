<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[破狼 Blog]]></title>
  <link href="http://greengerong.github.io/atom.xml" rel="self"/>
  <link href="http://greengerong.github.io/"/>
  <updated>2015-11-11T21:00:57+08:00</updated>
  <id>http://greengerong.github.io/</id>
  <author>
    <name><![CDATA[破 狼]]></name>
    <email><![CDATA[grzx2210@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Angular移除不必要的$watch之性能优化]]></title>
    <link href="http://greengerong.github.io/blog/2015/11/11/angular-remove-unnecessary-%24watch-to-improve-performance/"/>
    <updated>2015-11-11T20:20:58+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/11/11/angular-remove-unnecessary-$watch-to-improve-performance</id>
    <content type="html"><![CDATA[<p><img src="http://greengerong.github.io/images/blog_img/Angular-apply-and-%E6%B5%8F%E8%A7%88%E5%99%A8-event-loop.png" alt="Angular-apply-and-浏览器-event-loop" /></p>

<p>双向绑定是Angular的核心概念之一，它给我们带来了思维方式的转变：不再是DOM驱动，而是以Model为核心，在View中写上声明式标签。然后，Angular就会在后台默默的同步View的变化到Model，并将Model的变化更新到View。</p>

<p>双向绑定带来了很大的好处，但是它需要在后台保持一只“眼睛”，随时观察所有绑定值的改变，这就是Angular 1.x中“性能杀手”的“脏检查机制”($digest)。可以推论：如果有太多“眼睛”，就会产生性能问题。在讨论优化Angular的性能之前，笔者希望先讲解下Angular的双向绑定和watchers函数。</p>

<h3>双向绑定和watchers函数</h3>

<p>为了能够实现双向绑定，Angular使用了$watch API来监控$scope上的Model的改变。Angular应用在编译模板的时候，会收集模板上的声明式标签 —— 指令或绑定表达式，并链接（link）它们。这个过程中，指令或绑定表达式会注册自己的监控函数，这就是我们所说的watchers函数。</p>

<p>下面以我们常见的Angular表达式（<code>{{}}</code>）为例。</p>

<p>HTML：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre class='green'><code class='html'><span class='line'><span class="nt">&lt;body</span> <span class="na">ng-app=</span><span class="s">&quot;com.ngnice.app&quot;</span> <span class="na">ng-controller=</span><span class="s">&quot;DemoController as demo&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div&gt;</span>hello : {{demo.count}}<span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">&quot;button&quot;</span> <span class="na">ng-click=</span><span class="s">&quot;demo.increase ();&quot;</span><span class="nt">&gt;</span>increase ++<span class="nt">&lt;/button&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>JavaScript：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;com.ngnice.app&#39;</span><span class="p">)</span>
</span><span class='line'><span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s1">&#39;DemoController&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">vm</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">vm</span><span class="p">.</span><span class="nx">increase</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">vm</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">vm</span><span class="p">;</span>
</span><span class='line'><span class="p">}]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个自增长计数器的例子，在上面的代码我们用了Angular表达式（<code>{{}}</code>）。表达式为了能在Model的值改变的时候你能及时更新View，它会在其所在的$scope（本例中为DemoController）中注册上面提到的watchers函数，监控count属性的变化，以便及时更新View。</p>

<p>上例中在每次点击button的时候，count计数器将会加1，然后count的变化会通过Angular的$digest过程同步到View之上。在这里它是一个单向的更新，从Model到View的更新。如果处理一个带有ngModel指令的input交互控件，则在View上的每次输入都会被及时更新到Model之上，这里则是反向的更新，从View到Model的更新。</p>

<p>Model数据能被更新到View是因为在背后默默工作的$digest循环（“脏检查机制”）被触发了。它会执行当前scope以及其所有子scope上注册的watchers函数，检测是否发生变化，如果变了就执行相应的处理函数，直到Model稳定了。如果这个过程中发生过变化，浏览器就会重新渲染受到影响的DOM来体现Model的变化。</p>

<p>在Angular表达式（<code>{{}}</code>）背后的源码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">collectDirectives</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">directives</span><span class="p">,</span> <span class="nx">attrs</span><span class="p">,</span> <span class="nx">maxPriority</span><span class="p">,</span> <span class="nx">ignoreDirective</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">nodeType</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">nodeType</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">attrsMap</span> <span class="o">=</span> <span class="nx">attrs</span><span class="p">.</span><span class="nx">$attr</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">match</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">className</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">nodeType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class='line'>      <span class="cm">/* Element */</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span><span class='line'>      <span class="cm">/* Text Node */</span>
</span><span class='line'>      <span class="nx">addTextInterpolateDirective</span><span class="p">(</span><span class="nx">directives</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">);</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">8</span><span class="o">:</span>
</span><span class='line'>      <span class="cm">/* Comment */</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">directives</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">byPriority</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">directives</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">addTextInterpolateDirective</span><span class="p">(</span><span class="nx">directives</span><span class="p">,</span> <span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">interpolateFn</span> <span class="o">=</span> <span class="nx">$interpolate</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">interpolateFn</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">directives</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span><span class='line'>      <span class="nx">priority</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">compile</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">textInterpolateCompileFn</span><span class="p">(</span><span class="nx">templateNode</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// when transcluding a template that has bindings in the root</span>
</span><span class='line'>        <span class="c1">// then we don&#39;t have a parent and should do this in the linkFn</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">templateNode</span><span class="p">.</span><span class="nx">parent</span><span class="p">(),</span>
</span><span class='line'>          <span class="nx">hasCompileParent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nx">hasCompileParent</span><span class="p">)</span> <span class="nx">safeAddClass</span><span class="p">(</span><span class="nx">templateNode</span><span class="p">.</span><span class="nx">parent</span><span class="p">(),</span> <span class="s1">&#39;ng-binding&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kd">function</span> <span class="nx">textInterpolateLinkFn</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">parent</span><span class="p">(),</span>
</span><span class='line'>            <span class="nx">bindings</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="s1">&#39;$binding&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
</span><span class='line'>          <span class="nx">bindings</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">interpolateFn</span><span class="p">);</span>
</span><span class='line'>          <span class="nx">parent</span><span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="s1">&#39;$binding&#39;</span><span class="p">,</span> <span class="nx">bindings</span><span class="p">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasCompileParent</span><span class="p">)</span> <span class="nx">safeAddClass</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="s1">&#39;ng-binding&#39;</span><span class="p">);</span>
</span><span class='line'>          <span class="nx">scope</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="nx">interpolateFn</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">interpolateFnWatchAction</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span><span class='line'>          <span class="p">});</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Angular会在compile阶段收集View模板上的所有Directive。Angular表达式会被解析成一种特殊的指令：<code>addTextInterpolateDirective</code>。到了link阶段，就会利用scope.$watch的API注册我们在上面提到的watchers函数：它的求值函数为$interpolate对绑定表达式进行编译的结果，监听函数则是用新的表达式计算值去修改DOM Node的nodeValue。可见，在View中的Angular表达式，也会成为Angular在$digest循环中watchers的一员。</p>

<p>在上面代码中，还有一部分是为了给调试器用的。它会在Angular表达式所属的DOM节点加上名为‘ng-binding’的调试类。类似的调试类还有‘ng-scope’，‘ng-isolate-scope’等。在Angular 1.3中我们可以使用compileProvider服务来关闭这些调试信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">config</span><span class="p">([</span><span class="s1">&#39;$compileProvider&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">$compileProvider</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// disable debug info</span>
</span><span class='line'>  <span class="nx">$compileProvider</span><span class="p">.</span><span class="nx">debugInfoEnabled</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
</span><span class='line'><span class="p">}]);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>其它指令中的watchers函数</h3>

<p>不仅Angular的表达式会使用$scope.$watch API添加watchers，Angular内置的大部分指令也一样，下面再举几个常用的Angular指令。</p>

<p>ngBind：它和Angular表达式很类似，都是绑定特定表达式的值到DOM的内容，并保持与scope的同步。不同之处在于它需要一个HTML节点并以attribute属性的方式标记。简单来说，我们可以认为Angular表达式就是ngBind的特定语法糖。当然，还是有一点区别的，详情参见“使用技巧”一章的“防止Angular表达式闪烁”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">ngBindDirective</span> <span class="o">=</span> <span class="nx">ngDirective</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">compile</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">templateElement</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">templateElement</span><span class="p">.</span><span class="nx">addClass</span><span class="p">(</span><span class="s1">&#39;ng-binding&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">attr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">element</span><span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="s1">&#39;$binding&#39;</span><span class="p">,</span> <span class="nx">attr</span><span class="p">.</span><span class="nx">ngBind</span><span class="p">);</span>
</span><span class='line'>      <span class="nx">scope</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="nx">attr</span><span class="p">.</span><span class="nx">ngBind</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">ngBindWatchAction</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// We are purposefully using == here rather than === because we want to</span>
</span><span class='line'>        <span class="c1">// catch when value is &quot;null or undefined&quot;</span>
</span><span class='line'>        <span class="c1">// jshint -W041</span>
</span><span class='line'>        <span class="nx">element</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="s1">&#39;&#39;</span> <span class="o">:</span> <span class="nx">value</span><span class="p">);</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里也能清晰的看见$scope.$watch的注册代码：监控器函数为ngBind attribute的值，处理函数则是用表达式计算的结果去更新DOM的文本内容。</p>

<p>ngShow/ngHide: 它们是根据表达式的计算结果来控制显示/隐藏DOM节点的指令。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">ngShowDirective</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;$animate&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$animate</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">attr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">scope</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="nx">attr</span><span class="p">.</span><span class="nx">ngShow</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">ngShowWatchAction</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">$animate</span><span class="p">[</span><span class="nx">toBoolean</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;removeClass&#39;</span> <span class="o">:</span> <span class="s1">&#39;addClass&#39;</span><span class="p">](</span><span class="nx">element</span><span class="p">,</span> <span class="s1">&#39;ng-hide&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">ngHideDirective</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;$animate&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$animate</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">attr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">scope</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="nx">attr</span><span class="p">.</span><span class="nx">ngHide</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">ngHideWatchAction</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">$animate</span><span class="p">[</span><span class="nx">toBoolean</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;addClass&#39;</span> <span class="o">:</span> <span class="s1">&#39;removeClass&#39;</span><span class="p">](</span><span class="nx">element</span><span class="p">,</span> <span class="s1">&#39;ng-hide&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里同样用到了$scope.$watch，到这里你应该明白$watch的工作原理了吧。</p>

<p>再回到上面所提的性能问题。</p>

<p>如果有太多watcher函数，那么在每次$digest循环时，肯定会慢下来，这就是Angular“脏检查机制”的性能瓶颈。在社区中有个经验值，如果超过2000个watcher，就可能感觉到明显的卡顿，特别在IE8这种老旧浏览器上。有什么好的方案可以解决这个问题呢？最明显的方案是：减少$watch,尽量移除不必要的$watch。</p>

<h3>慎用$watch和及时销毁</h3>

<p>要想提高Angular页面的性能，那么在开发的时候，就应该尽量减少显式使用$scope.$watch函数，Angular中的很多内置指令已经能够满足大部分的业务需求。特别是如果能复用ng内置的UI事件指令（ngChange、ngClick&hellip;），那么就不要添加额外的$watch。</p>

<p>对于不再使用的$watch，最好尽早将其释放，$scope.$watch函数的返回值就是用于释放这个watcher的函数，如下面的单次绑定实现（one-time）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;com.ngnice.app&#39;</span><span class="p">)</span>
</span><span class='line'><span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s1">&#39;DemoController&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;$scope&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">vm</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">textWatch</span> <span class="o">=</span> <span class="nx">$scope</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="s1">&#39;demo.updated&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newVal</span><span class="p">,</span> <span class="nx">oldVal</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">newVal</span> <span class="o">!==</span> <span class="nx">oldVal</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">vm</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>      <span class="nx">textWatch</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">vm</span><span class="p">;</span>
</span><span class='line'><span class="p">}]);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>one-time绑定</h3>

<p>在开发中，经常会遇见很多有静态数据构成的页面，如静态的商品、订单等的显示，他们在绑定了数据之后，在当前页面中Model不再会被改变。试想我们需要显示一个培训会议Sessions的预约的展示页面，常规的Angular方案应该是用ng-repeat来产生这个列表：</p>

<p>HTML：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre class='green'><code class='html'><span class='line'><span class="nt">&lt;ul&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">ng-repeat=</span><span class="s">&quot;session in sessions&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;info&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            {{session.name}} - {{session.room}} - {{session.hour}} - {{session.speaker}}
</span><span class='line'>        <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;likes&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            {{session.likes}} likes!
</span><span class='line'>            <span class="nt">&lt;button</span> <span class="na">ng-click=</span><span class="s">&quot;likeSession(session)&quot;</span><span class="nt">&gt;</span>Like it!<span class="nt">&lt;/button&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>JavaScript：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;com.ngnice.app&#39;</span><span class="p">)</span>
</span><span class='line'><span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s1">&#39;MainController&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;$scope&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">$scope</span><span class="p">.</span><span class="nx">sessions</span> <span class="o">=</span> <span class="p">[...];</span>
</span><span class='line'>  <span class="nx">$scope</span><span class="p">.</span><span class="nx">likeSession</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">session</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Like the session</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>用Angular来实现这个需求，很简单。但假设这是一个大型的预约，一天会有300个Sessions。那么这里会产生多少个$watch？这里每个Session有5个绑定，额外的ng-repeat一个。这将会产生1501个$watch。这有什么问题？每次用户“like”一个Session，Angular将会去检查name、room等5个属性是不是被改变了。</p>

<p>问题在于，除了例外的“like”外，所有数据都是静态数据，这是不是有点浪费资源？我们知道数据Model是没有被改变的，既然这样为什么让Angular要去检查是否改变呢？</p>

<p>因此，这里的$watch是没必要的，它的存在反而会影响$digest的性能，但这个$watch在第一次却是必要的，它在初始化时用静态信息填充了我们的DOM结构。对于这类情况，如果能换为单次（one-time）绑定应该是最佳的方案。</p>

<p>Angular中的单次（one-time）绑定是在1.3后引入的。在官方文档描述如下：</p>

<pre class='green'><code>单次表达式在第一次$digest完成后，将不再计算（监测属性的变化）。
</code></pre>

<p>1.3中为Angular表达式（<code>{{}}</code>）引入了新语法，以“::”作为前缀的表达式为one-time绑定。对于上面的例子可以改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre class='green'><code class='html'><span class='line'><span class="nt">&lt;ul&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">ng-repeat=</span><span class="s">&quot;session in sessions&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;info&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            {{::session.name}} - {{::session.room}} - {{::session.hour}} - {{::session.speaker}}
</span><span class='line'>        <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;likes&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            {{session.likes}} likes!
</span><span class='line'>            <span class="nt">&lt;button</span> <span class="na">ng-click=</span><span class="s">&quot;likeSession(session)&quot;</span><span class="nt">&gt;</span>Like it!<span class="nt">&lt;/button&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在1.3之前的版本没有提供这个语法，我们应该如何实现one-time绑定呢？在开源社区中有个牛人在我们之前也问了自己这个问题，并创建了一系列指令来实现它：Bindonce <a href="https://github.com/Pasvaz/bindonce">https://github.com/Pasvaz/bindonce</a>。用Bindonce实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre class='green'><code class='html'><span class='line'><span class="nt">&lt;ul&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">bindonce</span> <span class="na">ng-repeat=</span><span class="s">&quot;session in sessions&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;info&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;span</span> <span class="na">bo-text=</span><span class="s">&quot;session.name&quot;</span><span class="nt">&gt;&lt;/span&gt;</span> -
</span><span class='line'>            <span class="nt">&lt;span</span> <span class="na">bo-text=</span><span class="s">&quot;session.room&quot;</span><span class="nt">&gt;&lt;/span&gt;</span> -
</span><span class='line'>            <span class="nt">&lt;span</span> <span class="na">bo-text=</span><span class="s">&quot;session.hour&quot;</span><span class="nt">&gt;&lt;/span&gt;</span> -
</span><span class='line'>            <span class="nt">&lt;span</span> <span class="na">bo-text=</span><span class="s">&quot;session.speaker&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;likes&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            {{session.likes}} likes!
</span><span class='line'>            <span class="nt">&lt;button</span> <span class="na">ng-click=</span><span class="s">&quot;likeSession(session)&quot;</span><span class="nt">&gt;</span>Like it!<span class="nt">&lt;/button&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了让示例能够工作，需要引入bindonce库，并依赖pasvaz.bindonce module。</p>

<pre class='green'><code>angular.module('com.ngnice.app', ['pasvaz.bindonce']);
</code></pre>

<p>并把Angular表达式改成bo-text指令。该指令将会绑定到Model，直到更新DOM，然后自动释放watcher。这样，显示功能仍然工作，但不再使用不必要的$watch。在这里每个Session只有一个$watch绑定，用301个绑定替代了1501个绑定。</p>

<p>恰当的使用bingonce或者1.3的one-time绑定能为应用one程序减少大量不必要$watch绑定，从而提高应用性能。</p>

<h3>滚屏加载</h3>

<p>另外一种可行的性能解决方案就是滚屏加载，又称&#8221;Endless Scrolling,&ldquo; &#8220;unpagination&#8221;，这是用于大量数据集显示的时候，又不想表格分页，所以一般放在页面最底部，当滚动屏幕到达页面底部的时候，就会尝试加载一个序列的数据集，追加在页面底部。在Angular社区有开源组件ngInfiniteScroll <a href="http://binarymuse.github.io/ngInfiniteScroll/index.html">http://binarymuse.github.io/ngInfiniteScroll/index.html</a>实现滚屏加载。下面是官方Demo：</p>

<p>HTML：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre class='green'><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">ng-app=</span><span class="s">&#39;myApp&#39;</span> <span class="na">ng-controller=</span><span class="s">&#39;DemoController&#39;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;div</span> <span class="na">infinite-scroll=</span><span class="s">&#39;reddit.nextPage()&#39;</span> <span class="na">infinite-scroll-disabled=</span><span class="s">&#39;reddit.busy&#39;</span> <span class="na">infinite-scroll-distance=</span><span class="s">&#39;1&#39;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">ng-repeat=</span><span class="s">&#39;item in reddit.items&#39;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&#39;score&#39;</span><span class="nt">&gt;</span>{{item.score}}<span class="nt">&lt;/span&gt;</span>
</span><span class='line'>      <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&#39;title&#39;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;a</span> <span class="na">ng-href=</span><span class="s">&#39;{{item.url}}&#39;</span> <span class="na">target=</span><span class="s">&#39;_blank&#39;</span><span class="nt">&gt;</span>{{item.title}}<span class="nt">&lt;/a&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/span&gt;</span>
</span><span class='line'>      <span class="nt">&lt;small&gt;</span>by {{item.author}} -
</span><span class='line'>        <span class="nt">&lt;a</span> <span class="na">ng-href=</span><span class="s">&#39;http://reddit.com{{item.permalink}}&#39;</span> <span class="na">target=</span><span class="s">&#39;_blank&#39;</span><span class="nt">&gt;</span>{{item.num_comments}} comments<span class="nt">&lt;/a&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/small&gt;</span>
</span><span class='line'>      <span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">&#39;clear: both;&#39;</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">ng-show=</span><span class="s">&#39;reddit.busy&#39;</span><span class="nt">&gt;</span>Loading data...<span class="nt">&lt;/div&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/div&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>JavaScript：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre class='green'><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">myApp</span> <span class="o">=</span> <span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;myApp&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;infinite-scroll&#39;</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'><span class="nx">myApp</span><span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s1">&#39;DemoController&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;$scope&#39;</span><span class="p">,</span> <span class="s1">&#39;Reddit&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$scope</span><span class="p">,</span> <span class="nx">Reddit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">$scope</span><span class="p">.</span><span class="nx">reddit</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Reddit</span><span class="p">();</span>
</span><span class='line'><span class="p">}]);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Reddit constructor function to encapsulate HTTP and pagination logic</span>
</span><span class='line'><span class="nx">myApp</span><span class="p">.</span><span class="nx">factory</span><span class="p">(</span><span class="s1">&#39;Reddit&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;$http&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$http</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">Reddit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">busy</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">after</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">Reddit</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">nextPage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">busy</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">busy</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">&#39;http://api.reddit.com/hot?after=&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">after</span> <span class="o">+</span> <span class="s1">&#39;&amp;jsonp=JSON_CALLBACK&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">$http</span><span class="p">.</span><span class="nx">jsonp</span><span class="p">(</span><span class="nx">url</span><span class="p">).</span><span class="nx">success</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">data</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">after</span> <span class="o">=</span> <span class="s1">&#39;t3_&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">id</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">busy</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">Reddit</span><span class="p">;</span>
</span><span class='line'><span class="p">}]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以在这里<a href="http://binarymuse.github.io/ngInfiniteScroll/demo_async.html">http://binarymuse.github.io/ngInfiniteScroll/demo_async.html</a>访问这个例子。其使用很简单，有兴趣的读者可以查看其官方文档。</p>

<h3>其它</h3>

<p>当然对于性能解决方案还有很多，如客户端分页、服务端分页、将其它更高效的jQuery插件或者React插件合理的封装为ng组件等。当封装第三方非Angular组件时需要注意scope和model的同步，以及合理的触发$apply更新View。另外在开源社区中也有ngReact可以简化将React组件应用到Angular应用中，在这里可以了解到关于它的更多信息：<a href="https://github.com/davidchang/ngReact">https://github.com/davidchang/ngReact</a>。</p>

<p>此刻，我猜你一定正是心中默默嘀咕着：Angular“脏检查机制”一定很慢，一个“肮脏”的家伙。但这是错误的。它其实很快，Angular团队为此专门做了很多优化。相反，在大多数场景下，Angular这种特殊的watcher机制，反而比很多基于JavaScript模板引擎（underscore、Handlebars等）更快。因为Angular并不需要通过大范围的DOM操作来更新View，它的每次更新区域更小，DOM操作更少。而DOM操作的代价远远高过JavaScript运算，在有些浏览器中，修改DOM的速度甚至会比纯粹的JavaScript运算慢很多倍！</p>

<p>而且，在现实场景中，我们的大多数页面都不会超出2000个watcher，因为过多的信息对使用者是非常不友好的，好的设计师都懂得限制单页信息的展示量。但是如果超过了2000个watcher，那么你就得仔细思考如何去优化它了，应该优先选择从用户体验方面改进，实在不行就用上面提到的技巧来优化你的应用程序。</p>

<p>最后，随着Angular 2.0框架对“脏检查机制”的改进，运行性能将会得到显著地提高，特别是针对Mobile开发的ionic这类框架，将直接受益。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript单线程和浏览器事件循环简述]]></title>
    <link href="http://greengerong.github.io/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/"/>
    <updated>2015-10-27T22:13:55+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/10/27/javascript-single-thread-and-browser-event-loop</id>
    <content type="html"><![CDATA[<p><img src="http://greengerong.github.io/images/blog_img/JavaScript%E5%8D%95%E7%BA%BF%E7%A8%8B-%E7%81%AB%E8%BD%A6%E8%BD%A8%E9%81%93.jpg" alt="JavaScript 单线程 火车轨道" /></p>

<h2>JavaScript单线程</h2>

<p>在上篇博客<a href="http://greengerong.com/blog/2015/10/22/promisede-miao-yong/">《Promise的前世今生和妙用技巧》</a>的开篇中，我们曾简述了JavaScript的单线程机制和浏览器的事件模型。应很多网友的回复，在这篇文章中将继续展开这一个话题。当然这里是博主的一些理解，如果还存在什么纰漏的话，请不吝指教。</p>

<p>JavaScript这门语言运行在浏览器中，是以单线程的方式运行的。说到单线程，就得从操作系统进程开始说起。进程和线程都是操作系统的概念。进程是应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据和其它系统资源所组成；进程在运行过程中能够申请创建和使用系统资源（如独立的内存区域等），这些资源也会随着进程的终止而被销毁。而线程则是进程内的一个独立执行单元，在不同的线程之间是可以共享进程资源的，所以在多线程的情况下，需要特别注意对临界资源的访问控制。在系统创建进程之后就开始启动执行进程的主线程，而进程的生命周期和这个主线程的生命周期一致，主线程的退出也就意味着进程的终止和销毁。主线程是由系统进程所创建的，同时用户也可以自主创建其它线程，这一系列的线程都会并发地运行于同一个进程中。</p>

<p>在多线程操作的情况下可以实现应用的并行处理，而提高整个应用程序的性能和吞吐量，更大粒度的榨取本机的CPU利用率，特别是现代很多语言都支持了多核并行处理技术。然后JavaScript居然还是单线程执行，为什么呢？</p>

<p>这是因为JavaScript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，而线程1要求浏览器删除DOM节点，线程2却希望修改这个节点的某些样式风格。这个时候浏览器就无法裁决采用哪一种策略了。当然我们可以为浏览器引入“排它锁”或者是“乐观锁”来解决这些冲突，但为了避免引入了更大的复杂性，所以JavaScript从诞生开始就选择了单线程执行。</p>

<p>因为单线程执行，所以对于JavaScript的任务而言，在同一时间内只能执行一个特定的任务，并且它会阻塞其他的任务执行。那么JavaScript的执行不会很慢吗？特别是对于长时间任务执行的时候，那么其他的任务就得不到执行。然而在软件开发中，特别是应用软件开发中，对于I/O设备的访问都是一些及其耗时的操作。在这些耗时任务执行的时候，其实并没必要等待它的完成，在I/O任务完成之前JavaScript完全可以继续执行其他的任务，直到I/O任务完成后再继续执行该任务的处理就行。JavaScript在设计之初，就意识这一点。所以在JavaScript中将这些耗时的I/O等操作封装为了异步的方法，等到这些任务完成后就将后续的处理操作封装为JavaScript任务放入执行任务队列中，等待JavaScript线程空闲的时候被执行。因此这里形成了另一个话题“浏览器的事件循环”机制，将在后续中详细阐述。</p>

<p>因为在JavaScript语言中，和其他大多数语言不一样之处：JavaScript中耗时的I/O操作都被处理为异步操作，以及回调注册机制。异步和回调仿佛和JavaScript就是“与生俱来”的一样。如Nodejs创始人Ryan Dahl所言，JavaScript语言的非阻塞的异步I/O事件驱动模型，以及JavaScript在Chrome推进下的多次性能优化、具有函数式等高级语言特性，因此最终Nodejs选择JavaScript。由于Nodejs最终选择了JavaScript，从此也大大的推动了JavaScript在非浏览器领域的急速扩展。</p>

<p>下面的文字是来自Nodejs官网：</p>

<p><img src="http://greengerong.github.io/images/blog_img/nodejs-javascript-%E7%AE%80%E4%BB%8B.png" alt="nodejs-javascript-简介" /></p>

<p>当然对于非I/O的操作耗时操作如上篇博文<a href="http://greengerong.com/blog/2015/10/22/promisede-miao-yong/">《Promise的前世今生和妙用技巧》</a>所说，在HTML5中也提出了新的解决方案，它就是Web Worker。Web Worker就是在当前JavaScript的执行主线程中利用Worker类新开辟一个额外的线程来加载和运行特定的JavaScript文件，这个新的线程和JavaScript的主线程之间并不会互相影响和阻塞执行的；并且在Web Worker中提供这个新线程和JavaScript主线程之间数据交换的接口：postMessage和onMessage事件。但在HTML5 Web Worker中是不能操作DOM的，任何需要操作DOM的任务都需要委托给JavaScript主线程来执行，所以虽然引入HTML5 WebWorker但仍然没有改线JavaScript单线程的本质。对于HTML5的Web Worker和在C# WinForm设计中的BackgroundWorker很类似，对于这类GUI（图形化界面）操作的应用程序中，对于UI界面的操作都需要委托给UI主线程来执行，避免多线程情况下UI操作的安全性和避免不必要的多线程访问控制的复杂度。</p>

<h2>浏览器事件循环</h2>

<p>在上面已经提到JavaScript中为了不阻塞UI的渲染，很多JavaScript任务都是异步的，它们包括键盘、鼠标I/O输入输出事件、窗口大小的resize事件、定时器（setTimeout、setInterval）事件、Ajax请求网络I/O回调等。当这些异步任务发生的时候，它们将会被放入浏览器的事件任务队列中去。在浏览器内部中存在一个消息循环池，也叫Event Loop（事件循环），JavaScript引擎在运行时后单线程的处理这些事件任务。例如用户在网页中点击了button事件，则它们会被放入在这个事件循环池中，需要等到JavaScript运行时执行线程空闲时候才会按照队列先进先出的原则被一一执行。对于setTimeout这类定时任务也是一样的，只有当定时时刻达到的时候，它们才会被放入浏览器的事件队列中等待被执行；由于此时的JavaScript主线程也许并不空闲，所以它将并不会被JavaScript引擎所立即执行，因为在JavaScript语言设计中setTimeout这类定时任务的执行时间并不是精确的。在前端开发中经常会发现setTimeout(func, 0)很有用，因为这并不是立即执行，而是将当前执行回调函数放入浏览器的事件队列中，等待当前其他任务的完成，然后在执行它；所以setTimeout(func, 0)具有改变当前代码执行顺序的作用，让浏览器有机会完成UI界面渲染等任务后在执行这段回调函数。当然对于老式浏览器这里具有16ms的差距，HTML5规定为4ms，以及关于动画操作中的requestAnimationFrame，请读者参见MDN资料<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame</a>。</p>

<p>浏览器事件循环如下图所示：</p>

<p><img src="http://greengerong.github.io/images/blog_img/browser-event-base.png" alt="浏览器事件模型" /></p>

<p>虽然JavaScript是单线程执行的，但是浏览器并不是单线程执行的，它们有JavaScript的执行线程、UI节点的渲染线程，图片等资源的加载线程，以及Ajax请求线程等。在Chrome设计中，为了防止因一个Tab window的奔溃而影响整个浏览器，它的每一个Tab被设计为一个进程；在Chrome设计中存在很多的进程，并利用进程间通讯来完成它们之间的同步，因此这也是Chrome快速的法宝之一。对于Ajax的请求也需要特殊线程来执行，当需要发送一个Ajax请求的时候，浏览器会开辟一个新的线程来执行HTTP的请求，它并不会阻塞JavaScript线程的执行，HTTP请求状态变更事件会被作为回调放入到浏览器的事件队列中等待被执行。</p>

<h2>总结</h2>

<p>写到这里，本文也进入了尾声。希望这篇文章能给阅读本文的读者一些启发，同时如果本文中存在不足的地方，也希望你能不吝指教。另外，同时也欢迎关注博主的微信公众号[破狼]（微信二维码位于博客右侧），这里将会为大家第一时间推送博主的最新博文，谢谢大家的支持和鼓励。</p>

<p><img src="http://greengerong.com/self/wei-xin-wolf-er-wei-ma.jpg" alt="微信订阅号" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise的前世今生和妙用技巧]]></title>
    <link href="http://greengerong.github.io/blog/2015/10/22/promisede-miao-yong/"/>
    <updated>2015-10-22T17:16:31+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/10/22/promisede-miao-yong</id>
    <content type="html"><![CDATA[<h2>浏览器事件模型和回调机制</h2>

<p>JavaScript作为单线程运行于浏览器之中，这是每本JavaScript教科书中都会被提到的。同时出于对UI线程操作的安全性考虑，JavaScript和UI线程也处于同一个线程中。因此对于长时间的耗时操作，将会阻塞UI的响应。为了更好的UI体验，应该尽量的避免JavaScript中执行较长耗时的操作（如大量for循环的对象diff等）或者是长时间I/O阻塞的任务。所以在浏览器中的大多数任务都是异步（无阻塞）执行的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、Ajax完成回调事件等。当每一个异步事件完成时，它都将被放入一个叫做”浏览器事件队列“中的事件池中去。而这些被放在事件池中的任务，将会被javascript引擎单线程处理的一个一个的处理，当在此次处理中再次遇见的异步任务，它们也会被放到事件池中去，等待下一次的tick被处理。另外在HTML5中引入了新的组件-Web Worker，它可以在JavaScript线程以外执行这些任务，而不阻塞当前UI线程。</p>

<p>浏览器中的事件循环模型如下图所示：</p>

<p><img src="http://greengerong.github.io/images/blog_img/browser-event-base.png" alt="浏览器事件模型" /></p>

<p>由于浏览器的这种内部事件循环机制，所以JavaScript一直以callback回调的方式来处理事件任务。因此无所避免的对于多个的JavaScript异步任务的处理，将会遇见”callback hell“（回调地狱），使得这类代码及其不可读和难易维护。</p>

<pre class='green'><code>asyncTask1(data, function (data1){

    asyncTask2(data1, function (data2){

        asyncTask3(data2, function (data3){
                // .... 魔鬼式的金字塔还在继续
        });

    });

});
</code></pre>

<h2>Promise的横空出世</h2>

<p><img src="http://greengerong.github.io/images/blog_img/%E6%8B%89%E9%92%A9-%E6%89%BF%E8%AF%BA-promise.jpg" alt="Promise承诺" /></p>

<p>因此很多JavaScript牛人开始寻找解决这回调地狱的模式设计，随后Promise（jQuery的<code>deferred</code>也属于Promise范畴）便被引入到了JavaScript的世界。Promise在英语中语义为：”承诺“，它表示如A调用一个长时间任务B的时候，B将返回一个”承诺“给A，A不用关心整个实施的过程，继续做自己的任务；当B实施完成的时候，会通过A，并将执行A之间的预先约定的回调。而deferred在英语中语义为：”延迟“，这也说明promise解决的问题是一种带有延迟的事件，这个事件会被延迟到未来某个合适点再执行。</p>

<p><a href="http://promises-aplus.github.io/promises-spec/">Promise/A+规范</a>：</p>

<ul>
<li>Promise 对象有三种状态： Pending &ndash; Promise对象的初始状态，等到任务的完成或者被拒绝；Fulfilled &ndash; 任务执行完成并且成功的状态；Rejected &ndash; 任务执行完成并且失败的状态；</li>
<li>Promise的状态只可能从“Pending”状态转到“Fulfilled”状态或者“Rejected”状态，而且不能逆向转换，同时“Fulfilled”状态和“Rejected”状态也不能相互转换；</li>
<li>Promise对象必须实现then方法，then是promise规范的核心，而且then方法也必须返回一个Promise对象，同一个Promise对象可以注册多个then方法，并且回调的执行顺序跟它们的注册顺序一致；</li>
<li>then方法接受两个回调函数，它们分别为：成功时的回调和失败时的回调；并且它们分别在：Promise由“Pending”状态转换到“Fulfilled”状态时被调用和在Promise由“Pending”状态转换到“Rejected”状态时被调用。</li>
</ul>


<p>如下面所示：</p>

<p><img src="http://greengerong.github.io/images/blog_img/promises-%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="promises 流程图" /></p>

<p>根据<a href="http://promises-aplus.github.io/promises-spec/">Promise/A+规范</a>，我们在文章开始的Promise伪代码就可以转换为如下代码：</p>

<pre class='green'><code>asyncTask1(data)
    .then(function(data1){
        return asyncTask2(data1);
    })
    .then(function(data2){
       return asyncTask3(data2);
    })
    // 仍然可以继续then方法
</code></pre>

<p>Promise将原来回调地狱中的回调函数，从横向式增加巧妙的变为了纵向增长。以链式的风格，纵向的书写，使得代码更加的可读和易于维护。</p>

<p>Promise在JavaScript的世界中逐渐的被大家所接受，所以在ES6的标准版中已经引入了Promise的规范了。现在通过Babel，可以完全放心的引入产品环境之中了。</p>

<p>另外，对于解决这类异步任务的方式，在ES7中将会引入<code>async、await</code>两个关键字，以同步的方式来书写异步的任务，它被誉为”JavaScript异步处理的终极方案“。这两个关键字是ES6标准中生成器（<code>generator</code>）和Promise的组合新语法，内置<code>generator</code>的执行器的一种方式。当然<code>async、await</code>的讲解并不会在本文中展开，有兴趣的读者可以参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN资料</a>。</p>

<h2>Promise的妙用</h2>

<p>如上所说Promise在处理异步回调或者是延迟执行任务时候，是一个不错的选择方案。下面我们将介绍一些Promise的使用技巧（下面将利用Angular的<code>$q</code>和<code>$http</code>为例，当然对于jQuery的<code>deferred</code>，ES6的Promise仍然实用）：</p>

<h4>多个异步任务的串行处理</h4>

<p>在上文中提到的回调地狱案例，就是一种试图去将多个异步的任务串行处理的结果，使得代码不断的横向延伸，可读性和维护性急剧下降。当然我们也提到了Promise利用链式和延迟执行模型，将代码从横向延伸拉回了纵向增长。使用Angular中<code>$http</code>的实现如下：</p>

<pre class='green'><code>$http.get('/demo1')
 .then(function(data){
     console.log('demo1', data);
     return $http.get('/demo2', {params: data.result});
  })
 .then(function(data){
     console.log('demo2', data);
     return $http.get('/demo3', {params: data.result});
  })
 .then(function(data){
     console.log('demo3', data.result);
  });
</code></pre>

<p>因为Promise是可以传递的，可以继续<code>then</code>方法延续下去，也可以在纵向扩展的途中改变为其他Promise或者数据。所以在例子中的$http也可以换为其他的Promise（如$<code>timeout</code>，<code>$resource</code> &hellip;）。</p>

<h4>多个异步任务的并行处理</h4>

<p>在有些场景下，我们所要处理的多个异步任务之间并没有像上例中的那么强的依赖关系，只需要在这一系列的异步任务全部完成的时候执行一些特定逻辑。这个时候为了性能的考虑等，我们不需要将它们都串行起来执行，并行执行它们将是一个最优的选择。如果仍然采用回调函数，则这是一个非常恼人的问题。利用Promise则同样可以优雅的解决它：</p>

<pre class='green'><code>$q.all([$http.get('/demo1'),
        $http.get('/demo2'),
        $http.get('/demo3')
])
.then(function(results){
    console.log('result 1', results[0]);
    console.log('result 2', results[1]);
    console.log('result 3', results[2]);
});
</code></pre>

<p>这样就可以等到一堆异步的任务完成后，在执行特定的业务回调了。在Angular中的路由机制<code>ngRoute</code>、<code>uiRoute</code>的resolve机制也是采用同样的原理：在路由执行的时候，会将获取模板的Promise、获取所有resolve数据的Promise都拼接在一起，同时并行的获取它们，然后等待它们都结束的时候，才开始初始化<code>ng-view</code>、<code>ui-view</code>指令的scope对象，以及compile模板节点，并插入页面DOM中，完成一次路由的跳转并且切换了View，将静态的HTML模板变为动态的网页展示出来。</p>

<p>Angular路由机制的伪代码如下：</p>

<pre class='green'><code>    var getTemplatePromise = function(options) {
         // ... 拼接所有template或者templateUrl
    };

    var getResolvePromises = function(resolves) {
        // ... 拼接所有resolve
    };

    var controllerLoader = function(options, currentScope, tplAndVars, initLocals) {
        // ...

        ctrlInstance = $controller(options.controller, ctrlLocals);
        if (options.controllerAs) {
            currentScope[options.controllerAs] = ctrlInstance;
        }

        // ...

        return currentScope;
    };

    var templateAndResolvePromise = $q.all([getTemplatePromise(options)].concat(getResolvePromises(options.resolve || {})));

    return templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
        var currentScope = currentScope || $rootScope.$new();
        controllerLoader(options, currentScope, tplAndVars, initLocals);
        // ... compile &amp; append dom 
    });
</code></pre>

<p>对于这类路由机制的使用，在博主上篇博文<a href="http://greengerong.com/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian/">《自定义Angular插件 &ndash; 网站用户引导》</a>中的ng-trainning插件中也采用了它。关于这段代码的具体分析和应用将在后续单独的文章中，敬请大家期待。</p>

<h4>对于同步数据的Promise处理，统一调用接口</h4>

<p>有了Promise的处理，因为在前端代码中最多的异步处理就是Ajax，它们都被包装为了Promise .then的风格。那么对于一部分同步的非异步处理呢？如localStorage、setTimeout、setInterval之类的方法。在大多数情况下，博主仍然推荐使用Promise的方式包装，使得项目Service的返回接口统一。这样也便于像上例中的多个异步任务的串行、并行处理。在Angular路由中对于只设置template的情况，也是这么处理的。</p>

<p>对于setTimeout、setInterval在Angular中都已经为我们内置了$timeout和$interval服务，它们就是一种Promise的封装。对于localStorage呢？可以采用$q.when方法来直接包装localStorage的返回值的为Promise接口，如下所示：</p>

<pre class='green'><code>    var data = $window.localStorage.getItem('data-api-key');
    return $q.when(data);
</code></pre>

<p>整个项目的Service层的返回值都可以被封装为统一的风格使用了，项目变得更加的一致和统一。在需要多个Service同时并行或者串行处理的时候，也变得简单了，一致的使用方式。</p>

<h4>对于延迟任务的Promise DSL语义化封装</h4>

<p>在前面已经提到Promise是延迟到未来执行某些特定任务，在调用时候则给消费者返回一个”承诺“，消费者线程并不会被阻塞。在消费者接受到”承诺“之后，消费者就不用再关心这些任务是如何完成的，以及督促生产者的任务执行状态等。直到任务完成后，消费者手中的这个”承诺“就被兑现了。</p>

<p>对于这类延迟机制，在前端的UI交互中也是极其常见的。比如模态窗口的显示，对于用户在模态窗口中的交互结果并不可提前预知的，用户是点击”ok“按钮，或者是”cancel“按钮，这是一个未来将会发生的延迟事件。对于这类场景的处理，也是Promise所擅长的领域。在Angular-UI的Bootstrap的modal的实现也是基于Promise的封装。</p>

<pre class='green'><code>$modal.open({
    templateUrl: '/templates/modal.html',
    controller: 'ModalController',
    controllerAs: 'modal',
    resolve: {
    }
})
    .result
    .then(function ok(data) {
        // 用户点击ok按钮事件
    }, function cancel(){
        // 用户点击cancel按钮事件
    });
</code></pre>

<p>这是因为modal在open方法的返回值中给了我们一个Promise的result对象（承诺）。等到用户在模态窗口中点击了ok按钮，则Bootstrap会使用<code>$q</code>的<code>defer</code>来<code>resolve</code>来执行ok事件；相反，如果用户点击了cancel按钮，则会使用<code>$q</code>的<code>defer</code>来<code>reject</code>执行cancel事件。</p>

<p>这样就很好的解决了延迟触发的问题，也避免了<code>callback的地狱</code>。我们仍然可以进一步将其返回值语义化，以业务自有的术语命名而形成一套DSL API。</p>

<pre class='green'><code> function open(data){
    var defer = $q.defer();

    // resolve or reject defer;

    var promise = defer.promise;
    promise.ok = function(func){
        promise.then(func);
        return promise;
    };

    promise.cancel = function(func){
        promise.then(null, func);
        return promise;
    };

    return promise;
};
</code></pre>

<p>则我们可以如下方式来访问它：</p>

<pre class='green'><code>$modal.open(item)
   .ok(function(data){
        // ok逻辑
   })
   .cancel(function(data){
       // cancel 逻辑
   });
</code></pre>

<p>是不是感觉更具有语义呢？在Angular中$http的返回方法success、error也是同样逻辑的封装。将success的注册函数注册为.then方法的成功回调，error的注册方法注册为then方法的失败回调。所以success和error方法只是Angular框架为我们在Promise语法之上封装的一套语法糖而已。</p>

<p>Angular的success、error回调的实现代码：</p>

<pre class='green'><code>  promise.success = function(fn) {
    promise.then(function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };

  promise.error = function(fn) {
    promise.then(null, function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };
</code></pre>

<h4>利用Promise来实现管道式AOP拦截</h4>

<p>在软件设计中，AOP是Aspect-Oriented Programming的缩写，意为：面向切面编程。通过编译时（Compile）植入代码、运行期（Runtime）动态代理、以及框架提供管道式执行等策略实现程序通用功能与业务模块的分离，统一处理、维护的一种解耦设计。 AOP是OOP的延续，是软件开发中的一个热点，也是很多服务端框架（如Java世界的Spring）中的核心内容之一，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。 AOP实用的场景主要有：权限控制、日志模块、事务处理、性能统计、异常处理等独立、通用的非业务模块。关于更多的AOP资料请参考<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a>。</p>

<p>在Angular中同样也内置了一些AOP的设计思想，便于实现程序通用功能与业务模块的分离、解耦、统一处理和维护。$http中的拦截器（interceptors）和装饰器（$provide.decorator）是Angular中两类常见的AOP切入点。前者以管道式执行策略实现，而后者则通过运行时的Promise管道动态实现的。</p>

<p>首先回顾一下Angular的拦截器实现方式：</p>

<pre class='green'><code>// 注册一个拦截器服务
$provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
  return {
    // 可选方法
    'request': function(config) {
      // 请求成功后处理
      return config;
    },

    // 可选方法
   'requestError': function(rejection) {
      // 请求失败后的处理
      if (canRecover(rejection)) {
        return responseOrNewPromise
      }
      return $q.reject(rejection);
    },



    // 可选方法
    'response': function(response) {
      // 返回回城处理
      return response;
    },

    // 可选方法
   'responseError': function(rejection) {
      // 返回失败的处理
      if (canRecover(rejection)) {
        return responseOrNewPromise
      }
      return $q.reject(rejection);
    }
  };
});

// 将服务注册到拦截器链中
$httpProvider.interceptors.push('myHttpInterceptor');


// 同样也可以将拦截器注册为一个工厂方法。 但上一中方式更为推荐。
$httpProvider.interceptors.push(['$q', function($q) {
  return {
   'request': function(config) {
       // 同上
    },

    'response': function(response) {
       // 同上
    }
  };
}]);
</code></pre>

<p>这样就可以实现对Angular中的<code>$http</code>或者是<code>$resource</code>的Ajax请求拦截了。但在Angular内部是是如何实现这种拦截方式的呢？Angular使用的就是Promise机制，形成异步管道流，将真实的Ajax请求放置在request、requestError和response、responseError的管道中间，因此就产生了对Ajax请求的拦截。</p>

<p>其源码实现如下：</p>

<pre class='green'><code>var interceptorFactories = this.interceptors = [];

var responseInterceptorFactories = this.responseInterceptors = [];

this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
  function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {

    var defaultCache = $cacheFactory('$http');

    var reversedInterceptors = [];

    forEach(interceptorFactories, function(interceptorFactory) {
      reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    });

    forEach(responseInterceptorFactories, function(interceptorFactory, index) {
      var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);

      reversedInterceptors.splice(index, 0, {
        response: function(response) {
          return responseFn($q.when(response));
        },
        responseError: function(response) {
          return responseFn($q.reject(response));
        }
      });
    });
    ...

function $http(requestConfig) {
  ...

  var chain = [serverRequest, undefined];
  var promise = $q.when(config);

  // apply interceptors
  forEach(reversedInterceptors, function(interceptor) {
    if (interceptor.request || interceptor.requestError) {
      chain.unshift(interceptor.request, interceptor.requestError);
    }
    if (interceptor.response || interceptor.responseError) {
      chain.push(interceptor.response, interceptor.responseError);
    }
  });

  while (chain.length) {
    var thenFn = chain.shift();
    var rejectFn = chain.shift();

    promise = promise.then(thenFn, rejectFn);
  }

  promise.success = function(fn) {
    promise.then(function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };

  promise.error = function(fn) {
    promise.then(null, function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };

  return promise;
};
</code></pre>

<p>在上面紧接着在<code>$get</code>注入方法之后，Angular会将<code>interceptors</code>和<code>responseInterceptors</code>反转合并到一个<code>reversedInterceptors</code>的拦截器内部变量中保存。最后在$http函数中以<code>[serverRequest, undefined]</code>（<code>serverRequest</code>是Ajax请求的Promise操作）为中心，将<code>reversedInterceptors</code>中的所有拦截器函数依次加入到chain链式数组中。如果是request或requestError，那么就放在链式数组起始位置；相反如果是response或responseError，那么就放在链式数组最后。</p>

<p>注意添加在chain的request和requestError或者response和responseError都一定是成对的，换句话说可能注册一个非空的request与一个为undefined的requestError，或者是一个为undefined的request与非空的requestError。就像chain数组的声明一样<code>（var chain = [serverRequest, undefined];）</code>，成对的放入serverRequest和undefined对象到数组中。因为后面的代码将利用Promise的机制注册这些拦截器函数，实现管道式AOP拦截机制。</p>

<p>在Promise中需要两个函数来注册回调，分别为成功回调和失败回调。在这里request和response会被注册成Promise的成功回调，而requestError和responseError则会注册成Promise的失败回调。所以在chain中添加的request和requestError，response或responseError都是成对出现的，这是为了能在接下来的循环中简洁地注册Promise回调函数。 这些被注册的拦截器链，会通过<code>$q.when(config)</code> Promise启动，它会首先传入<code>$http</code>的config对象，并执行所有的request拦截器，依次再到<code>serverRequest</code>这个Ajax请求，此时将挂起后边所有的response拦截器，直到Ajax请求响应完成，再依次执行剩下的response拦截器回调； 如果在request过程中有异常失败则会执行后边的requestError拦截器，对于Ajax请求的失败或者处理Ajax的response拦截器的异常也会被后面注册的responseError拦截器捕获。</p>

<p>从最后两段代码也能了解到关于<code>$http</code>服务中的success方法和error方法，是Angular为大家提供了一种Promise的便捷写法。success方法是注册一个传入的成功回调和为undefined的错误回调，而error则是注册一个为null的成功回调和一个传入的失败回调。</p>

<h2>总结</h2>

<p>写到这里，本文也进入了尾声。希望大家能够对Promise有一定的理解，并能够”信手拈来“的运用于实际的项目之中，增强代码的可读性和可维护性。在本文中所用到的例子，你都可以在博主的jsbin<a href="http://jsbin.com/bayeva/edit?html,js,output">http://jsbin.com/bayeva/edit?html,js,output</a>中找到它们。</p>

<p>另外，同时也欢迎关注博主的微信公众号[破狼]（微信二维码位于博客右侧），这里将会为大家第一时间推送博主的最新博文，谢谢大家的支持和鼓励。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义Angular插件 - 网站用户引导]]></title>
    <link href="http://greengerong.github.io/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian/"/>
    <updated>2015-10-18T19:47:51+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian</id>
    <content type="html"><![CDATA[<p>最近由于项目进行了较大的改版，为了让用户能够适应这次新的改版，因此在系统中引入了“用户引导”功能，对于初次进入系统的用户一些简单的使用培训training。对于大多数网站来说，这是一个很常见的功能。所以在开发这个任务之前，博主尝试将其抽象化，独立于现有系统的业务逻辑，将其封装为一个通用的插件，使得代码更容易扩展和维护。</p>

<p>无图无真相，先上图：</p>

<p><img src="http://greengerong.github.io/images/blog_img/training-demo.png" alt="training demo" /></p>

<p>关于这款trainning插件的使用很简单，它采用了类似Angular路由一样的配置，只需要简单的配置其每一步training信息。</p>

<ul>
<li>title：step的标题信息；</li>
<li>template/templateUrl: step的内容模板信息。这类可以配置html元素，或者是模板的url地址，同时templateUrl也支持Angular route一样的function语法；</li>
<li>controller: step的控制器配置；在controller中可注入如下参数：当前step &ndash; currentStep、所有step的配置 &ndash; trainnings、当前step的配置 &ndash; currentTrainning、以及下一步的操作回调 &ndash; trainningInstance（其中nextStep：为下一步的回调，cancel为取消用户引导回调）；</li>
<li>controllerAs: controller的别名；</li>
<li>resolve：在controller初始化前的数据配置，同Angular路由中的resolve；</li>
<li>locals：本地变量，和resolve相似，可以传递到controller中。区别之处在于它不支持function调用，对于常量书写会比resolve更方便；</li>
<li>placement: step容器上三角箭头的显示方位；</li>
<li>position: step容器的具体显示位置，这是一个绝对坐标；可以传递<code>{left: 100, top: 100}</code>的绝对坐标，也可以是<code>#stepPanelHost</code>配置相对于此元素的placement位置。同时它也支持自定义function和注入Angular的其他组件语法。并且默认可注入：所有step配置 &ndash; trainnings,当前步骤 &ndash; step，当前step的配置 &ndash; currentTrainning，以及step容器节点 &ndash; stepPanel；</li>
<li>backdrop：是否需要显示遮罩层，默认显示，除非显示声明为false配置，则不会显示遮罩层；</li>
<li>stepClass：每一个step容器的样式信息；</li>
<li>backdropClass： 每一个遮罩层的样式信息。</li>
</ul>


<p>了解了这些配置后，并根据特定需求定制化整个用户引导的配置信息后，我们就可以使用trainningService的trainning方法来在特定实际启动用户引导，传入参数为每一步step的配置信息。并可以注册其done或者cancel事件：</p>

<pre class='green'><code>trainningService.trainning(trainningCourses.courses)
    .done(function() {
        vm.isDone = true;
    });
</code></pre>

<p>下面是一个演示的配置信息：</p>

<pre class='green'><code>    .constant('trainningCourses', {
                courses: [{
                    title: 'Step 1:',
                    templateUrl: 'trainning-content.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    placement: 'left',
                    position: '#blogControl'
                },{
                    title: 'Step 3:',
                    templateUrl: 'trainning-content.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    placement: 'top',
                    position: {
                        top: 200,
                        left: 100
                    }
                },
                    ...
                {
                    stepClass: 'last-step',
                    backdropClass: 'last-backdrop',
                    templateUrl: 'trainning-content-done.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    position: ['$window', 'stepPanel', function($window, stepPanel) {
                        // 自定义函数，使其屏幕居中
                        var win = angular.element($window);
                        return {
                            top: (win.height() - stepPanel.height()) / 2,
                            left: (win.width() - stepPanel.width()) / 2
                        }
                    }]
                }]
            })
</code></pre>

<p>本文插件源码和演示效果唯一codepen上，效果如下：</p>

<p data-height="385" data-theme-id="0" data-slug-hash="pjwXQW" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/pjwXQW/'>ng-trainning</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://greengerong.github.io//assets.codepen.io/assets/embed/ei.js" async="true"></script>


<p>在trainning插件的源码设计中，包含如下几个要点：</p>

<ul>
<li>提供service api。因为关于trainning这个插件，它是一个全局的插件，正好在Angular中所有的service也是单例的，所以将用户引导逻辑封装到Angular的service中是一个不错的设计。但对于trainning的每一步展示内容信息则是DOM操作，在Angular的处理中它不该存在于service中，最佳的方式是应该把他封装到Directive中。所以这里采用Directive的定义，并在service中compile，然后append到body中。</li>
<li>对于每一个这类独立的插件应该封装一个独立的scope，这样便于在后续的销毁，以及不会与现有的scope变量的冲突。</li>
<li>$q对延时触发的结果包装。对于像该trainning插件或者modal这类操作结果采用promise的封装，是一个不错的选择。它取代了回调参数的复杂性，并以流畅API的方式展现，更利于代码的可读性。同时也能与其他Angular service统一返回API。</li>
<li>对于controller、controllerAs、resolve、template、templateUrl这类类似路由的处理代码，完全可以移到到你的同类插件中去。它们可以增加插件的更多定制化扩展。关于这部分代码的解释，博主将会在后续文章中为大家推送。</li>
<li>利用$injector.invoke动态注入和调用Angular service，这样既能获取Angular其他service注入的扩展性，也能获取到函数的动态性。如上例中的屏幕居中的自定义扩展方式。</li>
</ul>


<p>这类设计要点，同样可以运用到想modal、alert、overload这类全局插件中。有兴趣的读者，你可以在博主的codepen笔记中阅读这段代码<a href="http://codepen.io/greengerong/pen/pjwXQW#0">http://codepen.io/greengerong/pen/pjwXQW#0</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[smartcrop.js智能图片裁剪库]]></title>
    <link href="http://greengerong.github.io/blog/2015/10/13/smartcrop-dot-js-zhi-neng-tu-pian-cai-jian/"/>
    <updated>2015-10-13T21:58:21+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/10/13/smartcrop-dot-js-zhi-neng-tu-pian-cai-jian</id>
    <content type="html"><![CDATA[<p>今天将为大家介绍一款近期github上很不错的开源库 &ndash; <a href="https://github.com/jwagner/smartcrop.js">smartcrop.js</a>。它是一款图片处理的智能裁剪库。在很多项目开发中，经常会遇见上传图片的场景，它可能是用户照片信息，也可能是商品图片等。然而在网页布局中，为了更好的用户体验，它们往往都需要一些宽度和高度的限制。对于不合适的图片，常常需要为用户提供一种裁剪方式，以此来满足网站更好的用户体验。但是图片默认的裁剪区域往往被显示在一个固定的位置，而这个位置却往往又不是精准的用户裁剪位置。因此今天为大家介绍的这一款开源库，就是为了解决这类问题，并为用户提供更好的用户体验的。</p>

<p>首先我们可以使用<code>npm install smartcrop</code>或者<code>bower install smartcrop</code>来下载它。然后像如下方式使用它：</p>

<pre class='green'><code>SmartCrop.crop(image, {
        width: 100,
        height: 100
    }, 
    function(result){
        console.log(result); // {topCrop: {x: 300, y: 200, height: 200, width: 200}}
    });
</code></pre>

<p>它会输出一个比较好的最佳图片裁剪位置，如<code>{topCrop: {x: 300, y: 200, height: 200, width: 200}}</code>的数据。</p>

<p>下面是一副来自它的展示网站的案例，请欣赏：</p>

<p><img src="http://greengerong.github.io/images/blog_img/smartcrop-%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA-%E6%A1%88%E4%BE%8B.png" alt="smartcrop-图片裁剪-案例" /></p>

<p>更多案例：</p>

<ol>
<li><a href="http://29a.ch/sandbox/2014/smartcrop/examples/testsuite.html">http://29a.ch/sandbox/2014/smartcrop/examples/testsuite.html</a>：这里拥有超过1000个图片效果的展示（流量用户请谨慎点击，图片众多）；</li>
<li><a href="http://29a.ch/sandbox/2014/smartcrop/examples/testbed.html">http://29a.ch/sandbox/2014/smartcrop/examples/testbed.html</a>：这里允许上传本地的图片，并体验其效果；</li>
<li><a href="http://29a.ch/sandbox/2014/smartcrop/examples/slideshow.html">http://29a.ch/sandbox/2014/smartcrop/examples/slideshow.html</a>：在这里可以尝试用它创建幻灯片。</li>
</ol>


<p>最后，更多关于smartcrop.js的信息，请参见其github：<a href="https://github.com/jwagner/smartcrop.js">https://github.com/jwagner/smartcrop.js</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[书写高效的CSS代码-（待开发）]]></title>
    <link href="http://greengerong.github.io/blog/2015/10/13/shu-xie-gao-xiao-de-css-dai-ma/"/>
    <updated>2015-10-13T21:36:54+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/10/13/shu-xie-gao-xiao-de-css-dai-ma</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS尺寸和字体单位-em、px还是%]]></title>
    <link href="http://greengerong.github.io/blog/2015/10/09/css-chi-cun-dan-wei-em-px-huan-shi-percent/"/>
    <updated>2015-10-09T07:00:04+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/10/09/css-chi-cun-dan-wei-em-px-huan-shi-percent</id>
    <content type="html"><![CDATA[<p>在页面整体布局中，页面元素的尺寸大小（长度、宽度、内外边距等）和页面字体的大小也是重要的工作之一。一个合理设置，则会让页面看起来层次分明，重点鲜明，赏心悦目。反之，一个不友好的页面尺寸和字体大小设置，则会增加页面的复杂性，增加用户对页面理解的复杂性；甚至在当下访问终端（iPhone、iPad、PC、Android&hellip;）层出不穷的今天，适应各式各样的访问终端，将成为手中的一块“烫手的山芋”。所以在近几年，“九宫格”式的“流式布局”再度回归。为了提供页面布局，及其它的可维护性、可扩展性，我们尝试将页面元素的大小，以及字体大小都设置为相对值，不再是孤立的固定像素点。使其能在父元素的尺寸变化的同时，子元素也能随之适应变化。以及结合少量最新CSS3的@media查询，来实现“响应式布局”，bootstrap这类CSS框架大势兴起。</p>

<p>然而在CSS中，W3C文档把尺寸单位划为为两类：相对长度单位和绝对长度单位。然而相对长度单位按照不同的参考元素，又可以分为字体相对单位和视窗相对单位。字体相对单位有：em、ex、ch、rem；视窗相对单位则包含：vw、vh、vmin、vmax几种。绝对定位则是固定尺寸，它们采用的是物理度量单位：cm、mm、in、px、pt以及pc。但在实际应用中，我们使用最广泛的则是em、rem、px以及百分比（%）来度量页面元素的尺寸。</p>

<ol>
<li>px：为像素单位。它是显示屏上显示的每一个小点，为显示的最小单位。它是一个绝对尺寸单位；</li>
<li>em：它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；</li>
<li>%： 百分比，它是一个更纯粹的相对长度单位。它描述的是相对于父元素的百分比值。如50%，则为父元素的一半。</li>
</ol>


<p>这里需要注意的是：em是相对于应用于当前当前元素的字体尺寸；而百分比则是相对于父元素的尺寸。如下面示例：</p>

<p>HTML：</p>

<pre class='green'><code>&lt;div class="parent"&gt;
     &lt;div class="em-demo"&gt;
      设置长度为5em demo
     &lt;/div&gt;

     &lt;div class="percentage-demo"&gt;
      设置长度为80% demo
     &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>CSS：</p>

<pre class='green'><code>div{
    border: 1px dashed #808080;
    margin:10px
}

.parent{
    width: 200px;
    font-size: 18px;
}

.em-demo{
    width: 5em;
}

.percentage-demo{
    width: 80%
}
</code></pre>

<p>则其效果图为(<a href="http://jsbin.com/xihusojale/edit?html,css,output">http://jsbin.com/xihusojale/edit?html,css,output</a>)：</p>

<p><img src="http://greengerong.github.io/images/blog_img/em-percentage-demo.png" alt="em percentage demo" /></p>

<p>从图上我们可以看出：设置5em的div的第一行字符刚好为5个字符大小，因为如上所说，它是相对于当前元素字体的尺寸， 5 * 18 = 90px。而百分比显示则会比较大一些，因为它是相对于父元素的尺寸比例， 200 * 80% = 160px。</p>

<p>对于px、em和百分比都能设置元素的尺寸和字体大小，但是它们各自有自己所不同的应用场景。不合理的运用，则会导致页面的混乱、难易维护和扩展。对于它们的使用，有如下几点被大家所认同的最佳实践：</p>

<ol>
<li>尽量使用相对尺寸单位</li>
</ol>


<p>使用相对尺寸单位计量，则在调整页面的布局的时候，不需要遍历所有的内部DOM结构，重新设置内部子元素的尺寸大小，同时它也能更好的适应与多中分辨率和屏幕终端。采用相对定位，并不意味着页面整体的自适应。</p>

<p>当然，对于希望整体网站的“响应式设计”，适应当今层出不穷的的各类访问终端，相对尺寸布局将发挥更大的价值。我们仅需要利用CSS3的@media查询来设置外围的整体宽度，以及少量在设备上不一致的用户体验。关于“响应式布局”，可以更多的参考bootstrap这类新兴的CSS框架。</p>

<p>对于相对尺寸单位的设置：em和%因为它们相对的参考物不同，所以它们也有不同的使用场景。如果希望随着当前元素的字体尺寸而改变尺寸，则使用em最佳，如：行高、字体大小。相反，如果是随着父容器或者是整体页面布局而改变尺寸，则使用%更好，如元素的高度和宽度设置。</p>

<ol>
<li>只在可预知的元素上使用绝对尺寸</li>
</ol>


<p>并不是所有的元素设置相对尺寸就是最佳的。对于如图表icon、如video这类多媒体元素、网页整体的宽度这类可预知尺寸，设置为绝对路径可能反而是最佳的选择。但他们需要试具体场景而定，从而获得最佳体验。不管我们如此设置相对尺寸，但在外层也总会有一些绝对尺寸度量，才可能存在百分比这类相对尺寸设置。</p>

<ol>
<li>字体尺寸尽量使用em、rem</li>
</ol>


<p>和尽量使用相对尺寸单位一样，为了字体大小的可维护性和伸缩性，W3C更推荐使用em作为字体尺寸单位。需要注意的是，如果存在3层以及3层以上的字体相对尺寸的设置，则对于实际字体大小的计算，就会变得相对麻烦。这个时候，在满足浏览器兼容性的情况下，可以考虑使用CSS3的新特性rem：根据固定根元素的字体大小来设置相对尺寸大小，这也是近几年移动APP所兴起的使用方式。</p>

<p>rem的兼容性，我们可以用<a href="http://caniuse.com/#feat=rem">Can I Use</a>网站获取。</p>

<p><img src="http://greengerong.github.io/images/blog_img/rem-%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="rem 兼容性" /></p>

<ol>
<li>@media查询做平台适配，但禁止随处滥用</li>
</ol>


<p>如上所说CSS3的@media查询，能帮助我们做到多平台终端的自适应布局，得到一个更好的用户体验。但这绝不意味着我们可以随处滥用它，在CSS代码中存在太多的平台差异的代码，这也会增加代码可读性、维护性的难度。更好的方式则是仅在必须使用它的场景下，合理的使用它，如页面外围的整体宽度，不同显示的菜单栏等。更多的体验适应性，可以移动到使用“流式布局”来实现。</p>

<p>关于响应式设计，这是对开发周期、成本和平台体验的一个权衡的结果。如果不考虑开发、维护的成本，则为不同平台终端提供不同的页面设计，这样得到的用户体验会更友好。但在实际开发中，开发和维护成本、产品生命周期也是一个重要的权衡标准，而响应式设计则是它们之间的权衡结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多彩的Console打印新玩法]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/28/duo-cai-de-consolexin-wan-fa/"/>
    <updated>2015-09-28T08:53:40+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/28/duo-cai-de-consolexin-wan-fa</id>
    <content type="html"><![CDATA[<p>Chrome应该是每一个Web开发者必备的工具之一。它有而强大的Devtool，辅助我们的JavaScript调试，审视DOM元素，CSS即时修改等。以及它还有一个的庞大的插件系统，同时我们也可以很容易的扩展属于自己的Chrome插件。如果希望了解更多的Chrome常用调试，请参见笔者早期的微信推送文章<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTM1NDcyOQ==&amp;mid=204026297&amp;idx=1&amp;sn=47294644cc7298ea3c57736ed0a75173&amp;scene=23&amp;srcid=0928aP9a3QHDyTOtc2Nhrszw#rd">《15个必须知道的chrome开发者技巧》</a>。</p>

<p>Chrome中的控制台console，是我们检查程序允许是否正常的常用工具之一，同时它也是我们打印调试日志信息，运行调试代码的常用工具。在国内近几年，它也成为了程序员招聘的渠道之一。如下面百度的招聘信息：</p>

<p><img src="http://greengerong.github.io/images/blog_img/baidu-console-recruitment.png" alt="百度console招聘" /></p>

<p>在Console中打印日志的方式有log、info、warn、error这几类方式。但它们并不是本文的主题。对于日志信息打印来说，一直都显得很单调。直到最新版的Chrome和Firefox (+31)，我们可以尝试更多多彩的打印格式了。在最新的Google chrome文档中console.log支持如下的格式：</p>

<ol>
<li>%s   字符串格式化；</li>
<li>%d/%i    整数格式化；</li>
<li>%f   小数位数据格式化；</li>
<li>%o   可扩展的DOM节点格式化；</li>
<li>%O   可扩展的JavaScript对象格式化；</li>
<li>%c   利用CSS来自定义样式格式化输出。</li>
</ol>


<p>本文将要说的就是%c这个格式化器。我们可以利用CSS样式来控制打印信息的输出。这样我们就可以得到一个多彩的日志信息，或者就是招聘广告了。</p>

<p>下面代码输出效果为：</p>

<pre class='green'><code>console.log('%c [破狼]-[双狼说]!', 'background: #008000; color: #fff');
</code></pre>

<p>效果：</p>

<p><img src="http://greengerong.github.io/images/blog_img/console-log-po-lang.png" alt="彩色的console log" /></p>

<p>再如：下面这段来自<a href="http://stackoverflow.com/questions/7505623/colors-in-javascript-console">http://stackoverflow.com/questions/7505623/colors-in-javascript-console</a>示例，文字光影的效果：</p>

<p>代码比较长，请移步到stackoverflow查看。这里主要是利用的text-shadow这个CSS3特性来实现的，文字光影效果：</p>

<pre class='green'><code>var css = "text-shadow: -1px -1px hsl(0,100%,50%), 1px 1px hsl(5.4, 100%, 50%), 3px 2px hsl(10.8, 100%, 50%), .....";// 

console.log("%cExample %s", css, 'all code runs happy');
</code></pre>

<p>效果如下：</p>

<p><img src="http://greengerong.github.io/images/blog_img/console-log-demo-colorful-code.jpg" alt="彩色的console log" /></p>

<p>在github也有<a href="https://github.com/adamschwartz/log">log</a>的repo，感兴趣的读者也可以研究研究。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细说ES7 JavaScript Decorators]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/24/es7-javascript-decorators/"/>
    <updated>2015-09-24T15:00:40+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/24/es7-javascript-decorators</id>
    <content type="html"><![CDATA[<h2>开篇概述</h2>

<p>在上篇的<a href="http://greengerong.com/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>中，我们预先体验了ES7的Decorators，虽然它只是一个简单的日志AOP拦截Demo。但它也足以让我们体会到ES7 Decorators的强大魅力所在。所以为什么博主会为它而专门写作此文。在Angular2中的TypeScript Annotate就是标注装潢器的另一类实现。同样如果你也是一个React的爱好者，你应该已经发现了redux2中也开始利用ES7的Decorators进行了大量重构。</p>

<p>尝试过Python的同学们，我相信你做难忘的应该是装潢器。由<a href="https://github.com/wycats">Yehuda Katz</a>提出的<a href="https://github.com/wycats/javascript-decorators">decorator模式</a>，就是借鉴于Python的这一特性。作为读者的你，可以从上一篇博文<a href="http://greengerong.com/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>中看到它们之间的联系。</p>

<h2>Decorators</h2>

<h4>背后原理</h4>

<p>ES7的Decorators让我们能够在设计时对类、属性等进行标注和修改成为了可能。Decorators利用了ES5的</p>

<pre class='green'><code>Object.defineProperty(target, name, descriptor);
</code></pre>

<p>来实现这一特性。如果你还不了解Object.defineProperty，请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN文档</a>。首先我们来考虑一个普通的ES6类：</p>

<pre class='green'><code>class Person {
  name() { return `${this.first} ${this.last}` }
}
</code></pre>

<p>执行这一段class，给Person.prototype注册一个name属性，粗略的和如下代码相似：</p>

<pre class='green'><code>Object.defineProperty(Person.prototype, 'name', {
  value: specifiedFunction,
  enumerable: false,
  configurable: true,
  writable: true
});
</code></pre>

<p>如果利用装潢器来标注一个属性呢？</p>

<pre class='green'><code>class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}
</code></pre>

<p>在这种装潢下的属性，则会在利用Object.defineProperty为Person.prototype注册name属性之前，执行这段装潢器：</p>

<pre class='green'><code>let descriptor = {
  value: specifiedFunction,
  enumerable: false,
  configurable: true,enumerable、
  writable: true
};

descriptor = readonly(Person.prototype, 'name', descriptor) || descriptor;
Object.defineProperty(Person.prototype, 'name', descriptor);
</code></pre>

<p>从上面的伪代码中，我们能看出，装潢器只是在Object.defineProperty为Person.prototype注册属性之前，执行一个装饰函数，其属于一类对Object.defineProperty的拦截。所以它和Object.defineProperty具有一致的方法签名，它们的3个参数分别为：</p>

<ol>
<li>obj：作用的目标对象；</li>
<li>prop：作用的属性名；</li>
<li>descriptor: 针对该属性的描述符。</li>
</ol>


<p>这里最重要的是descriptor这个参数，它是一个数据或访问器的属性描述对象。在对数据和访问器属性描述时，它们都具有configurable、enumerable属性可用。而在数据描述时，value、writable属性则是数据所特有的。get、set属性则是访问器属性描述所特有的。属性描述器中的属性决定了对象prop属性的一些特性。比如 enumerable，它决定了目标对象是否可被枚举，能够在for…in循环中遍历到，或者出现在Object.keys法的返回值中；writable则决定了目标对象的属性是否可以被更改。完整的属性描述，请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description">MDN文档</a>。</p>

<p>对于descriptor中的属性，它们可以被我们在Decorators中使用，或者修改的，以达到我们标注或者拦截的目的。这也是装潢器拦截的主体信息。</p>

<h4>作用于访问器</h4>

<p>装潢器也可以作用与属性的getter/setter访问器之上，如下将属性标注为不可枚举的代码：</p>

<pre class='green'><code>class Person {
  @nonenumerable
  get kidCount() { return this.children.length; }
}

function nonenumerable(target, name, descriptor) {
  descriptor.enumerable = false;
  return descriptor;
}
</code></pre>

<p>下面是一个更复杂的对访问器的备用录模式运用：</p>

<pre class='green'><code>class Person {
  @memoize
  get name() { return `${this.first} ${this.last}` }
  set name(val) {
    let [first, last] = val.split(' ');
    this.first = first;
    this.last = last;
  }
}

let memoized = new WeakMap();
function memoize(target, name, descriptor) {
  let getter = descriptor.get, setter = descriptor.set;

  descriptor.get = function() {
    let table = memoizationFor(this);
    if (name in table) { return table[name]; }
    return table[name] = getter.call(this);
  }

  descriptor.set = function(val) {
    let table = memoizationFor(this);
    setter.call(this, val);
    table[name] = val;
  }
}

function memoizationFor(obj) {
  let table = memoized.get(obj);
  if (!table) { table = Object.create(null); memoized.set(obj, table); }
  return table;
}   
</code></pre>

<h4>作用域类上</h4>

<p>同样Decorators也可以为class装潢，如下对类是否annotated的标注：</p>

<pre class='green'><code>// A simple decorator
@annotation
class MyClass { }

function annotation(target) {
   // Add a property on target
   target.annotated = true;
}
</code></pre>

<h4>也可以是一个工厂方法</h4>

<p>对于装潢器来说，它同样也可以是一个工厂方法，接受配置参数信息，并返回一个应用于目标函数的装潢函数。如下例子，对类可测试性的标记：</p>

<pre class='green'><code>@isTestable(true)
class MyClass { }

function isTestable(value) {
   return function decorator(target) {
      target.isTestable = value;
   }
}
</code></pre>

<p>同样工厂方法，也可以被应用于属性之上，如下对可枚举属性的配置：</p>

<pre class='green'><code>class C {
  @enumerable(false)
  method() { }
}

function enumerable(value) {
  return function (target, key, descriptor) {
     descriptor.enumerable = value;
     return descriptor;
  }
}
</code></pre>

<p>同样在上篇<a href="http://greengerong.com/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>中对于日志拦截的日志类型配置信息，也是利用工厂方法来实现的。它是一个更复杂的工厂方式的Decorators实现。</p>

<h4>后续</h4>

<p>如上一篇博问所说：虽然它是ES7的特性，但在Babel大势流行的今天，我们可以利用Babel来使用它。我们可以利用Babel命令行工具，或者grunt、gulp、webpack的babel插件来使用Decorators。</p>

<p>关于ES7 Decorators的更有意思的玩法，你可以参见牛人实现的常用的Decorators：<a href="https://github.com/jayphelps/core-decorators.js">core-decorators</a>。以及<a href="http://raganwald.com/">raganwald</a>的<a href="http://raganwald.com/2015/06/26/decorators-in-es7.html">如何用Decorators来实现Mixin</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES7之Decorators实现AOP示例]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/"/>
    <updated>2015-09-23T07:11:07+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li</id>
    <content type="html"><![CDATA[<p>在上篇博文<a href="http://greengerong.com/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>中，笔者利用CoffeeScript支持的高阶函数，以及方法调用可省略括符的特性，实现了一个类似Python装潢器的日志Demo。这只是一种伪实现，JavaScript实现装潢器，我们需要等到ECMAScript7才行，在ES7特性中带来了Decorators，它就是我们所需要的装潢器特性。虽然它是ES7的特性，但在Babel大势流行的今天，我们可以利用Babel来使用它。关于Babel的推荐文章，请参见另一篇文章<a href="http://greengerong.com/blog/2015/03/22/babel-kai-shi-es6ti-yan/">Babel-现在开始使用 ES6</a>。</p>

<p>下面我们仍然和上节<a href="http://greengerong.com/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>一样，实现一个ES7 Decorators版的日志拦截示例。我们希望得到的代码效果如下：</p>

<pre class='green'><code>class MyClass {
  @log('MyClass add')
  add(a, b){
    return a + b;
  }
  @log('MyClass product')
  product(a, b){
    return a * b;
  }
  @log('MyClass error')
  error(){
     throw 'Something is wrong!';
   }
}
</code></pre>

<p>在ES7中Decorators，也是一个函数，我们只需要在它前面加上@符号，并将它标注在特定的目标，如class、method等，则可以实现方法的包裹拦截。它的传入参数有：target, name, descriptor。它们分别标记目标，标记目标名称，以及目标描述信息。在descriptor中，包括configurable、enumerable、writable，value四个属性。它们分别可以控制目标的读写、枚举，以及目标值。</p>

<p>所以我们可以如下实现：</p>

<pre class='green'><code>let log = (type) =&gt; {
    const logger = new Logger('#console');
    return (target, name, descriptor) =&gt; {
      const method = descriptor.value;
      descriptor.value =  (...args) =&gt; {
            logger.info(`(${type}) before function execute: ${name}(${args}) = ?`);
            let ret;
            try {
                ret = method.apply(target, args);
                logger.info(`(${type})after function execute success: ${name}(${args}) =&gt; ${ret}`);
            } catch (error) {
                logger.error(`(${type}) function execute error: ${name}(${args}) =&gt; ${error}`);
            } finally {
                logger.info(`(${type}) function execute done: ${name}(${args}) =&gt; ${ret}`);
            }
            return ret;
        }
    }
}
</code></pre>

<p>首先我们将原来的方法体缓存起来，直到方法调用时，才会被调用以实现方法调用前后的日志拦截，打印相关信息。示例的效果如下：</p>

<p><img src="http://greengerong.github.io/images/blog_img/es7-decorators-log-aop.png" alt="es7 decorators log aop" /></p>

<p>整个demo示例，你也可以在codepen上细细把玩：</p>

<p data-height="350" data-theme-id="0" data-slug-hash="epzbMV" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/epzbMV/'>ES7 Decorators</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async="true" src="http://greengerong.github.io//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoffeeScript实现Python装潢器]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/"/>
    <updated>2015-09-22T21:09:03+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi</id>
    <content type="html"><![CDATA[<p>在上篇<a href="http://greengerong.com/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/">Angular遇上CoffeeScript &ndash; NgComponent封装</a>中，我们讲述了CoffeeScript这门小巧的语言，摒弃JavaScript中糟粕（“坑”）部分，并将JavaScript中精粹部分发挥到淋淋尽致。虽然笔者更喜欢ES6 + Babel或者TypeScript这类鲜明特性的JavaScript语法。但是CoffeeScript也不失为一门不错的JavaScript扩展语言，特别在Ruby社区仍然是一个很好的选择。</p>

<p>在本节中，我们将会利用CoffeeScript来模拟Python中的装潢器实现。Python的装潢器是属于一类来自于语言层次的AOP实现。AOP是Aspect-Oriented Programming的缩写，意为：面向切面编程。通过编译时（Compile）植入代码、运行期（Runtime）动态代理、以及框架提供管道式执行等策略实现程序通用功能与业务模块的分离，统一处理、维护的一种解耦设计。AOP是OOP的延续，是软件开发中的一个热点，也是很多服务端框架（如Java世界的Spring）中的核心内容之一，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可复用性，同时提高开发效率。 AOP实用的场景主要有：权限控制、日志模块、事务处理、性能统计、异常处理等独立、通用的非业务模块。关于更多的AOP资料请参考<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a>。</p>

<p>在Python中的装潢器也是一个普通的函数，我们只需要使用@符号将方法标注在另一个方法签名上就能实现对被标注方法的装潢。这也是Python这门函数式语言中高阶函数的运用。被装潢的方法将会被传入装潢函数中，被装潢包裹以实现方法的拦截。</p>

<p>Python中的装潢器如下：</p>

<pre class='green'><code>def deco(func):
    def _deco(*args, **kwargs):
        print("before %s called." % func.__name__)
        ret = func(*args, **kwargs)
        print("  after %s called. result: %s" % (func.__name__, ret))
        return ret
    return _deco

@deco
def myfunc(a, b):
    print(" myfunc(%s,%s) called." % (a, b))
    return a+b
</code></pre>

<p>这里的装潢器deco，将会包裹myfunc方法，实现调用前后的日志信息拦截。</p>

<p>在CoffeeScript中，我们如何实现呢？在CoffeeScript并没有真正的装潢器这一特性，但它存在高阶函数，可以如下包裹：</p>

<pre class='green'><code>log(myfunc)
</code></pre>

<p>在CoffeeScript中，我们也可以简化去掉方法（）符号：</p>

<pre class='green'><code>log myfunc
</code></pre>

<p>如果我们再像Python一样强制加上@符号，并将log函数放在方法声明右边，则似乎就有点接近Python的装潢器：</p>

<pre class='green'><code>f = @log (a, b) -&gt; a + b
</code></pre>

<p>不知作为读者的你，是否也有点装潢的感觉呢？不用着急，我们在来看一个完整的demo示例：</p>

<p data-height="268" data-theme-id="0" data-slug-hash="wKKQKv" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/wKKQKv/'>CoffeeScript- decorator</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async="true" src="http://greengerong.github.io//assets.codepen.io/assets/embed/ei.js"></script>


<p>这里利用了高阶函数的log函数来包装我们的自定义函数。其实这只是高阶函数的运用，如果这门语法也能省略掉方法调用的（），则完全也可以做到如上实现。希望作为读者的你，到这里已经明白的在函数式中高阶函数的魅力，以及其重要性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verlet-js JavaScript 物理引擎]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing/"/>
    <updated>2015-09-19T22:20:34+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing</id>
    <content type="html"><![CDATA[<p>subprotocol最近在Github上开源了verlet-js。地址为<a href="https://github.com/subprotocol/verlet-js">https://github.com/subprotocol/verlet-js</a>。verlet-js是一个集成Verlet的物理引擎，利用JavaScript编写。verlet-js支持粒子系统、距离限制、角度限制等。其Github声称基于这些基础，则可以帮助我们构建几乎任何我们所能想象到的东西。</p>

<p>其官网为我们提供了一下几个demo：</p>

<ol>
<li><a href="http://subprotocol.com/verlet-js/examples/shapes.html">Shapes (verlet-js Hello world)</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/tree.html">Fractal Trees</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/cloth.html">Cloth</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/spiderweb.html">Spiderweb</a></li>
</ol>


<p>笔者觉得<a href="http://subprotocol.com/verlet-js/examples/spiderweb.html">Spiderweb</a>特别有意思，下面是它的效果截图：</p>

<p><img src="http://greengerong.github.io/images/blog_img/verlet-js-Spiderweb.png" alt="verlet-js Spiderweb" /></p>

<p><img src="http://greengerong.github.io/images/blog_img/verlet-js-cloth.png" alt="verlet-js Spiderweb" /></p>

<p>Github地址：<a href="https://github.com/subprotocol/verlet-js">https://github.com/subprotocol/verlet-js</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML5特性速记图]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/15/html5te-shu-su-ji-tu/"/>
    <updated>2015-09-15T15:03:35+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/15/html5te-shu-su-ji-tu</id>
    <content type="html"><![CDATA[<p>今天推荐大家一张HTML5特性速记图，供大家平时查阅，也可以打印放在电脑旁帮助速记、速查。此图笔者收集于网络图片。</p>

<p><img src="http://greengerong.github.io/images/blog_img/HTML5%E7%89%B9%E6%AE%8A%E9%80%9F%E8%AE%B0%E5%9B%BE.PNG" alt="angualr meet coffeescript" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular遇上CoffeeScript - NgComponent封装]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/"/>
    <updated>2015-09-12T22:09:23+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang</id>
    <content type="html"><![CDATA[<p><img src="http://greengerong.github.io/images/blog_img/Angular-meetting-CoffeeScript.jpg" alt="angualr meet coffeescript" /></p>

<p>CoffeeScript是基于JavaScript的一门扩展小巧语言，它需要编译成JavaScript，然后再运行与浏览器或者Nodejs平台。JavaScript由于商业原因10天时间就匆忙诞生，所以存在很多弊病。但如《JavaScript精粹》一书中所说：JavaScript也存在着一颗华丽的心脏，如果我们能避开JavaScript中的“坑”，使用其精华的部分，这将是一门令人爱不释手的语言. 而CoffeeScript则是尝试使用这部分简洁的方式展示JavaScript的这部分优秀的精华，避免那些困扰JavaScript开发者的“坑”.CoffeeScript借鉴于Python和Ruby这两门语言，函数式风格、鸭子类型、OO风格一体的一门简洁语言。</p>

<p>Angularjs从2012年以来是火极一时的前端MVVM框架，它引入了module、双向绑定、依赖注入、Directive、MVVM等机制。更多资料参见博主其他博文。当Angular遇见CoffeeScript这门语言，将会发生什么呢？</p>

<p>想让我们来看一眼笔者利用CoffeeScript对Angular1.x代码的封装后效果。</p>

<pre class='green'><code>## controller
class DemoController extends NgComponent
   @inject 'demoService'
   @controller 'ng.green.demo'   

   __init__: =&gt;
      @demoService.getLang().then (data) =&gt;
        @lang = data 

## service  
class DemoService extends NgComponent
   @inject '$q'
   @service 'ng.green.demo' 

   getLang: =&gt;
      data = data : ['JavaScript', 'CoffeeScript', 'TypeScript', 'ES6']
      @$q.when(data)

## directive controller   
class JsonDumpController extends NgComponent
   @inject '$log'
   @controller 'ng.green.demo'   

   __init__: =&gt;
      @$log.info('This is form directive controller')

## directive       
class JsonDumpDirective extends NgComponent
  @inject '$timeout', '$http', '$cacheFactory', '$log'
  @directive 'ng.green.demo' 
  restrict: 'EA'
  templateUrl: '/jsonDump.html'
  scope: 
    json: "="
  controller: 'JsonDumpController'
  link: (scope, elm, iAttrs) =&gt;
    @$timeout (() =&gt; @$log.info '$timeout &amp; $log injector worked on link function!' ), 100
</code></pre>

<p>有了上面的对controller、service、directive的定义，则我们可以如下方式使用：</p>

<pre class='green'><code>&lt;div ng-app="ng.green.demo" ng-controller="DemoController as demo" class="container"&gt;
  &lt;json-dump json="demo.lang"&gt;&lt;/json-dump&gt;
  &lt;script type="text/ng-template" id="/jsonDump.html"&gt; 
  &lt;hr /&gt;
  &lt;pre&gt;&lt;/pre&gt;
&lt;/script&gt; 
&lt;/div&gt;
</code></pre>

<p>不知各位看官对如上代码感觉如何？是不是更简化、语义化、有点ng的感觉。其中笔者还有意模仿Python，如<strong>init</strong>作为初始化方式。在这里每个class会自声明组件类型，以及声明式注入，module自注册。</p>

<p>不管如何看，下面我来看看NgComponent到底做了什么？</p>

<pre class='green'><code>class NgComponent
    @controller: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName(true)
      angular.module(moduleName, moduleResolver).controller componentName, @      

    @service: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName()
      angular.module(moduleName, moduleResolver).service componentName, @

    @directive: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName().replace('Directive','')
      directiveClass = @
      directiveFactory = (args...) -&gt;
          new directiveClass(args...)          
      directiveFactory.$inject = @$inject
      angular.module(moduleName, moduleResolver).directive componentName, directiveFactory    

    @$$componentName: (upperCaseFirstLetter = false) -&gt;
      # regex for ie
      componentName = @name || @toString().match(/function\s*(.*?)\(/)?[1]
      if upperCaseFirstLetter
       firstLetter =  componentName.substr(0,1).toUpperCase()
      else
        firstLetter = componentName.substr(0,1).toLowerCase()
      (componentName = "#{firstLetter}#{componentName.substr(1)}") unless upperCaseFirstLetter
      componentName

    @inject: (args...) -&gt;
      @$inject = args

    constructor: (args...) -&gt;
      for key, index in @constructor.$inject
        @[key] = args[index]

      @__init__?()
</code></pre>

<p>在NgComponent中定义了controller、service、directive注册接口，这里可以是声明创建module，也可以是在已声明的module上注册这些组件类型。对于组件命名也才采用了约定胜于配置，它们都以class类型为基础，controller为首字母大写的驼峰命名，service则首字母小写驼峰命名，directive则会去掉Directive标记并首字母小写注册。</p>

<p>同时这里也声明了@inject方法，使得我们可以在定义在类型之上定义$inejct属性，Angular的注入声明。对于Angular的注入服务，在构造函数中会将他们一一添加到当前类实例对象之上。在依赖添加完毕后，也会调用对象初始化方法，这里是模拟Python的<strong>init</strong>。</p>

<p>Demo效果可以在codepen查看 <a href="http://codepen.io/greengerong/pen/EVVQZg?editors=101">http://codepen.io/greengerong/pen/EVVQZg?editors=101</a>：</p>

<p data-height="268" data-theme-id="0" data-slug-hash="EVVQZg" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/EVVQZg/'>Angular meet CoffeeScript</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://greengerong.github.io//assets.codepen.io/assets/embed/ei.js"></script>


<p>本文笔者的突发奇想，希望能给读者一些启发，也许你还有更好的DSL封装，欢迎多多交流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展Bootstrap Tooltip插件使其可交互]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/09/kuo-zhan-bootstrap-tooltipcha-jian-shi-qi-ke-jiao-hu/"/>
    <updated>2015-09-09T13:20:20+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/09/kuo-zhan-bootstrap-tooltipcha-jian-shi-qi-ke-jiao-hu</id>
    <content type="html"><![CDATA[<p>最近在公司某项目开发中遇见一特殊需求，请笔者帮助，因此有了本文的插件。在前端开发中tooltip是一个极其常用的插件，它能更好向使用者展示更多的文档等帮助信息。它们通常都是一些静态文本信息。但同事他们的需求是需要动态交互，在文本信息中存在帮助网页的链接。如果使用常规tooltip，则在用户移出tooltip依赖DOM节点后，tooltip panel则将被隐藏。所以用户没有办法点击到这些交互链接。</p>

<p>所以我们期望：给用户一定的时间使得用户能够将鼠标从依赖节点移动到tooltip panel；并且如果用户鼠标停留在tooltip上则不能隐藏，使得用户能够与位于tooltip上的链接或者是其他form表单控件交互。</p>

<p>也许你觉得这并不难，在网上Google就有很多代码可直接使用。是的，如下面这段来自plnkr.co的代码（<a href="http://plnkr.co/edit/x2VMhh?p=preview">http://plnkr.co/edit/x2VMhh?p=preview</a>）：</p>

<pre class='green'><code>$(".pop").popover({ trigger: "manual" , html: true, animation:false})
    .on("mouseenter", function () {
        var _this = this;
        $(this).popover("show");
        $(".popover").on("mouseleave", function () {
            $(_this).popover('hide');
        });
    }).on("mouseleave", function () {
        var _this = this;
        setTimeout(function () {
            if (!$(".popover:hover").length) {
                $(_this).popover("hide");
            }
        }, 300);
});
</code></pre>

<p>它是使用bootstrap的popover来实现的，从bootstrap的源码能看到popover是继承至tooltip的组件之一。这里是通过将popover的触发方式设为手动触发，由我们自己来控制显示和隐藏它的时机。并且在依赖节点离开的时候，给定300ms的延迟等待用户进入tooltip panel，如果300ms还没有进入tooltip则隐藏它。否则就阻止隐藏tooltip的逻辑。</p>

<p>这代码虽然功能可用，但具有代码洁癖的博主并不太满意这样的代码。它难以阅读维护，同时重用性也将极差。所以笔者决定要以bootstrap插件方式来一bs way写这款插件。</p>

<p>当笔者查阅bootstrap tooltip源码时，发现它是一个扩展性很不错的插件。tooltip的显示和隐藏依赖于它内部的hoverState状态来控制，in代表在依赖节点元素之上，out则代表移出了DOM元素。并且它也支持延迟动画机制。所以我们可以如下方式控制hoverState的状态：</p>

<pre class='green'><code>var DelayTooltip = function (element, options) {
    this.init('delayTooltip', element, options);
    this.initDelayTooltip();
};

DelayTooltip.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    trigger: 'hover',
    delay: {hide: 600}
});

DelayTooltip.prototype.delayTooltipEnter = function(){
        this.hoverState = 'in';
    };

    DelayTooltip.prototype.delayTooltipLeave = function(){
        this.hoverState = 'out';
        this.leave(this);
    };

  DelayTooltip.prototype.initDelayTooltip = function(){
      this.tip()
          .on('mouseenter.'  +  this.type, $.proxy(this.delayTooltipEnter, this))
          .on('mouseleave.' + this.type, $.proxy(this.delayTooltipLeave, this));
  };
</code></pre>

<p>这里在构造tooltip对象同时也注册tooltip panel的mouseenter、mouseleave.事件，并设置对应的hoverState状态。当移出tooltip panel时，这里需要手动的调用来自tooltip继类的leave方法。对于隐藏延时则设置在默认option中，使其能够可配置。</p>

<p>上面的代码就是我们所需要扩展tooltip的所有的代码。当然要想作为一个通用的bootstrap插件，还需要它固定的插件配置代码。插件全部代码如下：</p>

<pre class='green'><code>(function ($) {
  'use strict';

  var DelayTooltip = function (element, options) {
    this.init('delayTooltip', element, options);
    this.initDelayTooltip();
  };

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');

  DelayTooltip.VERSION  = '0.1';

  DelayTooltip.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    trigger: 'hover',
    delay: {hide: 300}
  });

  DelayTooltip.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

  DelayTooltip.prototype.constructor = DelayTooltip;

  DelayTooltip.prototype.getDefaults = function () {
    return DelayTooltip.DEFAULTS;
  };

    DelayTooltip.prototype.delayTooltipEnter = function(){
        this.hoverState = 'in';
    };

    DelayTooltip.prototype.delayTooltipLeave = function(){
        this.hoverState = 'out';
        this.leave(this);
    };

  DelayTooltip.prototype.initDelayTooltip = function(){
      this.tip()
          .on('mouseenter.'  +  this.type, $.proxy(this.delayTooltipEnter, this))
          .on('mouseleave.' + this.type, $.proxy(this.delayTooltipLeave, this));
  };

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this);
      var data    = $this.data('bs.delayTooltip');
      var options = typeof option == 'object' &amp;&amp; option;

      if (!data &amp;&amp; /destroy|hide/.test(option)) return;
      if (!data) $this.data('bs.delayTooltip', (data = new DelayTooltip(this, options)));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.delayTooltip;

  $.fn.delayTooltip             = Plugin;
  $.fn.delayTooltip.Constructor = DelayTooltip;

  $.fn.delayTooltip.noConflict = function () {
    $.fn.delayTooltip = old;
    return this;
  };

})(jQuery);
</code></pre>

<p>这里基本都是bootstrap插件机制的固定模板，仅仅需要套用上就行。有了这个插件扩展，那么我们就可以如下使用这款插件：你也可以在jsbin中查看效果<a href="http://jsbin.com/wicoki/edit?html,js,output">http://jsbin.com/wicoki/edit?html,js,output</a>:</p>

<p>HTML:</p>

<pre class='green'><code>&lt;div id="tooltip"&gt;bs tooltip:你能点击链接？&lt;/div&gt;
&lt;hr&gt;
&lt;div  id="delayTooltip"&gt;delay tooltip：尝试点击链接&lt;/div&gt;
&lt;hr&gt;
&lt;div id="delayTooltipInHtml" data-html="true" data-placement="bottom" data-toggle="delayTooltip"&gt;delay tooltip:利用html标签实现&lt;/div&gt;
</code></pre>

<p>JavaScript 代码：</p>

<pre class='green'><code>(function(global, $){

    var page = function(){

    };

    page.prototype.bootstrap = function(){
        var html = 'Weclome to my blog &lt;a target="_blank" href="greengerong.github.io"&gt;破狼博客&lt;/a&gt;!&lt;input type="text" placeholder="input some thing"/&gt;';
        $('#tooltip').tooltip( {
            html: true,
            placement: 'top',
            title: html
        });

        $('#delayTooltip').delayTooltip( {
            html: true,
            placement: 'bottom',
            title: html
        });

  $('#delayTooltipInHtml').attr('title', html).delayTooltip();

  return this;
};

     global.Page = page;

})(this, jQuery);

$(function(){
    'use strict';
  var page = new window.Page().bootstrap();
    //
});
</code></pre>

<p>这款插件既支持jQuery在HTML中声明属性的方式，同时也可以在javascript中使用。效果如下：</p>

<p><img src="http://greengerong.github.io/images/blog_img/delay-tooltip-example.png" alt="bootstrap dealy-tooltip" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端获取元素定位位置的法宝]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao/"/>
    <updated>2015-09-08T07:09:23+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao</id>
    <content type="html"><![CDATA[<p><img src="http://greengerong.github.io/images/blog_img/box-chrome.png" alt="box chrome" /></p>

<p>在前端开发中，我们经常需要定位一个元素。如tooltip、popover或者modal等，或许是我们需要将它们定位在依赖元素的周围或屏幕滚动屏幕中心位置。这对于前端开发的码农来说并不是难事。算出和依赖元素的offset，设置元素的left、right。对于稍复杂的场景我们可能需要考虑被positioned的祖先元素。</p>

<p>但往往不是所有的事情都是这么简单的。笔者最新在项目开发中就遇见这样一个问题：这里的HTML是嵌入的，其来自jpedal商业软件从PDF文件自动生成的；为了展示的样式，jpedal统一使用了 position:absolute和relative来定位PDF元素。然而由于业务的需求，我们需要操作这类HTML。其中一个需求就是需要在每段文字附近显示操作工具条。</p>

<p>对于这类未知的DOM定位，那么我们就需要遍历它的DOM树来计算它的相对位置了。行为下面的这段代码：</p>

<pre class='green'><code>    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent &amp;&amp; offsetParent !== docDomEl &amp;&amp; isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };
</code></pre>

<p>在这里，我们会根据元素递归查询它所在的的DOM树中被positioned的最接近的祖先元素，然后才计算它们的相对位置。</p>

<p>这是一段来自Angular-UI bootstrap的$position服务的源码。这也是本文将要提到的获取定位元素位置的法宝。其源码位置在<a href="https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js">https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js</a>。</p>

<p>在$position服务中为我们提供了3个有用的位置服务：position、offset和positionElements。position是计算具体元素的定位位置，返回一个带有width、height、top、left的对象；positionElements则是返回某元素相对于其依赖容器元素的定位位置，一个带有top、left的对象。</p>

<p>笔者为了测试这写API，在jsbin中写了一个特定的指令：</p>

<p>JavaScript:</p>

<pre class='green'><code>angular.module("com.ngbook.demo", ['ui.bootstrap.position'])
.directive('position', ['$position', function($position){
    return {
        restrict: 'EA',
        templateUrl: '/position.html',
        scope:{
            title:"@"
        },
        link:function(scope, elm, iAttrs){
        scope.data =  $position.position(elm);
       }
    };
}]);
</code></pre>

<p>HTML:</p>

<pre class='green'><code>&lt;script type="text/ng-template" id="/position.html"&gt;
   &lt;table class="table"&gt;
       &lt;thead&gt;
           &lt;th colspan="2"&gt;{{title}}&lt;/th&gt;
       &lt;/thead&gt;
    &lt;tbody&gt;
       &lt;tr ng-repeat="field in ['width', 'height', 'left', 'top']"&gt;
       &lt;td&gt;{{field}}&lt;/td&gt;
       &lt;td&gt;{{data[field] | number}}&lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
 &lt;/script&gt;
</code></pre>

<p>所以我们可以如下测试这类API：</p>

<pre class='green'><code>&lt;position title ="no positioned parent"&gt;&lt;/position&gt;

&lt;div style="position: relative;padding:50px;"&gt;
    &lt;position title ="relative parent"&gt;&lt;/position&gt;

     &lt;div style="position: absolute;top:250px; padding:50px;"&gt;
         &lt;position title="relative-&gt;absolute parent"&gt;&lt;/position&gt;
     &lt;/div&gt;
 &lt;/div&gt;

 &lt;div style="position: absolute;top:0px;left:250px; padding:50px;"&gt;
         &lt;position title="absolute parent"&gt;&lt;/position&gt;
 &lt;/div&gt;
</code></pre>

<p>其效果可以在<a href="http://jsbin.com/deximu/edit?html,js,output">jsbin demo</a>:</p>

<p><img src="http://greengerong.github.io/images/blog_img/ng-$position-example.png" alt="$position demo" /></p>

<p>同样你也可以在官方的文档中看见对它的测试: <a href="https://github.com/angular-ui/bootstrap/blob/master/src/position/test/test.html">https://github.com/angular-ui/bootstrap/blob/master/src/position/test/test.html</a>。</p>

<p>简单的说：如果我们需要获取某个元素的定位信息，则我们可以用 $position.position(element)；获取相对于固定元素的定位，则可以使用$position.positionElements(hostEl, targetEl, positionStr, appendToBody)。其中positionStr是一个横向和纵向的字符串，如：&#8221;top-left&#8221;、&#8221;bottom-left&#8221;。其默认值为center。如笔者项目所期望的在某文字段落的左上角显示工具条：</p>

<pre class='green'><code>$position.after($toolbar);
var elPosition = $position.positionElements($paragraph, $toolbar, “top-left”);
$toolbar.css({left: elPosition.left + 'px', top: elPosition.top + 'px'});
</code></pre>

<p>当然也不要忘记为toolbar元素设置position: absolute;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular Input格式化]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/03/angular-inputge-shi-hua/"/>
    <updated>2015-09-03T16:29:35+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/03/angular-inputge-shi-hua</id>
    <content type="html"><![CDATA[<p>今天在Angular中文群有位同学问到：如何实现对input box的格式化。如下的方式对吗？</p>

<pre class='green'><code> &lt;input type="text" ng-model="demo.text | uppercase" /&gt;
</code></pre>

<p>这当然是不对的。在Angular中filter（过滤器）是为了显示数据的格式，它将$scope上的Model数据格式化View显示的数据绑定到DOM之上。它并不会负责ngModel的绑定值的格式化。</p>

<p>在Angular中ngModel作为Angular双向绑定中的重要组成部分，负责View控件交互数据到$scope上Model的同步。当然这里存在一些差异，View上的显示和输入都是字符串类型，而在Model上的数据则是有特定数据类型的，例如常用的Number、Date、Array、Object等。ngModel为了实现数据到Model的类型转换，在ngModelController中提供了两个管道数组$formatters和$parsers，它们分别是将Model的数据转换为View交互控件显示的值和将交互控件得到的View值转换为Model数据。它们都是一个数组对象，在ngModel启动数据转换时，会以UNIX管道式传递执行这一系列的转换。Angular允许我们手动的添加$formatters和$parsers的转换函数（unshift、push）。同时在这里也是做数据验证的最佳时机，能够转换意味应该是合法的数据。</p>

<p><img src="http://greengerong.github.io/images/blog_img/ngModelController-%E7%94%9F%E5%91%BD%E7%8E%AF.png" alt="ngModel" /></p>

<p>同时，我们也可以利用Angular指令的reuqire来获取到这个ngModelController。如下方式来使用它的$parses和$formaters：</p>

<pre class='green'><code>.directive('textTransform', [function() {

    return {
        require: 'ngModel',
        link: function(scope, element, iAttrs, ngModelCtrl) {
            ngModelCtrl.$parsers.push(function(value) {
                ...
            });

            ngModelCtrl.$formatters.push(function(value) {
                ...
            });
        }
    };
}]);
</code></pre>

<p>因此，开篇所描述的输入控件的大写格式化，则可以利用ngModelController实现，在对于View文字大小的格式化，这个特殊的场景下，利用css特性text-transform会更简单。所以实现如下：</p>

<pre class='green'><code> .directive('textTransform', function() {
     var transformConfig = {
         uppercase: function(input){
             return input.toUpperCase();
         },
         capitalize: function(input){
             return input.replace(
                 /([a-zA-Z])([a-zA-Z]*)/gi,
                 function(matched, $1, $2){
                    return $1.toUpperCase() + $2;
                });
         },
         lowercase: function(input){
             return input.toLowerCase();
         }
     };
    return {
        require: 'ngModel',
        link: function(scope, element, iAttrs, modelCtrl) {
            var transform = transformConfig[iAttrs.textTransform];
            if(transform){
                modelCtrl.$parsers.push(function(input) {
                    return transform(input || "");
                }); 

                element.css("text-transform", iAttrs.textTransform);
            }
        }
    };
});
</code></pre>

<p>则，在HTML就可以如下方式使用指令, demo效果参见<a href="http://jsbin.com/baqaso/edit?html,js,output">jsbin demo</a>：</p>

<pre class='green'><code>&lt;input type="text" ng-model="demo.text" text-transform="capitalize" /&gt;
&lt;input type="text" ng-model="demo.text" text-transform="uppercase" /&gt;
&lt;input type="text" ng-model="demo.text" text-transform="lowercase" /&gt;
</code></pre>

<p>在这里利用了css text-transform特性，对于其它的方式，我们可以使用keydown、keyup、keypress等来实现。如<a href="https://github.com/greengerong/green.inputmask4angular">inputMask</a>和<a href="https://github.com/greengerong/ngmodel-format">ngmodel-format</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular实现递归指令 - Tree View]]></title>
    <link href="http://greengerong.github.io/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view/"/>
    <updated>2015-09-02T07:47:21+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view</id>
    <content type="html"><![CDATA[<p>在层次数据结构展示中，树是一种极其常见的展现方式。比如系统中目录结构、企业组织结构、电子商务产品分类都是常见的树形结构数据。</p>

<p>这里我们采用Angular的方式来实现这类常见的tree view结构。</p>

<p>首先我们定义数据结构，采用以children属性来挂接子节点方式来展现树层次结构，示例如下：</p>

<pre class='green'><code>[
   {
      "id":"1",
      "pid":"0",
      "name":"家用电器",
      "children":[
         {
            "id":"4",
            "pid":"1",
            "name":"大家电"
         }
      ]
   },
   {
     ...
   }
   ...
]
</code></pre>

<p>则我们对于ng way的tree view可以实现为：</p>

<p>JavaScript:</p>

<pre class='green'><code>angular.module('ng.demo', [])
.directive('treeView',[function(){

     return {
          restrict: 'E',
          templateUrl: '/treeView.html',
          scope: {
              treeData: '=',
              canChecked: '=',
              textField: '@',
              itemClicked: '&amp;',
              itemCheckedChanged: '&amp;',
              itemTemplateUrl: '@'
          },
         controller:['$scope', function($scope){
             $scope.itemExpended = function(item, $event){
                 item.$$isExpend = ! item.$$isExpend;
                 $event.stopPropagation();
             };

             $scope.getItemIcon = function(item){
                 var isLeaf = $scope.isLeaf(item);

                 if(isLeaf){
                     return 'fa fa-leaf';
                 }

                 return item.$$isExpend ? 'fa fa-minus': 'fa fa-plus';   
             };

             $scope.isLeaf = function(item){
                return !item.children || !item.children.length; 
             };

             $scope.warpCallback = function(callback, item, $event){
                  ($scope[callback] || angular.noop)({
                     $item:item,
                     $event:$event
                 });
             };
         }]
     };
 }]);
</code></pre>

<p>HTML:</p>

<p>树内容主题HTML： /treeView.html</p>

<pre class='green'><code>&lt;ul class="tree-view"&gt;
       &lt;li ng-repeat="item in treeData" ng-include="'/treeItem.html'" &gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>每个item节点的HTML：/treeItem.html</p>

<pre class='green'><code>&lt;i ng-click="itemExpended(item, $event);" class=""&gt;&lt;/i&gt;

&lt;input type="checkbox" ng-model="item.$$isChecked" class="check-box" ng-if="canChecked" ng-change="warpCallback('itemCheckedChanged', item, $event)"&gt;

&lt;span class='text-field' ng-click="warpCallback('itemClicked', item, $event);"&gt;&lt;/span&gt;
&lt;ul ng-if="!isLeaf(item)" ng-show="item.$$isExpend"&gt;
   &lt;li ng-repeat="item in item.children" ng-include="'/treeItem.html'"&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>这里的技巧在于利用ng-include来加载子节点和数据，以及利用一个warpCallback方法来转接函数外部回调函数，利用angular.noop的空对象模式来避免未注册的回调场景。对于View交互的数据隔离采用了直接封装在元数据对象的方式，但它们都以$$开头，如$$isChecked、$$isExpend。在Angular程序中以$$开头的对象会被认为是内部的私有变量，在angular.toJson的时候，它们并不会被序列化，所以利用$http发回服务端更新的时候，它们并不会影响服务端传送的数据。同时，在客户端，我们也能利用对象的这些$$属性来控制View的状态，如item.$$isChecked来默认选中某一节点。</p>

<p>我们就可以如下方式来使用这个tree-view：</p>

<pre class='green'><code>&lt;tree-view tree-data="demo.tree" text-field="name" value-field='id' item-clicked="demo.itemClicked($item)" item-checked-changed="demo.itemCheckedChanged($item)" can-checked="true"&gt;&lt;/tree-view&gt;
</code></pre>

<p>效果如下，当然你也可以在<a href="http://jsbin.com/vefuqu/edit?html,js,output">jsbin中体验它</a>：</p>

<p> <img src="http://greengerong.github.io/images/blog_img/ng-tree-view-sample.png" alt="ng-tree-view" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ramdajs函数编程]]></title>
    <link href="http://greengerong.github.io/blog/2015/08/30/ramdajshan-shu-bian-cheng/"/>
    <updated>2015-08-30T11:46:30+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/08/30/ramdajshan-shu-bian-cheng</id>
    <content type="html"><![CDATA[<p><img src="http://greengerong.github.io/images/blog_img/ramda-logo.png" alt="ramdajs函数式编程" /></p>

<p>在JavaScript语言世界，函数是第一等公民。JavaScript函数是继承自Function的对象,函数能作另一个函数的参数或者返回值使用，这便形成了我们常说的高阶函数（或称函数对象）。这就构成函数编程的第一要素。在JavaScript世界中有很多的函数式编程库能辅助我们的JavaScript函数式体验，在它们之中最为成功的要数Underscore或lodash。</p>

<p>如下lodash实例代码：</p>

<pre class='green'><code>var users = [
  { 'user': 'barney',  'age': 36 },
  { 'user': 'fred',    'age': 40 },
  { 'user': 'pebbles', 'age': 18 }
];

var names = _.chain(users)
    .pluck('user')
    .join(" , ")
    .value();
console.log(names);
</code></pre>

<p>它以链式、惰性求值著称，形成了一套自有的DSL风格。更多关于lodash的编程可以参见博主的另一篇文章<a href="http://greengerong.com/blog/2015/04/11/qian-duan-ku-zhi-lodash/">JavaScript工具库之Lodash</a>。</p>

<p>函数式思想展现的是一种纯粹的数学思维。函数并不代表任何物质（对象，相对于面向对象思想而言），而它仅仅代表一种针对数据的转换行为。一个函数可以是原子的算法子（函数），也可以是多个原子算法子组成的组合算法子。它们是对行为的最高抽象，具有非凡的抽象能力和表现力。</p>

<p>虽然Underscore或lodash也提供了<em>.compose（或</em>.flowRight）函数来实现函数组合的能力，但ramdajs具有更强的组合力。</p>

<p>ramdajs是一个更具有函数式代表的JavaScript库，可以在这里了解更多关于它的信息<a href="http://ramdajs.com/0.17/">http://ramdajs.com/0.17/</a>。它的这种能力主要来自它自有的两大能力：自动柯里化和函数参数优先于数据。</p>

<h4>自动柯里化</h4>

<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>

<p>在理论计算机科学中，柯里化提供了在简单的理论模型中比如只接受一个单一参数的lambda 演算中研究带有多个参数的函数的方式。</p>

<p>ramdajs利用这一技术，默认所有API函数都支持自动柯里化。这为它提供了可以将另一个函数组合的先决条件。如常用的map操作需要接受两个参数，在ramdajs中可以如下两种方式实现：</p>

<pre class='green'><code>R.map(function(item){
    return item *2;
 }, 
 [2,3,5]
); //输出[4, 6, 10]


var map = R.map(function(item){
    return item *2;
});
map([2,3,5]); //输出[4, 6, 10]
</code></pre>

<p>如果我们传入2个完备的参数，则R.map函数将会直接执行。否则，它将返回另一个函数，等待参数完备时才执行。</p>

<p>关于JavaScript函数的柯里化，你还可以从博主的《JavaScript函数柯里化》中了解更多<a href="http://www.cnblogs.com/whitewolf/p/4495517.html">http://www.cnblogs.com/whitewolf/p/4495517.html</a></p>

<h4>函数参数优先于数据</h4>

<p>在UnderScore和lodash这类库中，都要求首先传入数据，然后才是转换函数。而在ramdajs却是颠覆性的改变。在它的规约中数据参数是最后一个参数，而转换函数和配置参数则优于数据参数，排在前面。</p>

<p>将转换函数放置在前面，再加上函数的自动柯里化，就可以在不触及数据的情况下，将一个函数算法子包装进另一个算法子中，实现两个独立转换功能的组合。</p>

<p>假设，我们拥有如下两个基础算法子:</p>

<ol>
<li>R.multiply(a, b)：实现 a *b；
2：R.map(func, data)：实现集合 a &ndash;> b的map。</li>
</ol>


<p>因为可以自动柯里化，所以有</p>

<pre class='green'><code>R.multiply(10, 2); // 20

R.multiply(10) (2); // 20
</code></pre>

<p>所以上面对数组map的例子则可以转为如下形式：</p>

<pre class='green'><code>R.map(R.multiply(2)) ([2, 5, 10, 80]); // [4, 10, 20, 160]
</code></pre>

<p>R.map(R.multiply(2))的返回值也是一个函数，它是一个组合转换函数。它组合了map和multiply行为。它利用R.map组合封装了R.multiply(2)返回的柯里化函数，它等待map函数传入对应的被乘数。</p>

<h4>ramdajs的组合</h4>

<p>有了上面的两个条件，再加上ramdajs为我们提供的R.compose方法，我们就能很容易的实现更多算法子的组合。R.compose是从右向左执行的数据流向。</p>

<p>用ramdajs的组合来实现开篇lodash一样的用户名拼接的例子，则我们可以分为2个算法子的组合：</p>

<ol>
<li>R.pluck(prop)：选择对象固定属性；</li>
<li>R.join(data)：对数组的字符串拼接。</li>
</ol>


<p>则代码如下所示：</p>

<pre class='green'><code>var joinUserName = R.compose(R.join(" , "), R.pluck("user"));
joinUserName(users); // "barney , fred , pebbles"
</code></pre>

<p>这里的函数式组合可表示为下图：</p>

<p><img src="http://greengerong.github.io/images/blog_img/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%AE%97%E6%B3%95%E5%AD%90%E7%BB%84%E5%90%88.png" alt="函数式组合" /></p>

<p>如果我们希望join用户的年龄，则如下：</p>

<pre class='green'><code>var joinUserAge = R.compose(R.join(" , "), R.pluck("age"));
joinUserAge(users); // "36 , 40 , 18"
</code></pre>

<p>假设我们希望输出的不是用户年龄，而是用户生日，则我们可以轻易组合上一个减法的算法子：</p>

<ol>
<li>R.subtract(a, b)：实现 a &ndash; b 数学算法。</li>
</ol>


<p>则代码如下：</p>

<pre class='green'><code>var joinUserBrithDay = R.compose(R.join(","),R.map(R.subtract(new Date().getFullYear())),R.pluck("age"));
joinUserBrithDay(users); // "1979,1975,1997"
</code></pre>

<p>再如，我们希望获取最年轻的用户：</p>

<p>lodash实现：</p>

<pre class='green'><code>_.chain(users)
  .sortBy("age")
  .first()
  .value();
</code></pre>

<p>ramdajs则，可以组合获取第一个元素的R.head算法子和排序算法子R.sortBy：</p>

<pre class='green'><code>var youngestUser = R.compose(R.head, R.sortBy(R.prop("age")));
youngestUser(users); // Object {user: "pebbles", age: 18}
</code></pre>

<p>比如我们希望获取年长的用户，则只需再组合一个反序排列的算法子R.reverse：</p>

<pre class='green'><code>var olderUser = R.compose(R.head, R.reverse, R.sortBy(R.prop("age")));
olderUser(users); // Object {user: "fred", age: 40}         
</code></pre>

<p>希望你也能像我一样喜欢上ramdajs，关于它的更多资料，请参见其官网 <a href="http://ramdajs.com/0.17/">http://ramdajs.com/0.17/</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计-简约而不简单]]></title>
    <link href="http://greengerong.github.io/blog/2015/08/07/zhi-jie-bu-deng-yu-jian-dan/"/>
    <updated>2015-08-07T16:12:35+08:00</updated>
    <id>http://greengerong.github.io/blog/2015/08/07/zhi-jie-bu-deng-yu-jian-dan</id>
    <content type="html"><![CDATA[<p>本文来自<a href="https://github.com/hxfirefox/blog/blob/master/TDD/%E7%9B%B4%E6%8E%A5%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95.md">hxfirefox</a>，他是笔者在某国内大型企业提供敏捷XP咨询项目的内部教练。本文也是由他交给笔者帮助review，同时也授权发布在笔者的博客中。</p>

<p>原文地址为：<a href="https://github.com/hxfirefox/blog/blob/master/TDD/%E7%9B%B4%E6%8E%A5%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95.md">直接不等于简单</a>。</p>

<h4>码农的博弈</h4>

<p>了解XP(极限编程)的人都知道，XP有一项实践叫做简单设计(simple design)，站在这项实践对立面的是过度设计。当我们从客户价值的中心视角去审视那些我们遇到过的过度设计，自然而然就会得出一个结论：</p>

<p><em>“又TM被那些美其名曰项目经理和程序员的孙子们给忽悠了，这些功能我其实都用不到，但我还花了这么多冤枉钱去购买，下次议价时一定要砍掉80%的预算。”</em></p>

<p><img src="http://ano.lolcathost.org/pics/pcartoon1.jpg" alt="img1" /></p>

<p>一旦得出这个结论，那么很快客户和开发团队将陷入无止境的撕逼状态，群体攻击增强300%，单体理智降低80%，所以为了避免程序猿的世界被破坏，并从根本上保障码农群体可怜的经济来源，就应当想办法给客户这样一种错觉：</p>

<p><em>“你要的功能必须值这个价，如果想要新增一个功能就应该要额外收费。”</em></p>

<p>对于开发人员而言，想在这场博弈中获胜的最佳方法就是砍掉那些完全只为满足自我虚荣心(以此证明自己技艺是如何炉火纯青)的多余设计和实现，只完美地产出客户真正需要和关心的功能，这就是简单设计。</p>

<h4>似乎简单的直接设计</h4>

<p>理论总是非常easy，但是，请注意这里的<strong>但是</strong>，由于汉字的博大精深和内涵丰富，再遇上程序员这种伴随二进制进化的只有0和1二个极端的特殊生物，“简单”一词的含义被引申到了更广的范围，演化成了简单粗暴，出现了一种在编码中随处可见的风景——我称之为<strong>直接设计(directly design)</strong>。</p>

<p>直接设计看上去像是一种“按图索骥”的编程方法，开发人员将流程图上的处理及分支用直白的代码表达出来，比如最近在工作中遇到的一个例子：</p>

<p>设备对于端口的获得信息默认情况下需要进行处理，当端口被配置为A或B类型时，则该端口获得的信息无需处理，转化为流程图如下。</p>

<p><img src="https://www.processon.com/chart_image/thumb/55c438d6e4b08c136f0791c9.png" width = "300" height = "300" alt="flowchart" align=center /></p>

<p>产生的代码如下：
例1</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre class='green'><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMsgRecvdFromPort</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">checkNotNull</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">B</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">handleMsg</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>也许团队中有那么一两个了解过clean code和重构的人，那么这段代码可能演变成如下：
例2</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre class='green'><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMsgRecvdFromPort</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">checkNotNull</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">A</span> <span class="o">||</span> <span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">B</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">handleMsg</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这还不够，再改造一下：
例3</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre class='green'><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMsgRecvdFromPort</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">checkNotNull</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">isPortTypeAOrB</span><span class="o">(</span><span class="n">msg</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">handleMsg</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isPortTypeAOrB</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">A</span> <span class="o">||</span> <span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">B</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在看上去似乎舒服多了，代码也好理解了，进行到这一步代码可以算是大的提升，但是这就结束了吗？其实这只是转嫁了问题，问题并没有结束，因为现在isPortTypeAOrB方法开始变得复杂难懂起来。不论编码资历深浅，大多数开发人员都写过类似例1的代码，这些直接设计总是自觉或不自觉地跑出来，像个幽灵一样。那么这些直接设计从何而来？</p>

<p>审视自己的经历，直接设计代码产生的原因有很多，归结起来有以下几种可能性：</p>

<ul>
<li>习惯于面向过程编程的开发人员转向面向对象，惯性使然</li>
<li>新手们被要求严格地按规划的流程编码，这是最快地让新手熟练起来的方法</li>
<li>开发人员误解了简单的含义，认为简单就是直接，忽视了设计，也即简单而不设计</li>
</ul>


<p>人人都爱直接设计，不只是开发人员，因为那样不费脑力，有章可循，且按图索骥后责任就变成了流程的设计人员，既可以轻轻松松，又能趋利避害，不这么做似乎于情于理都很难说过去。其实直接设计并不代表代码质量有问题，相反只要意图足够清晰和简单，那么还是要推荐直接设计，毕竟开发人员都是这样被教育出来的。但是直接设计有一个很突出的缺陷——丑陋，因为总是会把过多的细节暴露出来，尤其是在分支处理上，就像上面的例1那样。</p>

<p>也许有人觉得这样直接挺清晰，挺容易理解，其实问题也就在这里，现在这样的分支只有两个，当用户觉得这样的需求还不能满足需要时，就会要求更多，也许会有5个，10个甚至近百个分支，那时对于开发人员而言就要不断地增加新的分支代码，就像下面的代码这样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre class='green'><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMsgRecvdFromPort</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">checkNotNull</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">B</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">C</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">D</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">().</span><span class="na">getPortType</span><span class="o">()</span> <span class="o">==</span> <span class="n">InPortType</span><span class="o">.</span><span class="na">E</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">handleMsg</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>并且在新增分支时还要小心翼翼地考虑与原有分支的逻辑关系，嵌套分支看来是在所难免了，用不了几个迭代，这些代码就会变得一堆意大利面条。</p>

<p><img src="http://richkeycafe.com/UploadFile/201142631318888.jpg" alt="pasta_img" /></p>

<p>也许，万幸的是，功能都实现，你幸福地点上一根烟，满足地看着自己的杰作，突然，有个新手菜鸟心怀崇敬地问你：“大牛，这段代码是什么意思？”，你盯着代码半天心里嘀咕着，这TM是什么鬼，我怎么也看不懂了，然后只好敷衍地回答一句“这个不明白吗？回去看看设计文档！”，好不容易打发走了这个新手，项目经理找到了你，告诉了你一个晴天霹雳，客户又改需求了，可能又要新增十几个分支，你眼前一黑，感叹一声又要加班了，但又不得不重新重头解读一遍自己创作的一切，看看哪里能够插入一个新需求，于是加班又开始了。</p>

<p><img src="http://hackles.org/strips/cartoon75.png" alt="bad_condition" /></p>

<h4>简单设计需要设计</h4>

<p>直截了当地设计过多地暴露细节造成扩展性和维护性也直截了当地下降，这种结局是所有开发人员都努力想避免的，如此看来简单设计并不简单，<strong>关键是设计，因为简单设计更需要设计</strong>，套用一句经典的广告语：<strong>简约而不简单</strong>，这才是简单设计想到达到的目的。现在试着重新解读简单设计，个人认为简单设计原则可以分成三个层次：</p>

<ul>
<li>实现具有用户价值的需求，简单的说就是用户要什么你就给他什么</li>
<li>代码设计应当职责简单，简单地说就是做好一件事</li>
<li>设计应尽可能针对一到两个问题展开，做到即设计要简单，足够针对性的解决问题即可</li>
</ul>


<p>让我们看看从上面角度怎么来设计，仍然以上面的例子为例。根据这个原则，将上述需求实例化，可以得到：</p>

<ul>
<li>when port type == A, it should not handle message</li>
<li>when port type == B, it should not handle message</li>
<li>when port type != A &amp;&amp; != B, it should handle message</li>
</ul>


<p>将端口类型进行归纳，可以发现其实端口是否处理消息由端口类型决定，一种端口类型是不需要处理消息类型，而另一种则是需要处理类型，因此端口消息处理只需要关心哪些端口是属于需要处理的类型即可。从这点出发可以看出例1做了太多可以委托他人去做的事情，因此设计上需要考虑将功能分离，特别是判断逻辑与功能主体剥离，使得单个主体的功能尽量简单来满足简单设计的第二条原则，按照上述思路，转化为如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre class='green'><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMsgRecvdFromPort</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">checkNotNull</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>    <span class="n">parseMsg</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">parseMsg</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">filter</span><span class="o">(</span><span class="n">msg</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// only ports not in disabled list could be parsed</span>
</span><span class='line'>        <span class="n">handleMsg</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">doRecord</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">RecvMsg</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">DisabledPortFilter</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getIn</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而DisabledPortFilter负责管理禁用端口，提供注册及过滤功能，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre class='green'><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DisabledPortFilter</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// FilterRule in HashMap means rule for filting with port</span>
</span><span class='line'>    <span class="c1">// Sometimes you need to composite multi-conditions to filting, not only type of port</span>
</span><span class='line'>    <span class="c1">// FilterRule is an interface, so any one wants to use filter should offer an implementation</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">InPort</span><span class="o">,</span> <span class="n">FilterRule</span><span class="o">&gt;</span> <span class="n">disableHandleList</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">DisabledPortFilter</span> <span class="n">portFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DisabledPortFilter</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">DisabledPortFilter</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">DisabledPortFilter</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">portFilter</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">registDisabledPort</span><span class="o">(</span><span class="n">InPort</span> <span class="n">inPort</span><span class="o">,</span> <span class="n">FilterRule</span> <span class="n">rule</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">disableHandleList</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">inPort</span><span class="o">,</span> <span class="n">rule</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unregistDisabeldPort</span><span class="o">(</span><span class="n">InPort</span> <span class="n">inPort</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">disableHandleList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">inPort</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">InPort</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">!</span><span class="n">disableHandleList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">in</span><span class="o">).</span><span class="na">matchFilter</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>FilterRule定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre class='green'><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FilterRule</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">matchFilter</span><span class="o">(</span><span class="n">InPort</span> <span class="n">inPort</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>将例1中在一个方法中执行的过程分解到多个类中，每个类的职责更为单一，将复杂的过滤逻辑通过转化放在各个实现类中，也可以帮助开发者及维护者能够在某一时间点只关注其中某一中过滤规则。完成上述转化后，原来可能冗余繁复的分支处理消失了，取而代之的是短短的几行简单易懂的代码。并且转化后还带来了维护上的便利与代码扩展性的提升，当客户新增需求时，只需要增加对应的FilterRule实现，并注册到DisabledPortFilter中就可以，而不用去修改原有代码，不知不觉中又契合了OCP原则。
对照前后例子，发生变化原因是针对逻辑判断与功能主体分离这一点问题进行了设计，后面的设计都是在此基础上展开，一次只设计一个切入点使得开发人员更容易控制开发思路，而不至于过多复杂的设计带来的思维混乱，因此简单设计原则中的第三条显得尤为重要，很多时候是我们自己想的太多而导致停滞不前，举步维艰。</p>

<h4>简单设计之路</h4>

<p>简单设计是一条光明大道，但通向简单设计的路却并不简单，布满荆棘，很多时候并非我们不知道简单设计，而是在一次次与时间、进度博弈的过程中自觉或不自觉地放弃了简单设计，不少简单设计只需要我们再多想那么一点点，捅破这层窗户纸并不难，要做的只是多想一点，多看一眼，往往这片刻的思考就会对我们的编码产生巨大的影响，这也正是通向简单设计道路上唯一可以依靠的工具，你要做的只是多想一点，多看一眼。</p>
]]></content>
  </entry>
  
</feed>
