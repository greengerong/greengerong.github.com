
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <title>破狼 Blog</title>
    <meta name="author" content="破 狼"> 
    <meta name="description" content="在上篇博文CoffeeScript实现Python装潢器中，笔者利用CoffeeScript支持的高阶函数，以及方法调用可省略括符的特性，实现了一个类似Python装潢器的日志Demo。这只是一种伪实现，JavaScript实现装潢器，我们需要等到ECMAScript7才行， &hellip;"> 
    <!-- http://t.co/dKP3o1e -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1"> 
    <link rel="canonical" href="http://greengerong.github.io">
    <link href="/favicon.png" rel="icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/atom.xml" rel="alternate" title="破狼 Blog" type="application/atom+xml">
    <script src="/javascripts/modernizr-2.0.js"></script>
    <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
    <script>
    !window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))
    </script>
    <script src="/javascripts/octopress.js" type="text/javascript"></script>
    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
 

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">破狼 Blog</a></h1>
  
    <h2>Write less got more.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:greengerong.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-23T07:11:07+08:00" pubdate data-updated="true">Sep 23<span>rd</span>, 2015</time>
        
           | <a href="/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上篇博文<a href="http://greengerong.com/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>中，笔者利用CoffeeScript支持的高阶函数，以及方法调用可省略括符的特性，实现了一个类似Python装潢器的日志Demo。这只是一种伪实现，JavaScript实现装潢器，我们需要等到ECMAScript7才行，在ES7特性中带来了Decorators，它就是我们所需要的装潢器特性。虽然它是ES7的特性，但在Babel大势流行的今天，我们可以利用Babel来使用它。关于Babel的推荐文章，请参见另一篇文章<a href="http://greengerong.com/blog/2015/03/22/babel-kai-shi-es6ti-yan/">Babel-现在开始使用 ES6</a>。</p>

<p>下面我们仍然和上节<a href="http://greengerong.com/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>一样，实现一个ES7 Decorators版的日志拦截示例。我们希望得到的代码效果如下：</p>

<pre class='green'><code>class MyClass {
  @log('MyClass add')
  add(a, b){
    return a + b;
  }
  @log('MyClass product')
  product(a, b){
    return a * b;
  }
  @log('MyClass error')
  error(){
     throw 'Something is wrong!';
   }
}
</code></pre>

<p>在ES7中Decorators，也是一个函数，我们只需要在它前面加上@符号，并将它标注在特定的目标，如class、method等，则可以实现方法的包裹拦截。它的传入参数有：target, name, descriptor。它们分别标记目标，标记目标名称，以及目标描述信息。在descriptor中，包括configurable、enumerable、writable，value四个属性。它们分别可以控制目标的读写、枚举，以及目标值。</p>

<p>所以我们可以如下实现：</p>

<pre class='green'><code>let log = (type) =&gt; {
    const logger = new Logger('#console');
    return (target, name, descriptor) =&gt; {
      const method = descriptor.value;
      descriptor.value =  (...args) =&gt; {
            logger.info(`(${type}) before function execute: ${name}(${args}) = ?`);
            let ret;
            try {
                ret = method.apply(target, args);
                logger.info(`(${type})after function execute success: ${name}(${args}) =&gt; ${ret}`);
            } catch (error) {
                logger.error(`(${type}) function execute error: ${name}(${args}) =&gt; ${error}`);
            } finally {
                logger.info(`(${type}) function execute done: ${name}(${args}) =&gt; ${ret}`);
            }
            return ret;
        }
    }
}
</code></pre>

<p>首先我们将原来的方法体缓存起来，直到方法调用时，实现方法调用前后的日志拦截，打印相关信息。它的效果如下：</p>

<p><img src="/images/blog_img/es7-decorators-log-aop.png" alt="es7 decorators log aop" /></p>

<p>整个demo示例，你也可以在codepen上细细把玩：</p>

<p data-height="350" data-theme-id="0" data-slug-hash="epzbMV" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/epzbMV/'>ES7 Decorators</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="//assets.codepen.io/assets/embed/ei.js"></script>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-22T21:09:03+08:00" pubdate data-updated="true">Sep 22<span>nd</span>, 2015</time>
        
           | <a href="/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上篇<a href="http://greengerong.com/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/">Angular遇上CoffeeScript &ndash; NgComponent封装</a>中，我们讲述了CoffeeScript这门小巧的语言，摒弃JavaScript中糟粕（“坑”）部分，并将JavaScript中精粹部分发挥到淋淋尽致。虽然笔者更喜欢ES6 + Babel或者TypeScript这类鲜明特性的JavaScript语法。但是CoffeeScript也不失为一门不错的JavaScript扩展语言，特别在Ruby社区仍然是一个很好的选择。</p>

<p>在本节中，我们将会利用CoffeeScript来模拟Python中的装潢器实现。Python的装潢器是属于一类来自于语言层次的AOP实现。AOP是Aspect-Oriented Programming的缩写，意为：面向切面编程。通过编译时（Compile）植入代码、运行期（Runtime）动态代理、以及框架提供管道式执行等策略实现程序通用功能与业务模块的分离，统一处理、维护的一种解耦设计。AOP是OOP的延续，是软件开发中的一个热点，也是很多服务端框架（如Java世界的Spring）中的核心内容之一，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可复用性，同时提高开发效率。 AOP实用的场景主要有：权限控制、日志模块、事务处理、性能统计、异常处理等独立、通用的非业务模块。关于更多的AOP资料请参考<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a>。</p>

<p>在Python中的装潢器也是一个普通的函数，我们只需要使用@符号将方法标注在另一个方法签名上就能实现对被标注方法的装潢。这也是Python这门函数式语言中高阶函数的运用。被装潢的方法将会被传入装潢函数中，被装潢包裹以实现方法的拦截。</p>

<p>Python中的装潢器如下：</p>

<pre class='green'><code>def deco(func):
    def _deco(*args, **kwargs):
        print("before %s called." % func.__name__)
        ret = func(*args, **kwargs)
        print("  after %s called. result: %s" % (func.__name__, ret))
        return ret
    return _deco

@deco
def myfunc(a, b):
    print(" myfunc(%s,%s) called." % (a, b))
    return a+b
</code></pre>

<p>这里的装潢器deco，将会包裹myfunc方法，实现调用前后的日志信息拦截。</p>

<p>在CoffeeScript中，我们如何实现呢？在CoffeeScript并没有真正的装潢器这一特性，但它存在高级函数，可以如下包裹：</p>

<pre class='green'><code>log(myfunc)
</code></pre>

<p>在CoffeeScript中，我们也可以简化去掉方法（）符号：</p>

<pre class='green'><code>log myfunc
</code></pre>

<p>如果我们再像Python一样强制加上@符号，并将log函数放在方法声明右边，则似乎就有点接近Python的装潢器：</p>

<pre class='green'><code>f = @log (a, b) -&gt; a + b
</code></pre>

<p>不知作为读者的你，是否也有点装潢的感觉呢？不用着急，我们在来看一个完整的demo示例：</p>

<p data-height="268" data-theme-id="0" data-slug-hash="wKKQKv" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/wKKQKv/'>CoffeeScript- decorator</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="//assets.codepen.io/assets/embed/ei.js"></script>


<p>这里利用了高阶函数的log函数来包装我们的自定义函数。其实这只是高阶函数的运用，如果这门语法也能省略掉方法调用的（），则完全也可以做到如上实现。希望作为读者的你，到这里已经明白的在函数式中高阶函数的魅力，以及其重要性。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing/">Verlet-js JavaScript 物理引擎</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-19T22:20:34+08:00" pubdate data-updated="true">Sep 19<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>subprotocol最近在Github上开源了verlet-js。地址为<a href="https://github.com/subprotocol/verlet-js">https://github.com/subprotocol/verlet-js</a>。verlet-js是一个集成Verlet的物理引擎，利用JavaScript编写。verlet-js支持粒子系统、距离限制、角度限制等。其Github声称基于这些基础，则可以帮助我们构建几乎任何我们所能想象到的东西。</p>

<p>其官网为我们提供了一下几个demo：</p>

<ol>
<li><a href="http://subprotocol.com/verlet-js/examples/shapes.html">Shapes (verlet-js Hello world)</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/tree.html">Fractal Trees</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/cloth.html">Cloth</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/spiderweb.html">Spiderweb</a></li>
</ol>


<p>笔者觉得<a href="http://subprotocol.com/verlet-js/examples/spiderweb.html">Spiderweb</a>特别有意思，下面是它的效果截图：</p>

<p><img src="/images/blog_img/verlet-js-Spiderweb.png" alt="verlet-js Spiderweb" /></p>

<p><img src="/images/blog_img/verlet-js-cloth.png" alt="verlet-js Spiderweb" /></p>

<p>Github地址：<a href="https://github.com/subprotocol/verlet-js">https://github.com/subprotocol/verlet-js</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/15/html5te-shu-su-ji-tu/">HTML5特性速记图</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-15T15:03:35+08:00" pubdate data-updated="true">Sep 15<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/09/15/html5te-shu-su-ji-tu/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/15/html5te-shu-su-ji-tu/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天推荐大家一张HTML5特性速记图，供大家平时查阅，也可以打印放在电脑旁帮助速记、速查。此图笔者收集于网络图片。</p>

<p><img src="/images/blog_img/HTML5%E7%89%B9%E6%AE%8A%E9%80%9F%E8%AE%B0%E5%9B%BE.PNG" alt="angualr meet coffeescript" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/">Angular遇上CoffeeScript - NgComponent封装</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-12T22:09:23+08:00" pubdate data-updated="true">Sep 12<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/blog_img/Angular-meetting-CoffeeScript.jpg" alt="angualr meet coffeescript" /></p>

<p>CoffeeScript是基于JavaScript的一门扩展小巧语言，它需要编译成JavaScript，然后再运行与浏览器或者Nodejs平台。JavaScript由于商业原因10天时间就匆忙诞生，所以存在很多弊病。但如《JavaScript精粹》一书中所说：JavaScript也存在着一颗华丽的心脏，如果我们能避开JavaScript中的“坑”，使用其精华的部分，这将是一门令人爱不释手的语言. 而CoffeeScript则是尝试使用这部分简洁的方式展示JavaScript的这部分优秀的精华，避免那些困扰JavaScript开发者的“坑”.CoffeeScript借鉴于Python和Ruby这两门语言，函数式风格、鸭子类型、OO风格一体的一门简洁语言。</p>

<p>Angularjs从2012年以来是火极一时的前端MVVM框架，它引入了module、双向绑定、依赖注入、Directive、MVVM等机制。更多资料参见博主其他博文。当Angular遇见CoffeeScript这门语言，将会发生什么呢？</p>

<p>想让我们来看一眼笔者利用CoffeeScript对Angular1.x代码的封装后效果。</p>

<pre class='green'><code>## controller
class DemoController extends NgComponent
   @inject 'demoService'
   @controller 'ng.green.demo'   

   __init__: =&gt;
      @demoService.getLang().then (data) =&gt;
        @lang = data 

## service  
class DemoService extends NgComponent
   @inject '$q'
   @service 'ng.green.demo' 

   getLang: =&gt;
      data = data : ['JavaScript', 'CoffeeScript', 'TypeScript', 'ES6']
      @$q.when(data)

## directive controller   
class JsonDumpController extends NgComponent
   @inject '$log'
   @controller 'ng.green.demo'   

   __init__: =&gt;
      @$log.info('This is form directive controller')

## directive       
class JsonDumpDirective extends NgComponent
  @inject '$timeout', '$http', '$cacheFactory', '$log'
  @directive 'ng.green.demo' 
  restrict: 'EA'
  templateUrl: '/jsonDump.html'
  scope: 
    json: "="
  controller: 'JsonDumpController'
  link: (scope, elm, iAttrs) =&gt;
    @$timeout (() =&gt; @$log.info '$timeout &amp; $log injector worked on link function!' ), 100
</code></pre>

<p>有了上面的对controller、service、directive的定义，则我们可以如下方式使用：</p>

<pre class='green'><code>&lt;div ng-app="ng.green.demo" ng-controller="DemoController as demo" class="container"&gt;
  &lt;json-dump json="demo.lang"&gt;&lt;/json-dump&gt;
  &lt;script type="text/ng-template" id="/jsonDump.html"&gt; 
  &lt;hr /&gt;
  &lt;pre&gt;&lt;/pre&gt;
&lt;/script&gt; 
&lt;/div&gt;
</code></pre>

<p>不知各位看官对如上代码感觉如何？是不是更简化、语义化、有点ng的感觉。其中笔者还有意模仿Python，如<strong>init</strong>作为初始化方式。在这里每个class会自声明组件类型，以及声明式注入，module自注册。</p>

<p>不管如何看，下面我来看看NgComponent到底做了什么？</p>

<pre class='green'><code>class NgComponent
    @controller: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName(true)
      angular.module(moduleName, moduleResolver).controller componentName, @      

    @service: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName()
      angular.module(moduleName, moduleResolver).service componentName, @

    @directive: (moduleName, moduleResolver) -&gt;
      componentName = @$$componentName().replace('Directive','')
      directiveClass = @
      directiveFactory = (args...) -&gt;
          new directiveClass(args...)          
      directiveFactory.$inject = @$inject
      angular.module(moduleName, moduleResolver).directive componentName, directiveFactory    

    @$$componentName: (upperCaseFirstLetter = false) -&gt;
      # regex for ie
      componentName = @name || @toString().match(/function\s*(.*?)\(/)?[1]
      if upperCaseFirstLetter
       firstLetter =  componentName.substr(0,1).toUpperCase()
      else
        firstLetter = componentName.substr(0,1).toLowerCase()
      (componentName = "#{firstLetter}#{componentName.substr(1)}") unless upperCaseFirstLetter
      componentName

    @inject: (args...) -&gt;
      @$inject = args

    constructor: (args...) -&gt;
      for key, index in @constructor.$inject
        @[key] = args[index]

      @__init__?()
</code></pre>

<p>在NgComponent中定义了controller、service、directive注册接口，这里可以是声明创建module，也可以是在已声明的module上注册这些组件类型。对于组件命名也才采用了约定胜于配置，它们都以class类型为基础，controller为首字母大写的驼峰命名，service则首字母小写驼峰命名，directive则会去掉Directive标记并首字母小写注册。</p>

<p>同时这里也声明了@inject方法，使得我们可以在定义在类型之上定义$inejct属性，Angular的注入声明。对于Angular的注入服务，在构造函数中会将他们一一添加到当前类实例对象之上。在依赖添加完毕后，也会调用对象初始化方法，这里是模拟Python的<strong>init</strong>。</p>

<p>Demo效果可以在codepen查看 <a href="http://codepen.io/greengerong/pen/EVVQZg?editors=101">http://codepen.io/greengerong/pen/EVVQZg?editors=101</a>：</p>

<p data-height="268" data-theme-id="0" data-slug-hash="EVVQZg" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/EVVQZg/'>Angular meet CoffeeScript</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="//assets.codepen.io/assets/embed/ei.js"></script>


<p>本文笔者的突发奇想，希望能给读者一些启发，也许你还有更好的DSL封装，欢迎多多交流。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/09/kuo-zhan-bootstrap-tooltipcha-jian-shi-qi-ke-jiao-hu/">扩展Bootstrap Tooltip插件使其可交互</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-09T13:20:20+08:00" pubdate data-updated="true">Sep 9<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/09/09/kuo-zhan-bootstrap-tooltipcha-jian-shi-qi-ke-jiao-hu/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/09/kuo-zhan-bootstrap-tooltipcha-jian-shi-qi-ke-jiao-hu/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在公司某项目开发中遇见一特殊需求，请笔者帮助，因此有了本文的插件。在前端开发中tooltip是一个极其常用的插件，它能更好向使用者展示更多的文档等帮助信息。它们通常都是一些静态文本信息。但同事他们的需求是需要动态交互，在文本信息中存在帮助网页的链接。如果使用常规tooltip，则在用户移出tooltip依赖DOM节点后，tooltip panel则将被隐藏。所以用户没有办法点击到这些交互链接。</p>

<p>所以我们期望：给用户一定的时间使得用户能够将鼠标从依赖节点移动到tooltip panel；并且如果用户鼠标停留在tooltip上则不能隐藏，使得用户能够与位于tooltip上的链接或者是其他form表单控件交互。</p>

<p>也许你觉得这并不难，在网上Google就有很多代码可直接使用。是的，如下面这段来自plnkr.co的代码（<a href="http://plnkr.co/edit/x2VMhh?p=preview">http://plnkr.co/edit/x2VMhh?p=preview</a>）：</p>

<pre class='green'><code>$(".pop").popover({ trigger: "manual" , html: true, animation:false})
    .on("mouseenter", function () {
        var _this = this;
        $(this).popover("show");
        $(".popover").on("mouseleave", function () {
            $(_this).popover('hide');
        });
    }).on("mouseleave", function () {
        var _this = this;
        setTimeout(function () {
            if (!$(".popover:hover").length) {
                $(_this).popover("hide");
            }
        }, 300);
});
</code></pre>

<p>它是使用bootstrap的popover来实现的，从bootstrap的源码能看到popover是继承至tooltip的组件之一。这里是通过将popover的触发方式设为手动触发，由我们自己来控制显示和隐藏它的时机。并且在依赖节点离开的时候，给定300ms的延迟等待用户进入tooltip panel，如果300ms还没有进入tooltip则隐藏它。否则就阻止隐藏tooltip的逻辑。</p>

<p>这代码虽然功能可用，但具有代码洁癖的博主并不太满意这样的代码。它难以阅读维护，同时重用性也将极差。所以笔者决定要以bootstrap插件方式来一bs way写这款插件。</p>

<p>当笔者查阅bootstrap tooltip源码时，发现它是一个扩展性很不错的插件。tooltip的显示和隐藏依赖于它内部的hoverState状态来控制，in代表在依赖节点元素之上，out则代表移出了DOM元素。并且它也支持延迟动画机制。所以我们可以如下方式控制hoverState的状态：</p>

<pre class='green'><code>var DelayTooltip = function (element, options) {
    this.init('delayTooltip', element, options);
    this.initDelayTooltip();
};

DelayTooltip.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    trigger: 'hover',
    delay: {hide: 600}
});

DelayTooltip.prototype.delayTooltipEnter = function(){
        this.hoverState = 'in';
    };

    DelayTooltip.prototype.delayTooltipLeave = function(){
        this.hoverState = 'out';
        this.leave(this);
    };

  DelayTooltip.prototype.initDelayTooltip = function(){
      this.tip()
          .on('mouseenter.'  +  this.type, $.proxy(this.delayTooltipEnter, this))
          .on('mouseleave.' + this.type, $.proxy(this.delayTooltipLeave, this));
  };
</code></pre>

<p>这里在构造tooltip对象同时也注册tooltip panel的mouseenter、mouseleave.事件，并设置对应的hoverState状态。当移出tooltip panel时，这里需要手动的调用来自tooltip继类的leave方法。对于隐藏延时则设置在默认option中，使其能够可配置。</p>

<p>上面的代码就是我们所需要扩展tooltip的所有的代码。当然要想作为一个通用的bootstrap插件，还需要它固定的插件配置代码。插件全部代码如下：</p>

<pre class='green'><code>(function ($) {
  'use strict';

  var DelayTooltip = function (element, options) {
    this.init('delayTooltip', element, options);
    this.initDelayTooltip();
  };

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');

  DelayTooltip.VERSION  = '0.1';

  DelayTooltip.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    trigger: 'hover',
    delay: {hide: 300}
  });

  DelayTooltip.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

  DelayTooltip.prototype.constructor = DelayTooltip;

  DelayTooltip.prototype.getDefaults = function () {
    return DelayTooltip.DEFAULTS;
  };

    DelayTooltip.prototype.delayTooltipEnter = function(){
        this.hoverState = 'in';
    };

    DelayTooltip.prototype.delayTooltipLeave = function(){
        this.hoverState = 'out';
        this.leave(this);
    };

  DelayTooltip.prototype.initDelayTooltip = function(){
      this.tip()
          .on('mouseenter.'  +  this.type, $.proxy(this.delayTooltipEnter, this))
          .on('mouseleave.' + this.type, $.proxy(this.delayTooltipLeave, this));
  };

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this);
      var data    = $this.data('bs.delayTooltip');
      var options = typeof option == 'object' &amp;&amp; option;

      if (!data &amp;&amp; /destroy|hide/.test(option)) return;
      if (!data) $this.data('bs.delayTooltip', (data = new DelayTooltip(this, options)));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.delayTooltip;

  $.fn.delayTooltip             = Plugin;
  $.fn.delayTooltip.Constructor = DelayTooltip;

  $.fn.delayTooltip.noConflict = function () {
    $.fn.delayTooltip = old;
    return this;
  };

})(jQuery);
</code></pre>

<p>这里基本都是bootstrap插件机制的固定模板，仅仅需要套用上就行。有了这个插件扩展，那么我们就可以如下使用这款插件：你也可以在jsbin中查看效果<a href="http://jsbin.com/wicoki/edit?html,js,output">http://jsbin.com/wicoki/edit?html,js,output</a>:</p>

<p>HTML:</p>

<pre class='green'><code>&lt;div id="tooltip"&gt;bs tooltip:你能点击链接？&lt;/div&gt;
&lt;hr&gt;
&lt;div  id="delayTooltip"&gt;delay tooltip：尝试点击链接&lt;/div&gt;
&lt;hr&gt;
&lt;div id="delayTooltipInHtml" data-html="true" data-placement="bottom" data-toggle="delayTooltip"&gt;delay tooltip:利用html标签实现&lt;/div&gt;
</code></pre>

<p>JavaScript 代码：</p>

<pre class='green'><code>(function(global, $){

    var page = function(){

    };

    page.prototype.bootstrap = function(){
        var html = 'Weclome to my blog &lt;a target="_blank" href="greengerong.github.io"&gt;破狼博客&lt;/a&gt;!&lt;input type="text" placeholder="input some thing"/&gt;';
        $('#tooltip').tooltip( {
            html: true,
            placement: 'top',
            title: html
        });

        $('#delayTooltip').delayTooltip( {
            html: true,
            placement: 'bottom',
            title: html
        });

  $('#delayTooltipInHtml').attr('title', html).delayTooltip();

  return this;
};

     global.Page = page;

})(this, jQuery);

$(function(){
    'use strict';
  var page = new window.Page().bootstrap();
    //
});
</code></pre>

<p>这款插件既支持jQuery在HTML中声明属性的方式，同时也可以在javascript中使用。效果如下：</p>

<p><img src="/images/blog_img/delay-tooltip-example.png" alt="bootstrap dealy-tooltip" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao/">前端获取元素定位位置的法宝</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-08T07:09:23+08:00" pubdate data-updated="true">Sep 8<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/blog_img/box-chrome.png" alt="box chrome" /></p>

<p>在前端开发中，我们经常需要定位一个元素。如tooltip、popover或者modal等，或许是我们需要将它们定位在依赖元素的周围或屏幕滚动屏幕中心位置。这对于前端开发的码农来说并不是难事。算出和依赖元素的offset，设置元素的left、right。对于稍复杂的场景我们可能需要考虑被positioned的祖先元素。</p>

<p>但往往不是所有的事情都是这么简单的。笔者最新在项目开发中就遇见这样一个问题：这里的HTML是嵌入的，其来自jpedal商业软件从PDF文件自动生成的；为了展示的样式，jpedal统一使用了 position:absolute和relative来定位PDF元素。然而由于业务的需求，我们需要操作这类HTML。其中一个需求就是需要在每段文字附近显示操作工具条。</p>

<p>对于这类未知的DOM定位，那么我们就需要遍历它的DOM树来计算它的相对位置了。行为下面的这段代码：</p>

<pre class='green'><code>    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent &amp;&amp; offsetParent !== docDomEl &amp;&amp; isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };
</code></pre>

<p>在这里，我们会根据元素递归查询它所在的的DOM树中被positioned的最接近的祖先元素，然后才计算它们的相对位置。</p>

<p>这是一段来自Angular-UI bootstrap的$position服务的源码。这也是本文将要提到的获取定位元素位置的法宝。其源码位置在<a href="https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js">https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js</a>。</p>

<p>在$position服务中为我们提供了3个有用的位置服务：position、offset和positionElements。position是计算具体元素的定位位置，返回一个带有width、height、top、left的对象；positionElements则是返回某元素相对于其依赖容器元素的定位位置，一个带有top、left的对象。</p>

<p>笔者为了测试这写API，在jsbin中写了一个特定的指令：</p>

<p>JavaScript:</p>

<pre class='green'><code>angular.module("com.ngbook.demo", ['ui.bootstrap.position'])
.directive('position', ['$position', function($position){
    return {
        restrict: 'EA',
        templateUrl: '/position.html',
        scope:{
            title:"@"
        },
        link:function(scope, elm, iAttrs){
        scope.data =  $position.position(elm);
       }
    };
}]);
</code></pre>

<p>HTML:</p>

<pre class='green'><code>&lt;script type="text/ng-template" id="/position.html"&gt;
   &lt;table class="table"&gt;
       &lt;thead&gt;
           &lt;th colspan="2"&gt;{{title}}&lt;/th&gt;
       &lt;/thead&gt;
    &lt;tbody&gt;
       &lt;tr ng-repeat="field in ['width', 'height', 'left', 'top']"&gt;
       &lt;td&gt;{{field}}&lt;/td&gt;
       &lt;td&gt;{{data[field] | number}}&lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
 &lt;/script&gt;
</code></pre>

<p>所以我们可以如下测试这类API：</p>

<pre class='green'><code>&lt;position title ="no positioned parent"&gt;&lt;/position&gt;

&lt;div style="position: relative;padding:50px;"&gt;
    &lt;position title ="relative parent"&gt;&lt;/position&gt;

     &lt;div style="position: absolute;top:250px; padding:50px;"&gt;
         &lt;position title="relative-&gt;absolute parent"&gt;&lt;/position&gt;
     &lt;/div&gt;
 &lt;/div&gt;

 &lt;div style="position: absolute;top:0px;left:250px; padding:50px;"&gt;
         &lt;position title="absolute parent"&gt;&lt;/position&gt;
 &lt;/div&gt;
</code></pre>

<p>其效果可以在<a href="http://jsbin.com/deximu/edit?html,js,output">jsbin demo</a>:</p>

<p><img src="/images/blog_img/ng-$position-example.png" alt="$position demo" /></p>

<p>同样你也可以在官方的文档中看见对它的测试: <a href="https://github.com/angular-ui/bootstrap/blob/master/src/position/test/test.html">https://github.com/angular-ui/bootstrap/blob/master/src/position/test/test.html</a>。</p>

<p>简单的说：如果我们需要获取某个元素的定位信息，则我们可以用 $position.position(element)；获取相对于固定元素的定位，则可以使用$position.positionElements(hostEl, targetEl, positionStr, appendToBody)。其中positionStr是一个横向和纵向的字符串，如：&#8221;top-left&#8221;、&#8221;bottom-left&#8221;。其默认值为center。如笔者项目所期望的在某文字段落的左上角显示工具条：</p>

<pre class='green'><code>$position.after($toolbar);
var elPosition = $position.positionElements($paragraph, $toolbar, “top-left”);
$toolbar.css({left: elPosition.left + 'px', top: elPosition.top + 'px'});
</code></pre>

<p>当然也不要忘记为toolbar元素设置position: absolute;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/03/angular-inputge-shi-hua/">Angular Input格式化</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-03T16:29:35+08:00" pubdate data-updated="true">Sep 3<span>rd</span>, 2015</time>
        
           | <a href="/blog/2015/09/03/angular-inputge-shi-hua/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/03/angular-inputge-shi-hua/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天在Angular中文群有位同学问到：如何实现对input box的格式化。如下的方式对吗？</p>

<pre class='green'><code> &lt;input type="text" ng-model="demo.text | uppercase" /&gt;
</code></pre>

<p>这当然是不对的。在Angular中filter（过滤器）是为了显示数据的格式，它将$scope上的Model数据格式化View显示的数据绑定到DOM之上。它并不会负责ngModel的绑定值的格式化。</p>

<p>在Angular中ngModel作为Angular双向绑定中的重要组成部分，负责View控件交互数据到$scope上Model的同步。当然这里存在一些差异，View上的显示和输入都是字符串类型，而在Model上的数据则是有特定数据类型的，例如常用的Number、Date、Array、Object等。ngModel为了实现数据到Model的类型转换，在ngModelController中提供了两个管道数组$formatters和$parsers，它们分别是将Model的数据转换为View交互控件显示的值和将交互控件得到的View值转换为Model数据。它们都是一个数组对象，在ngModel启动数据转换时，会以UNIX管道式传递执行这一系列的转换。Angular允许我们手动的添加$formatters和$parsers的转换函数（unshift、push）。同时在这里也是做数据验证的最佳时机，能够转换意味应该是合法的数据。</p>

<p><img src="/images/blog_img/ngModelController-%E7%94%9F%E5%91%BD%E7%8E%AF.png" alt="ngModel" /></p>

<p>同时，我们也可以利用Angular指令的reuqire来获取到这个ngModelController。如下方式来使用它的$parses和$formaters：</p>

<pre class='green'><code>.directive('textTransform', [function() {

    return {
        require: 'ngModel',
        link: function(scope, element, iAttrs, ngModelCtrl) {
            ngModelCtrl.$parsers.push(function(value) {
                ...
            });

            ngModelCtrl.$formatters.push(function(value) {
                ...
            });
        }
    };
}]);
</code></pre>

<p>因此，开篇所描述的输入控件的大写格式化，则可以利用ngModelController实现，在对于View文字大小的格式化，这个特殊的场景下，利用css特性text-transform会更简单。所以实现如下：</p>

<pre class='green'><code> .directive('textTransform', function() {
     var transformConfig = {
         uppercase: function(input){
             return input.toUpperCase();
         },
         capitalize: function(input){
             return input.replace(
                 /([a-zA-Z])([a-zA-Z]*)/gi,
                 function(matched, $1, $2){
                    return $1.toUpperCase() + $2;
                });
         },
         lowercase: function(input){
             return input.toLowerCase();
         }
     };
    return {
        require: 'ngModel',
        link: function(scope, element, iAttrs, modelCtrl) {
            var transform = transformConfig[iAttrs.textTransform];
            if(transform){
                modelCtrl.$parsers.push(function(input) {
                    return transform(input || "");
                }); 

                element.css("text-transform", iAttrs.textTransform);
            }
        }
    };
});
</code></pre>

<p>则，在HTML就可以如下方式使用指令, demo效果参见<a href="http://jsbin.com/baqaso/edit?html,js,output">jsbin demo</a>：</p>

<pre class='green'><code>&lt;input type="text" ng-model="demo.text" text-transform="capitalize" /&gt;
&lt;input type="text" ng-model="demo.text" text-transform="uppercase" /&gt;
&lt;input type="text" ng-model="demo.text" text-transform="lowercase" /&gt;
</code></pre>

<p>在这里利用了css text-transform特性，对于其它的方式，我们可以使用keydown、keyup、keypress等来实现。如<a href="https://github.com/greengerong/green.inputmask4angular">inputMask</a>和<a href="https://github.com/greengerong/ngmodel-format">ngmodel-format</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view/">Angular实现递归指令 - Tree View</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-02T07:47:21+08:00" pubdate data-updated="true">Sep 2<span>nd</span>, 2015</time>
        
           | <a href="/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/09/02/angularshi-xian-di-gui-zhi-ling-tree-view/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在层次数据结构展示中，树是一种极其常见的展现方式。比如系统中目录结构、企业组织结构、电子商务产品分类都是常见的树形结构数据。</p>

<p>这里我们采用Angular的方式来实现这类常见的tree view结构。</p>

<p>首先我们定义数据结构，采用以children属性来挂接子节点方式来展现树层次结构，示例如下：</p>

<pre class='green'><code>[
   {
      "id":"1",
      "pid":"0",
      "name":"家用电器",
      "children":[
         {
            "id":"4",
            "pid":"1",
            "name":"大家电"
         }
      ]
   },
   {
     ...
   }
   ...
]
</code></pre>

<p>则我们对于ng way的tree view可以实现为：</p>

<p>JavaScript:</p>

<pre class='green'><code>angular.module('ng.demo', [])
.directive('treeView',[function(){

     return {
          restrict: 'E',
          templateUrl: '/treeView.html',
          scope: {
              treeData: '=',
              canChecked: '=',
              textField: '@',
              itemClicked: '&amp;',
              itemCheckedChanged: '&amp;',
              itemTemplateUrl: '@'
          },
         controller:['$scope', function($scope){
             $scope.itemExpended = function(item, $event){
                 item.$$isExpend = ! item.$$isExpend;
                 $event.stopPropagation();
             };

             $scope.getItemIcon = function(item){
                 var isLeaf = $scope.isLeaf(item);

                 if(isLeaf){
                     return 'fa fa-leaf';
                 }

                 return item.$$isExpend ? 'fa fa-minus': 'fa fa-plus';   
             };

             $scope.isLeaf = function(item){
                return !item.children || !item.children.length; 
             };

             $scope.warpCallback = function(callback, item, $event){
                  ($scope[callback] || angular.noop)({
                     $item:item,
                     $event:$event
                 });
             };
         }]
     };
 }]);
</code></pre>

<p>HTML:</p>

<p>树内容主题HTML： /treeView.html</p>

<pre class='green'><code>&lt;ul class="tree-view"&gt;
       &lt;li ng-repeat="item in treeData" ng-include="'/treeItem.html'" &gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>每个item节点的HTML：/treeItem.html</p>

<pre class='green'><code>&lt;i ng-click="itemExpended(item, $event);" class=""&gt;&lt;/i&gt;

&lt;input type="checkbox" ng-model="item.$$isChecked" class="check-box" ng-if="canChecked" ng-change="warpCallback('itemCheckedChanged', item, $event)"&gt;

&lt;span class='text-field' ng-click="warpCallback('itemClicked', item, $event);"&gt;&lt;/span&gt;
&lt;ul ng-if="!isLeaf(item)" ng-show="item.$$isExpend"&gt;
   &lt;li ng-repeat="item in item.children" ng-include="'/treeItem.html'"&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>这里的技巧在于利用ng-include来加载子节点和数据，以及利用一个warpCallback方法来转接函数外部回调函数，利用angular.noop的空对象模式来避免未注册的回调场景。对于View交互的数据隔离采用了直接封装在元数据对象的方式，但它们都以$$开头，如$$isChecked、$$isExpend。在Angular程序中以$$开头的对象会被认为是内部的私有变量，在angular.toJson的时候，它们并不会被序列化，所以利用$http发回服务端更新的时候，它们并不会影响服务端传送的数据。同时，在客户端，我们也能利用对象的这些$$属性来控制View的状态，如item.$$isChecked来默认选中某一节点。</p>

<p>我们就可以如下方式来使用这个tree-view：</p>

<pre class='green'><code>&lt;tree-view tree-data="demo.tree" text-field="name" value-field='id' item-clicked="demo.itemClicked($item)" item-checked-changed="demo.itemCheckedChanged($item)" can-checked="true"&gt;&lt;/tree-view&gt;
</code></pre>

<p>效果如下，当然你也可以在<a href="http://jsbin.com/vefuqu/edit?html,js,output">jsbin中体验它</a>：</p>

<p> <img src="/images/blog_img/ng-tree-view-sample.png" alt="ng-tree-view" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/30/ramdajshan-shu-bian-cheng/">Ramdajs函数编程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-08-30T11:46:30+08:00" pubdate data-updated="true">Aug 30<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/08/30/ramdajshan-shu-bian-cheng/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/08/30/ramdajshan-shu-bian-cheng/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/blog_img/ramda-logo.png" alt="ramdajs函数式编程" /></p>

<p>在JavaScript语言世界，函数是第一等公民。JavaScript函数是继承自Function的对象,函数能作另一个函数的参数或者返回值使用，这便形成了我们常说的高阶函数（或称函数对象）。这就构成函数编程的第一要素。在JavaScript世界中有很多的函数式编程库能辅助我们的JavaScript函数式体验，在它们之中最为成功的要数Underscore或lodash。</p>

<p>如下lodash实例代码：</p>

<pre class='green'><code>var users = [
  { 'user': 'barney',  'age': 36 },
  { 'user': 'fred',    'age': 40 },
  { 'user': 'pebbles', 'age': 18 }
];

var names = _.chain(users)
    .pluck('user')
    .join(" , ")
    .value();
console.log(names);
</code></pre>

<p>它以链式、惰性求值著称，形成了一套自有的DSL风格。更多关于lodash的编程可以参见博主的另一篇文章<a href="http://greengerong.com/blog/2015/04/11/qian-duan-ku-zhi-lodash/">JavaScript工具库之Lodash</a>。</p>

<p>函数式思想展现的是一种纯粹的数学思维。函数并不代表任何物质（对象，相对于面向对象思想而言），而它仅仅代表一种针对数据的转换行为。一个函数可以是原子的算法子（函数），也可以是多个原子算法子组成的组合算法子。它们是对行为的最高抽象，具有非凡的抽象能力和表现力。</p>

<p>虽然Underscore或lodash也提供了<em>.compose（或</em>.flowRight）函数来实现函数组合的能力，但ramdajs具有更强的组合力。</p>

<p>ramdajs是一个更具有函数式代表的JavaScript库，可以在这里了解更多关于它的信息<a href="http://ramdajs.com/0.17/">http://ramdajs.com/0.17/</a>。它的这种能力主要来自它自有的两大能力：自动柯里化和函数参数优先于数据。</p>

<h4>自动柯里化</h4>

<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>

<p>在理论计算机科学中，柯里化提供了在简单的理论模型中比如只接受一个单一参数的lambda 演算中研究带有多个参数的函数的方式。</p>

<p>ramdajs利用这一技术，默认所有API函数都支持自动柯里化。这为它提供了可以将另一个函数组合的先决条件。如常用的map操作需要接受两个参数，在ramdajs中可以如下两种方式实现：</p>

<pre class='green'><code>R.map(function(item){
    return item *2;
 }, 
 [2,3,5]
); //输出[4, 6, 10]


var map = R.map(function(item){
    return item *2;
});
map([2,3,5]); //输出[4, 6, 10]
</code></pre>

<p>如果我们传入2个完备的参数，则R.map函数将会直接执行。否则，它将返回另一个函数，等待参数完备时才执行。</p>

<p>关于JavaScript函数的柯里化，你还可以从博主的《JavaScript函数柯里化》中了解更多<a href="http://www.cnblogs.com/whitewolf/p/4495517.html">http://www.cnblogs.com/whitewolf/p/4495517.html</a></p>

<h4>函数参数优先于数据</h4>

<p>在UnderScore和lodash这类库中，都要求首先传入数据，然后才是转换函数。而在ramdajs却是颠覆性的改变。在它的规约中数据参数是最后一个参数，而转换函数和配置参数则优于数据参数，排在前面。</p>

<p>将转换函数放置在前面，再加上函数的自动柯里化，就可以在不触及数据的情况下，将一个函数算法子包装进另一个算法子中，实现两个独立转换功能的组合。</p>

<p>假设，我们拥有如下两个基础算法子:</p>

<ol>
<li>R.multiply(a, b)：实现 a *b；
2：R.map(func, data)：实现集合 a &ndash;> b的map。</li>
</ol>


<p>因为可以自动柯里化，所以有</p>

<pre class='green'><code>R.multiply(10, 2); // 20

R.multiply(10) (2); // 20
</code></pre>

<p>所以上面对数组map的例子则可以转为如下形式：</p>

<pre class='green'><code>R.map(R.multiply(2)) ([2, 5, 10, 80]); // [4, 10, 20, 160]
</code></pre>

<p>R.map(R.multiply(2))的返回值也是一个函数，它是一个组合转换函数。它组合了map和multiply行为。它利用R.map组合封装了R.multiply(2)返回的柯里化函数，它等待map函数传入对应的被乘数。</p>

<h4>ramdajs的组合</h4>

<p>有了上面的两个条件，再加上ramdajs为我们提供的R.compose方法，我们就能很容易的实现更多算法子的组合。R.compose是从右向左执行的数据流向。</p>

<p>用ramdajs的组合来实现开篇lodash一样的用户名拼接的例子，则我们可以分为2个算法子的组合：</p>

<ol>
<li>R.pluck(prop)：选择对象固定属性；</li>
<li>R.join(data)：对数组的字符串拼接。</li>
</ol>


<p>则代码如下所示：</p>

<pre class='green'><code>var joinUserName = R.compose(R.join(" , "), R.pluck("user"));
joinUserName(users); // "barney , fred , pebbles"
</code></pre>

<p>这里的函数式组合可表示为下图：</p>

<p><img src="/images/blog_img/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%AE%97%E6%B3%95%E5%AD%90%E7%BB%84%E5%90%88.png" alt="函数式组合" /></p>

<p>如果我们希望join用户的年龄，则如下：</p>

<pre class='green'><code>var joinUserAge = R.compose(R.join(" , "), R.pluck("age"));
joinUserAge(users); // "36 , 40 , 18"
</code></pre>

<p>假设我们希望输出的不是用户年龄，而是用户生日，则我们可以轻易组合上一个减法的算法子：</p>

<ol>
<li>R.subtract(a, b)：实现 a &ndash; b 数学算法。</li>
</ol>


<p>则代码如下：</p>

<pre class='green'><code>var joinUserBrithDay = R.compose(R.join(","),R.map(R.subtract(new Date().getFullYear())),R.pluck("age"));
joinUserBrithDay(users); // "1979,1975,1997"
</code></pre>

<p>再如，我们希望获取最年轻的用户：</p>

<p>lodash实现：</p>

<pre class='green'><code>_.chain(users)
  .sortBy("age")
  .first()
  .value();
</code></pre>

<p>ramdajs则，可以组合获取第一个元素的R.head算法子和排序算法子R.sortBy：</p>

<pre class='green'><code>var youngestUser = R.compose(R.head, R.sortBy(R.prop("age")));
youngestUser(users); // Object {user: "pebbles", age: 18}
</code></pre>

<p>比如我们希望获取年长的用户，则只需再组合一个反序排列的算法子R.reverse：</p>

<pre class='green'><code>var olderUser = R.compose(R.head, R.reverse, R.sortBy(R.prop("age")));
olderUser(users); // Object {user: "fred", age: 40}         
</code></pre>

<p>希望你也能像我一样喜欢上ramdajs，关于它的更多资料，请参见其官网 <a href="http://ramdajs.com/0.17/">http://ramdajs.com/0.17/</a>。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>破 狼</h1>
  <p>    那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息。 那一月，我转过所有经轮，不为超度，只为触摸你的指纹。 那一年，我磕长头拥抱尘埃，不为朝佛，只为贴着了你的温暖。 那一世，我翻遍十万大山，不为修来世，只为路中能与你相遇。 那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。<a href="http://greengerong.github.io/blog/2009/12/24/cang-yang-jia-cuo-na-yi-tian-na-yi-yue-na-yi-nian-na-yi-shi/">《那一天，那一月，那一年，那一世》&#8211;仓央嘉措。</a></p>
</section>
<section>
  <p style="align: center"><a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3158890&amp;c=9476983" alt="count web site visits"/></a></p>
</section>
<section>
    <h1>博客友情链接</h1>
    <ul>
        <li><a href="http://www.cnblogs.com/whitewolf/">博客园-破狼</a></li>
    </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing/">Verlet-js JavaScript 物理引擎</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/15/html5te-shu-su-ji-tu/">HTML5特性速记图</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/">Angular遇上CoffeeScript - NgComponent封装</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/09/kuo-zhan-bootstrap-tooltipcha-jian-shi-qi-ke-jiao-hu/">扩展Bootstrap Tooltip插件使其可交互</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/08/angularzhong-huo-qu-ding-wei-yuan-su-wei-zhi-de-fa-bao/">前端获取元素定位位置的法宝</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/03/angular-inputge-shi-hua/">Angular Input格式化</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/greengerong">@greengerong</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'greengerong',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 破 狼 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'greengerong';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
