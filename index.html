
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <title>破狼 Blog</title>
    <meta name="author" content="破 狼"> 
    <meta name="description" content="浏览器事件模型和回调机制 JavaScript作为单线程运行于浏览器之中，这是每本JavaScript教科书中都会被提到的。同时出于对UI线程操作的安全性考虑，JavaScript和UI线程也处于同一个线程中。因此对于长时间的耗时操作，将会阻塞UI的响应。为了更好的UI体验， &hellip;"> 
    <!-- http://t.co/dKP3o1e -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1"> 
    <link rel="canonical" href="http://greengerong.github.io">
    <link href="/favicon.png" rel="icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/atom.xml" rel="alternate" title="破狼 Blog" type="application/atom+xml">
    <script src="/javascripts/modernizr-2.0.js"></script>
    <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
    <script>
    !window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))
    </script>
    <script src="/javascripts/octopress.js" type="text/javascript"></script>
    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
 

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">破狼 Blog</a></h1>
  
    <h2>Write less got more.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:greengerong.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/22/promisede-miao-yong/">Promise的前世今生和妙用技巧</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-22T17:16:31+08:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>浏览器事件模型和回调机制</h2>

<p>JavaScript作为单线程运行于浏览器之中，这是每本JavaScript教科书中都会被提到的。同时出于对UI线程操作的安全性考虑，JavaScript和UI线程也处于同一个线程中。因此对于长时间的耗时操作，将会阻塞UI的响应。为了更好的UI体验，应该尽量的避免JavaScript中执行较长耗时的操作（如大量for循环的对象diff等）或者是长时间I/O阻塞的任务。所以在浏览器中的大多数任务都是异步（无阻塞）执行的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、Ajax完成回调事件等。当每一个异步事件完成时，它都将被放入一个叫做”浏览器事件队列“中的事件池中去。而这些被放在事件池中的任务，将会被javascript引擎单线程处理的一个一个的处理，当在此次处理中再次遇见的异步任务，它们也会被放到事件池中去，等待下一次的tick被处理。另外在HTML5中引入了新的组件-Web Worker，它可以在JavaScript线程以外执行这些任务，而不阻塞当前UI线程。</p>

<p>浏览器中的事件循环模型如下图所示：</p>

<p><img src="/images/blog_img/browser-event-base.png" alt="浏览器事件模型" /></p>

<p>由于浏览器的这种内部事件循环机制，所以JavaScript一直以callback回调的方式来处理事件任务。因此无所避免的对于多个的JavaScript异步任务的处理，将会遇见”callback hell“（回调地狱），使得这类代码及其不可读和难易维护。</p>

<pre class='green'><code>asyncTask1(data, function (data1){

    asyncTask2(data1, function (data2){

        asyncTask3(data2, function (data3){
                // .... 魔鬼式的金字塔还在继续
        });

    });

});
</code></pre>

<h2>Promise的横空出世</h2>

<p><img src="/images/blog_img/%E6%8B%89%E9%92%A9-%E6%89%BF%E8%AF%BA-promise.jpg" alt="Promise承诺" /></p>

<p>因此很多JavaScript牛人开始寻找解决这回调地狱的模式设计，随后Promise（jQuery的<code>deferred</code>也属于Promise范畴）便被引入到了JavaScript的世界。Promise在英语中语义为：”承诺“，它表示如A调用一个长时间任务B的时候，B将返回一个”承诺“给A，A不用关心整个实施的过程，继续做自己的任务；当B实施完成的时候，会通过A，并将执行A之间的预先约定的回调。而deferred在英语中语义为：”延迟“，这也说明promise解决的问题是一种带有延迟的事件，这个事件会被延迟到未来某个合适点再执行。</p>

<p><a href="http://promises-aplus.github.io/promises-spec/">Promise/A+规范</a>：</p>

<ul>
<li>Promise 对象有三种状态： Pending &ndash; Promise对象的初始状态，等到任务的完成或者被拒绝；Fulfilled &ndash; 任务执行完成并且成功的状态；Rejected &ndash; 任务执行完成并且失败的状态；</li>
<li>Promise的状态只可能从“Pending”状态转到“Fulfilled”状态或者“Rejected”状态，而且不能逆向转换，同时“Fulfilled”状态和“Rejected”状态也不能相互转换；</li>
<li>Promise对象必须实现then方法，then是promise规范的核心，而且then方法也必须返回一个Promise对象，同一个Promise对象可以注册多个then方法，并且回调的执行顺序跟它们的注册顺序一致；</li>
<li>then方法接受两个回调函数，它们分别为：成功时的回调和失败时的回调；并且它们分别在：Promise由“Pending”状态转换到“Fulfilled”状态时被调用和在Promise由“Pending”状态转换到“Rejected”状态时被调用。</li>
</ul>


<p>根据<a href="http://promises-aplus.github.io/promises-spec/">Promise/A+规范</a>，我们在文章开始的Promise伪代码就可以转换为如下代码：</p>

<pre class='green'><code>asyncTask1(data)
    .then(function(data1){
        return asyncTask2(data1);
    })
    .then(function(data2){
       return asyncTask3(data2);
    })
    // 仍然可以继续then方法
</code></pre>

<p>Promise将原来回调地狱中的回调函数，从横向式增加巧妙的变为了纵向增长。以链式的风格，纵向的书写，使得代码更加的可读和易于维护。</p>

<p>Promise在JavaScript的世界中逐渐的被大家所接受，所以在ES6的标准版中已经引入了Promise的规范了。现在通过Babel，可以完全放心的引入产品环境之中了。</p>

<p>另外，对于解决这类异步任务的方式，在ES7中将会引入<code>async、await</code>两个关键字，以同步的方式来书写异步的任务，它被誉为”JavaScript异步处理的终极方案“。这两个关键字是ES6标准中生成器（<code>generator</code>）和Promise的组合新语法，内置<code>generator</code>的执行器的一种方式。当然<code>async、await</code>的讲解并不会在本文中展开，有兴趣的读者可以参见MDN资料。</p>

<h2>Promise的妙用</h2>

<p>如上所说Promise在处理异步回调或者是延迟执行任务时候，是一个不错的选择方案。下面我们将介绍一些Promise的使用技巧（下面将利用Angular的<code>$q</code>和<code>$http</code>为例，当然对于jQuery的<code>deferred</code>，ES6的Promise仍然实用）：</p>

<h4>多个异步任务的串行处理</h4>

<p>在上文中提到的回调地狱案例，就是一种试图去将多个异步的任务串行处理的结果，使得代码不断的横向延伸，可读性和维护性急剧下降。当然我们也提到了Promise利用链式和延迟执行模型，将代码从横向延伸拉回了纵向增长。使用Angular中<code>$http</code>的实现如下：</p>

<pre class='green'><code>$http.get('/demo1')
 .then(function(data){
     console.log('demo1', data);
     return $http.get('/demo2', {params: data.result});
  })
 .then(function(data){
     console.log('demo2', data);
     return $http.get('/demo3', {params: data.result});
  })
 .then(function(data){
     console.log('demo3', data.result);
  });
</code></pre>

<p>因为Promise是可以传递的，可以继续<code>then</code>方法延续下去，也可以在纵向扩展的途中改变为其他Promise或者数据。所以在例子中的$http也可以换为其他的Promise（如$<code>timeout</code>，<code>$resource</code> &hellip;）。</p>

<h4>多个异步任务的并行处理</h4>

<p>在有些场景下，我们所要处理的多个异步任务之间并没有像上例中的那么强的依赖关系，只需要在这一系列的异步任务全部完成的时候执行一些特定逻辑。这个时候为了性能的考虑等，我们不需要将它们都串行起来执行，并行执行它们将是一个最优的选择。如果仍然采用回调函数，则这是一个非常恼人的问题。利用Promise则同样可以优雅的解决它：</p>

<pre class='green'><code>$q.all([$http.get('/demo1'),
        $http.get('/demo2'),
        $http.get('/demo3')
])
.then(function(results){
    console.log('result 1', results[0]);
    console.log('result 2', results[1]);
    console.log('result 3', results[2]);
});
</code></pre>

<p>这样就可以等到一堆异步的任务完成后，在执行特定的业务回调了。在Angular中的路由机制<code>ngRoute</code>、<code>uiRoute</code>的resolve机制也是采用同样的原理：在路由执行的时候，会将获取模板的Promise、获取所有resolve数据的Promise都拼接在一起，同时并行的获取它们，然后等待它们都结束的时候，才开始初始化<code>ng-view</code>、<code>ui-view</code>指令的scope对象，以及compile模板节点，并插入页面DOM中，完成一次路由的跳转，切换view，将静态的HTML模板变为动态的网页展示出来。</p>

<p>Angular路由机制的伪代码如下：</p>

<pre class='green'><code>    var getTemplatePromise = function(options) {
         // ... 拼接所有template或者templateUrl
    };

    var getResolvePromises = function(resolves) {
        // ... 拼接所有resolve
    };

    var controllerLoader = function(options, currentScope, tplAndVars, initLocals) {
        // ...

        ctrlInstance = $controller(options.controller, ctrlLocals);
        if (options.controllerAs) {
            currentScope[options.controllerAs] = ctrlInstance;
        }

        // ...

        return currentScope;
    };

    var templateAndResolvePromise = $q.all([getTemplatePromise(options)].concat(getResolvePromises(options.resolve || {})));

    return templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
        var currentScope = currentScope || $rootScope.$new();
        controllerLoader(options, currentScope, tplAndVars, initLocals);
        // ... compile &amp; append dom 
    });
</code></pre>

<p>对于这类路由机制的使用，在博主上篇博文<a href="http://greengerong.com/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian/">《自定义Angular插件 &ndash; 网站用户引导》</a>中的ng-trainning插件中也采用了它。关于这段代码的具体分析和应用将在后续单独的文章中，敬请大家期待。</p>

<h4>对于同步数据的Promise处理，统一调用接口</h4>

<p>有了Promise的处理，因为在前端代码中最多的异步处理就是Ajax，它们都被包装为了Promise .then的风格。那么对于一部分同步的非异步处理呢？如localStorage、setTimeout、setInterval之类的方法。在大多数情况下，博主仍然推荐使用Promise的方式包装，使得项目Service的返回接口统一。这样也便于像上例中的多个异步任务的串行、并行处理。在Angular路由中对于只设置template的情况，也是这么处理的。</p>

<p>对于setTimeout、setInterval在Angular中都已经为我们内置了$timeout和$interval服务，它们就是一种Promise的封装。对于localStorage呢？可以采用$q.when方法来直接包装localStorage的返回值的为Promise接口，如下所示：</p>

<p>  var data = $window.localStorage.getItem(&lsquo;data-api-key&rsquo;);
  return $q.when(data);</p>

<p>整个项目的Service层的返回值都可以被封装为统一的风格使用了，项目变得更加的一致和统一。在需要多个Service同时并行或者串行处理的时候，也变得简单了，一致的使用方式。</p>

<h4>对于延迟任务的Promise DSL语义化封装</h4>

<p>在前面已经提到Promise是延迟到未来执行某以特定任务，而在当前给消费者返回一个”承诺“，它并不会阻塞消费者的线程，在接受到”承诺“之后，消费者就不用再关心这些任务是如何完成的，以及也不需要不断地督促身生产者是否完成了等。</p>

<p>对于这类延迟机制，在前端的UI交互中也是极其常见的。比如模态窗口的显示，对于用户在模态窗口中的交互结果并不可提前预知的，用户是点击”ok“按钮，或者是”cancel“按钮，这是一个未来将会发生的延迟事件。对于这类场景的处理，也是Promise所擅长的领域。在Angular-UI的Bootstrap的modal的实现也是基于Promise的封装。</p>

<pre class='green'><code>$modal.open({
    templateUrl: '/templates/modal.html',
    controller: 'ModalController',
    controllerAs: 'modal',
    resolve: {
    }
})
    .result
    .then(function ok(data) {
        // 用户点击ok按钮事件
    }, function cancel(){
        // 用户点击cancel按钮事件
    });
</code></pre>

<p>这是因为modal在open方法的返回值中给了我们一个Promise的result对象（承诺）。等到用户在模态窗口中点击了ok按钮，则Bootstrap会使用<code>$q</code>的<code>defer</code>来<code>resolve</code>来执行ok事件；相反，如果用户点击了cancel按钮，则会使用<code>$q</code>的<code>defer</code>来<code>reject</code>执行cancel事件。</p>

<p>这样就很好的解决了延迟触发的问题，也避免了<code>callback的地狱</code>。我们仍然可以进一步将其返回值语义化，以业务自有的术语命名而形成一套DSL API。</p>

<pre class='green'><code> function open(data){
    var defer = $q.defer();

    // resolve or reject defer;

    var promise = defer.promise;
    promise.ok = function(func){
        promise.then(func);
        return promise;
    };

    promise.cancel = function(func){
        promise.then(null, func);
        return promise;
    };

    return promise;
};
</code></pre>

<p>则我们可以如下方式来访问它：</p>

<pre class='green'><code>$modal.open(item)
   .ok(function(data){
        // ok逻辑
   })
   .cancel(function(data){
       // cancel 逻辑
   });
</code></pre>

<p>是不是感觉更具有语义呢？在Angular中$http的返回方法success、error也是同样逻辑的封装。将success的注册函数注册为.then方法的成功回调，error的注册方法注册为then方法的失败回调。所以success和error方法只是Angular框架为我们在Promise语法之上封装的一套语法糖而已。</p>

<p>Angular的success、error回调的实现代码：</p>

<pre class='green'><code>  promise.success = function(fn) {
    promise.then(function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };

  promise.error = function(fn) {
    promise.then(null, function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };
</code></pre>

<h4>利用Promise来实现管道式AOP拦截</h4>

<p>在软件设计中，AOP是Aspect-Oriented Programming的缩写，意为：面向切面编程。通过编译时（Compile）植入代码、运行期（Runtime）动态代理、以及框架提供管道式执行等策略实现程序通用功能与业务模块的分离，统一处理、维护的一种解耦设计。 AOP是OOP的延续，是软件开发中的一个热点，也是很多服务端框架（如Java世界的Spring）中的核心内容之一，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。 AOP实用的场景主要有：权限控制、日志模块、事务处理、性能统计、异常处理等独立、通用的非业务模块。关于更多的AOP资料请参考<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a>。</p>

<p>在Angular中同样也内置了一些AOP的设计思想，便于实现程序通用功能与业务模块的分离、解耦、统一处理和维护。$http中的拦截器（interceptors）和装饰器（$provide.decorator）是Angular中两类常见的AOP切入点。前者以管道式执行策略实现，而后者则通过运行时的Promise管道动态实现的。</p>

<p>首先回顾一下Angular的拦截器实现方式：</p>

<pre class='green'><code>// 注册一个拦截器服务
$provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
  return {
    // 可选方法
    'request': function(config) {
      // 请求成功后处理
      return config;
    },

    // 可选方法
   'requestError': function(rejection) {
      // 请求失败后的处理
      if (canRecover(rejection)) {
        return responseOrNewPromise
      }
      return $q.reject(rejection);
    },



    // 可选方法
    'response': function(response) {
      // 返回回城处理
      return response;
    },

    // 可选方法
   'responseError': function(rejection) {
      // 返回失败的处理
      if (canRecover(rejection)) {
        return responseOrNewPromise
      }
      return $q.reject(rejection);
    }
  };
});

// 将服务注册到拦截器链中
$httpProvider.interceptors.push('myHttpInterceptor');


// 同样也可以将拦截器注册为一个工厂方法。 但上一中方式更为推荐。
$httpProvider.interceptors.push(['$q', function($q) {
  return {
   'request': function(config) {
       // 同上
    },

    'response': function(response) {
       // 同上
    }
  };
}]);
</code></pre>

<p>这样就可以实现对Angular中的<code>$http</code>或者是<code>$resource</code>的Ajax请求拦截了。但在Angular内部是是如何实现这种拦截方式的呢？Angular使用的就是Promise机制，形成异步管道流，将真实的Ajax请求防止在request、requestError和response、responseError的管道中间，因此就产生了对Ajax请求的拦截。</p>

<p>其源码实现如下：</p>

<pre class='green'><code>var interceptorFactories = this.interceptors = [];

var responseInterceptorFactories = this.responseInterceptors = [];

this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
  function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {

    var defaultCache = $cacheFactory('$http');

    var reversedInterceptors = [];

    forEach(interceptorFactories, function(interceptorFactory) {
      reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    });

    forEach(responseInterceptorFactories, function(interceptorFactory, index) {
      var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);

      reversedInterceptors.splice(index, 0, {
        response: function(response) {
          return responseFn($q.when(response));
        },
        responseError: function(response) {
          return responseFn($q.reject(response));
        }
      });
    });
    ...

function $http(requestConfig) {
  ...

  var chain = [serverRequest, undefined];
  var promise = $q.when(config);

  // apply interceptors
  forEach(reversedInterceptors, function(interceptor) {
    if (interceptor.request || interceptor.requestError) {
      chain.unshift(interceptor.request, interceptor.requestError);
    }
    if (interceptor.response || interceptor.responseError) {
      chain.push(interceptor.response, interceptor.responseError);
    }
  });

  while (chain.length) {
    var thenFn = chain.shift();
    var rejectFn = chain.shift();

    promise = promise.then(thenFn, rejectFn);
  }

  promise.success = function(fn) {
    promise.then(function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };

  promise.error = function(fn) {
    promise.then(null, function(response) {
      fn(response.data, response.status, response.headers, config);
    });
    return promise;
  };

  return promise;
};
</code></pre>

<p>在上面紧接着在$get注入方法之后，Angular会将interceptors和responseInterceptors反转合并到一个reversedInterceptors的拦截器内部变量中保存。最后在$http函数中以[serverRequest, undefined]（serverRequest是Ajax请求的promise操作）为中心，将reversedInterceptors中的所有拦截器函数依次加入到chain链式数组中。如果是request或requestError，那么就放在链式数组起始位置；相反如果是response或responseError，那么就放在链式数组最后。</p>

<p>注意添加在chain的request和requestError或者response和responseError都一定是成对的，换句话说可能注册一个非空的request与一个为undefined的requestError，或者是一个为undefined的request与非空的requestError。就像chain数组的声明一样（var chain = [serverRequest, undefined];），成对的放入serverRequest和undefined对象到数组中。因为后面的代码将利用Promise的机制注册这些拦截器函数，实现管道式AOP拦截机制。</p>

<p>在Promise中需要两个函数来注册回调，分别为成功回调和失败回调。在这里request和response会被注册成Promise的成功回调，而requestError和responseError则会注册成Promise的失败回调。所以在chain中添加的request和requestError，response或responseError都是成对出现的，这是为了能在接下来的循环中简洁地注册Promise回调函数。 这些被注册的拦截器链，会通过$q.when(config) Promise启动，它会首先传入$http的config对象，并执行所有的request拦截器，依次再到serverRequest这个Ajax请求，此时将挂起后边所有的response拦截器，直到Ajax请求响应完成，再依次执行剩下的response拦截器回调； 如果在request过程中有异常失败则会执行后边的requestError拦截器，对于Ajax请求的失败或者处理Ajax的response拦截器的异常也会被后面注册的responseError拦截器捕获。</p>

<p>从最后两段代码也能了解到关于$http服务中的success方法和error方法，是Angular为大家提供了一种Promise的便捷写法。success方法是注册一个传入的成功回调和为undefined的错误回调，而error则是注册一个为null的成功回调和一个传入的失败回调。</p>

<h2>总结</h2>

<p>写到这里，本文也进入了尾声。希望大家能够对Promise有一定的理解，并能够”信手拈来“的运用在实际的项目之中，增强代码的可读性和可维护性。在本文中所用到的例子，你都可以在博主的jsbin<a href="http://jsbin.com/bayeva/edit?html,js,output">http://jsbin.com/bayeva/edit?html,js,output</a>中找到它们。</p>

<p>另外，同时也欢迎关注博主的微信公众号[破狼]，这里将会为大家地时间推送博主的最新博文，谢谢大家的支持和鼓励。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian/">自定义Angular插件 - 网站用户引导</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-18T19:47:51+08:00" pubdate data-updated="true">Oct 18<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近由于项目进行了较大的改版，为了让用户能够适应这次新的改版，因此在系统中引入了“用户引导”功能，对于初次进入系统的用户一些简单的使用培训training。对于大多数网站来说，这是一个很常见的功能。所以在开发这个任务之前，博主尝试将其抽象化，独立于现有系统的业务逻辑，将其封装为一个通用的插件，使得代码更容易扩展和维护。</p>

<p>无图无真相，先上图：</p>

<p><img src="/images/blog_img/training-demo.png" alt="training demo" /></p>

<p>关于这款trainning插件的使用很简单，它采用了类似Angular路由一样的配置，只需要简单的配置其每一步training信息。</p>

<ul>
<li>title：step的标题信息；</li>
<li>template/templateUrl: step的内容模板信息。这类可以配置html元素，或者是模板的url地址，同时templateUrl也支持Angular route一样的function语法；</li>
<li>controller: step的控制器配置；在controller中可注入如下参数：当前step &ndash; currentStep、所有step的配置 &ndash; trainnings、当前step的配置 &ndash; currentTrainning、以及下一步的操作回调 &ndash; trainningInstance（其中nextStep：为下一步的回调，cancel为取消用户引导回调）；</li>
<li>controllerAs: controller的别名；</li>
<li>resolve：在controller初始化前的数据配置，同Angular路由中的resolve；</li>
<li>locals：本地变量，和resolve相似，可以传递到controller中。区别之处在于它不支持function调用，对于常量书写会比resolve更方便；</li>
<li>placement: step容器上三角箭头的显示方位；</li>
<li>position: step容器的具体显示位置，这是一个绝对坐标；可以传递<code>{left: 100, top: 100}</code>的绝对坐标，也可以是<code>#stepPanelHost</code>配置相对于此元素的placement位置。同时它也支持自定义function和注入Angular的其他组件语法。并且默认可注入：所有step配置 &ndash; trainnings,当前步骤 &ndash; step，当前step的配置 &ndash; currentTrainning，以及step容器节点 &ndash; stepPanel；</li>
<li>backdrop：是否需要显示遮罩层，默认显示，除非显示声明为false配置，则不会显示遮罩层；</li>
<li>stepClass：每一个step容器的样式信息；</li>
<li>backdropClass： 每一个遮罩层的样式信息。</li>
</ul>


<p>了解了这些配置后，并根据特定需求定制化整个用户引导的配置信息后，我们就可以使用trainningService的trainning方法来在特定实际启动用户引导，传入参数为每一步step的配置信息。并可以注册其done或者cancel事件：</p>

<pre class='green'><code>trainningService.trainning(trainningCourses.courses)
    .done(function() {
        vm.isDone = true;
    });
</code></pre>

<p>下面是一个演示的配置信息：</p>

<pre class='green'><code>    .constant('trainningCourses', {
                courses: [{
                    title: 'Step 1:',
                    templateUrl: 'trainning-content.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    placement: 'left',
                    position: '#blogControl'
                },{
                    title: 'Step 3:',
                    templateUrl: 'trainning-content.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    placement: 'top',
                    position: {
                        top: 200,
                        left: 100
                    }
                },
                    ...
                {
                    stepClass: 'last-step',
                    backdropClass: 'last-backdrop',
                    templateUrl: 'trainning-content-done.html',
                    controller: 'StepPanelController',
                    controllerAs: 'stepPanel',
                    position: ['$window', 'stepPanel', function($window, stepPanel) {
                        // 自定义函数，使其屏幕居中
                        var win = angular.element($window);
                        return {
                            top: (win.height() - stepPanel.height()) / 2,
                            left: (win.width() - stepPanel.width()) / 2
                        }
                    }]
                }]
            })
</code></pre>

<p>本文插件源码和演示效果唯一codepen上，效果如下：</p>

<p data-height="385" data-theme-id="0" data-slug-hash="pjwXQW" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/pjwXQW/'>ng-trainning</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="//assets.codepen.io/assets/embed/ei.js" async="true"></script>


<p>在trainning插件的源码设计中，包含如下几个要点：</p>

<ul>
<li>提供service api。因为关于trainning这个插件，它是一个全局的插件，正好在Angular中所有的service也是单例的，所以将用户引导逻辑封装到Angular的service中是一个不错的设计。但对于trainning的每一步展示内容信息则是DOM操作，在Angular的处理中它不该存在于service中，最佳的方式是应该把他封装到Directive中。所以这里采用Directive的定义，并在service中compile，然后append到body中。</li>
<li>对于每一个这类独立的插件应该封装一个独立的scope，这样便于在后续的销毁，以及不会与现有的scope变量的冲突。</li>
<li>$q对延时触发的结果包装。对于像该trainning插件或者modal这类操作结果采用promise的封装，是一个不错的选择。它取代了回调参数的复杂性，并以流畅API的方式展现，更利于代码的可读性。同时也能与其他Angular service统一返回API。</li>
<li>对于controller、controllerAs、resolve、template、templateUrl这类类似路由的处理代码，完全可以移到到你的同类插件中去。它们可以增加插件的更多定制化扩展。关于这部分代码的解释，博主将会在后续文章中为大家推送。</li>
<li>利用$injector.invoke动态注入和调用Angular service，这样既能获取Angular其他service注入的扩展性，也能获取到函数的动态性。如上例中的屏幕居中的自定义扩展方式。</li>
</ul>


<p>这类设计要点，同样可以运用到想modal、alert、overload这类全局插件中。有兴趣的读者，你可以在博主的codepen笔记中阅读这段代码<a href="http://codepen.io/greengerong/pen/pjwXQW#0">http://codepen.io/greengerong/pen/pjwXQW#0</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/13/smartcrop-dot-js-zhi-neng-tu-pian-cai-jian/">smartcrop.js智能图片裁剪库</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-13T21:58:21+08:00" pubdate data-updated="true">Oct 13<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天将为大家介绍一款近期github上很不错的开源库 &ndash; <a href="https://github.com/jwagner/smartcrop.js">smartcrop.js</a>。它是一款图片处理的智能裁剪库。在很多项目开发中，经常会遇见上传图片的场景，它可能是用户照片信息，也可能是商品图片等。然而在网页布局中，为了更好的用户体验，它们往往都需要一些宽度和高度的限制。对于不合适的图片，常常需要为用户提供一种裁剪方式，以此来满足网站更好的用户体验。但是图片默认的裁剪区域往往被显示在一个固定的位置，而这个位置却往往又不是精准的用户裁剪位置。因此今天为大家介绍的这一款开源库，就是为了解决这类问题，并为用户提供更好的用户体验的。</p>

<p>首先我们可以使用<code>npm install smartcrop</code>或者<code>bower install smartcrop</code>来下载它。然后像如下方式使用它：</p>

<pre class='green'><code>SmartCrop.crop(image, {
        width: 100,
        height: 100
    }, 
    function(result){
        console.log(result); // {topCrop: {x: 300, y: 200, height: 200, width: 200}}
    });
</code></pre>

<p>它会输出一个比较好的最佳图片裁剪位置，如<code>{topCrop: {x: 300, y: 200, height: 200, width: 200}}</code>的数据。</p>

<p>下面是一副来自它的展示网站的案例，请欣赏：</p>

<p><img src="/images/blog_img/smartcrop-%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA-%E6%A1%88%E4%BE%8B.png" alt="smartcrop-图片裁剪-案例" /></p>

<p>更多案例：</p>

<ol>
<li><a href="http://29a.ch/sandbox/2014/smartcrop/examples/testsuite.html">http://29a.ch/sandbox/2014/smartcrop/examples/testsuite.html</a>：这里拥有超过1000个图片效果的展示（流量用户请谨慎点击，图片众多）；</li>
<li><a href="http://29a.ch/sandbox/2014/smartcrop/examples/testbed.html">http://29a.ch/sandbox/2014/smartcrop/examples/testbed.html</a>：这里允许上传本地的图片，并体验其效果；</li>
<li><a href="http://29a.ch/sandbox/2014/smartcrop/examples/slideshow.html">http://29a.ch/sandbox/2014/smartcrop/examples/slideshow.html</a>：在这里可以尝试用它创建幻灯片。</li>
</ol>


<p>最后，更多关于smartcrop.js的信息，请参见其github：<a href="https://github.com/jwagner/smartcrop.js">https://github.com/jwagner/smartcrop.js</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/13/shu-xie-gao-xiao-de-css-dai-ma/">书写高效的CSS代码-（待开发）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-13T21:36:54+08:00" pubdate data-updated="true">Oct 13<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/09/css-chi-cun-dan-wei-em-px-huan-shi-percent/">CSS尺寸和字体单位-em、px还是%</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-09T07:00:04+08:00" pubdate data-updated="true">Oct 9<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在页面整体布局中，页面元素的尺寸大小（长度、宽度、内外边距等）和页面字体的大小也是重要的工作之一。一个合理设置，则会让页面看起来层次分明，重点鲜明，赏心悦目。反之，一个不友好的页面尺寸和字体大小设置，则会增加页面的复杂性，增加用户对页面理解的复杂性；甚至在当下访问终端（iPhone、iPad、PC、Android&hellip;）层出不穷的今天，适应各式各样的访问终端，将成为手中的一块“烫手的山芋”。所以在近几年，“九宫格”式的“流式布局”再度回归。为了提供页面布局，及其它的可维护性、可扩展性，我们尝试将页面元素的大小，以及字体大小都设置为相对值，不再是孤立的固定像素点。使其能在父元素的尺寸变化的同时，子元素也能随之适应变化。以及结合少量最新CSS3的@media查询，来实现“响应式布局”，bootstrap这类CSS框架大势兴起。</p>

<p>然而在CSS中，W3C文档把尺寸单位划为为两类：相对长度单位和绝对长度单位。然而相对长度单位按照不同的参考元素，又可以分为字体相对单位和视窗相对单位。字体相对单位有：em、ex、ch、rem；视窗相对单位则包含：vw、vh、vmin、vmax几种。绝对定位则是固定尺寸，它们采用的是物理度量单位：cm、mm、in、px、pt以及pc。但在实际应用中，我们使用最广泛的则是em、rem、px以及百分比（%）来度量页面元素的尺寸。</p>

<ol>
<li>px：为像素单位。它是显示屏上显示的每一个小点，为显示的最小单位。它是一个绝对尺寸单位；</li>
<li>em：它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；</li>
<li>%： 百分比，它是一个更纯粹的相对长度单位。它描述的是相对于父元素的百分比值。如50%，则为父元素的一半。</li>
</ol>


<p>这里需要注意的是：em是相对于应用于当前当前元素的字体尺寸；而百分比则是相对于父元素的尺寸。如下面示例：</p>

<p>HTML：</p>

<pre class='green'><code>&lt;div class="parent"&gt;
     &lt;div class="em-demo"&gt;
      设置长度为5em demo
     &lt;/div&gt;

     &lt;div class="percentage-demo"&gt;
      设置长度为80% demo
     &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>CSS：</p>

<pre class='green'><code>div{
    border: 1px dashed #808080;
    margin:10px
}

.parent{
    width: 200px;
    font-size: 18px;
}

.em-demo{
    width: 5em;
}

.percentage-demo{
    width: 80%
}
</code></pre>

<p>则其效果图为(<a href="http://jsbin.com/xihusojale/edit?html,css,output">http://jsbin.com/xihusojale/edit?html,css,output</a>)：</p>

<p><img src="/images/blog_img/em-percentage-demo.png" alt="em percentage demo" /></p>

<p>从图上我们可以看出：设置5em的div的第一行字符刚好为5个字符大小，因为如上所说，它是相对于当前元素字体的尺寸， 5 * 18 = 90px。而百分比显示则会比较大一些，因为它是相对于父元素的尺寸比例， 200 * 80% = 160px。</p>

<p>对于px、em和百分比都能设置元素的尺寸和字体大小，但是它们各自有自己所不同的应用场景。不合理的运用，则会导致页面的混乱、难易维护和扩展。对于它们的使用，有如下几点被大家所认同的最佳实践：</p>

<ol>
<li>尽量使用相对尺寸单位</li>
</ol>


<p>使用相对尺寸单位计量，则在调整页面的布局的时候，不需要遍历所有的内部DOM结构，重新设置内部子元素的尺寸大小，同时它也能更好的适应与多中分辨率和屏幕终端。采用相对定位，并不意味着页面整体的自适应。</p>

<p>当然，对于希望整体网站的“响应式设计”，适应当今层出不穷的的各类访问终端，相对尺寸布局将发挥更大的价值。我们仅需要利用CSS3的@media查询来设置外围的整体宽度，以及少量在设备上不一致的用户体验。关于“响应式布局”，可以更多的参考bootstrap这类新兴的CSS框架。</p>

<p>对于相对尺寸单位的设置：em和%因为它们相对的参考物不同，所以它们也有不同的使用场景。如果希望随着当前元素的字体尺寸而改变尺寸，则使用em最佳，如：行高、字体大小。相反，如果是随着父容器或者是整体页面布局而改变尺寸，则使用%更好，如元素的高度和宽度设置。</p>

<ol>
<li>只在可预知的元素上使用绝对尺寸</li>
</ol>


<p>并不是所有的元素设置相对尺寸就是最佳的。对于如图表icon、如video这类多媒体元素、网页整体的宽度这类可预知尺寸，设置为绝对路径可能反而是最佳的选择。但他们需要试具体场景而定，从而获得最佳体验。不管我们如此设置相对尺寸，但在外层也总会有一些绝对尺寸度量，才可能存在百分比这类相对尺寸设置。</p>

<ol>
<li>字体尺寸尽量使用em、rem</li>
</ol>


<p>和尽量使用相对尺寸单位一样，为了字体大小的可维护性和伸缩性，W3C更推荐使用em作为字体尺寸单位。需要注意的是，如果存在3层以及3层以上的字体相对尺寸的设置，则对于实际字体大小的计算，就会变得相对麻烦。这个时候，在满足浏览器兼容性的情况下，可以考虑使用CSS3的新特性rem：根据固定根元素的字体大小来设置相对尺寸大小，这也是近几年移动APP所兴起的使用方式。</p>

<p>rem的兼容性，我们可以用<a href="http://caniuse.com/#feat=rem">Can I Use</a>网站获取。</p>

<p><img src="/images/blog_img/rem-%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="rem 兼容性" /></p>

<ol>
<li>@media查询做平台适配，但禁止随处滥用</li>
</ol>


<p>如上所说CSS3的@media查询，能帮助我们做到多平台终端的自适应布局，得到一个更好的用户体验。但这绝不意味着我们可以随处滥用它，在CSS代码中存在太多的平台差异的代码，这也会增加代码可读性、维护性的难度。更好的方式则是仅在必须使用它的场景下，合理的使用它，如页面外围的整体宽度，不同显示的菜单栏等。更多的体验适应性，可以移动到使用“流式布局”来实现。</p>

<p>关于响应式设计，这是对开发周期、成本和平台体验的一个权衡的结果。如果不考虑开发、维护的成本，则为不同平台终端提供不同的页面设计，这样得到的用户体验会更友好。但在实际开发中，开发和维护成本、产品生命周期也是一个重要的权衡标准，而响应式设计则是它们之间的权衡结果。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/28/duo-cai-de-consolexin-wan-fa/">多彩的Console打印新玩法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-28T08:53:40+08:00" pubdate data-updated="true">Sep 28<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Chrome应该是每一个Web开发者必备的工具之一。它有而强大的Devtool，辅助我们的JavaScript调试，审视DOM元素，CSS即时修改等。以及它还有一个的庞大的插件系统，同时我们也可以很容易的扩展属于自己的Chrome插件。如果希望了解更多的Chrome常用调试，请参见笔者早期的微信推送文章<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTM1NDcyOQ==&amp;mid=204026297&amp;idx=1&amp;sn=47294644cc7298ea3c57736ed0a75173&amp;scene=23&amp;srcid=0928aP9a3QHDyTOtc2Nhrszw#rd">《15个必须知道的chrome开发者技巧》</a>。</p>

<p>Chrome中的控制台console，是我们检查程序允许是否正常的常用工具之一，同时它也是我们打印调试日志信息，运行调试代码的常用工具。在国内近几年，它也成为了程序员招聘的渠道之一。如下面百度的招聘信息：</p>

<p><img src="/images/blog_img/baidu-console-recruitment.png" alt="百度console招聘" /></p>

<p>在Console中打印日志的方式有log、info、warn、error这几类方式。但它们并不是本文的主题。对于日志信息打印来说，一直都显得很单调。直到最新版的Chrome和Firefox (+31)，我们可以尝试更多多彩的打印格式了。在最新的Google chrome文档中console.log支持如下的格式：</p>

<ol>
<li>%s   字符串格式化；</li>
<li>%d/%i    整数格式化；</li>
<li>%f   小数位数据格式化；</li>
<li>%o   可扩展的DOM节点格式化；</li>
<li>%O   可扩展的JavaScript对象格式化；</li>
<li>%c   利用CSS来自定义样式格式化输出。</li>
</ol>


<p>本文将要说的就是%c这个格式化器。我们可以利用CSS样式来控制打印信息的输出。这样我们就可以得到一个多彩的日志信息，或者就是招聘广告了。</p>

<p>下面代码输出效果为：</p>

<pre class='green'><code>console.log('%c [破狼]-[双狼说]!', 'background: #008000; color: #fff');
</code></pre>

<p>效果：</p>

<p><img src="/images/blog_img/console-log-po-lang.png" alt="彩色的console log" /></p>

<p>再如：下面这段来自<a href="http://stackoverflow.com/questions/7505623/colors-in-javascript-console">http://stackoverflow.com/questions/7505623/colors-in-javascript-console</a>示例，文字光影的效果：</p>

<p>代码比较长，请移步到stackoverflow查看。这里主要是利用的text-shadow这个CSS3特性来实现的，文字光影效果：</p>

<pre class='green'><code>var css = "text-shadow: -1px -1px hsl(0,100%,50%), 1px 1px hsl(5.4, 100%, 50%), 3px 2px hsl(10.8, 100%, 50%), .....";// 

console.log("%cExample %s", css, 'all code runs happy');
</code></pre>

<p>效果如下：</p>

<p><img src="/images/blog_img/console-log-demo-colorful-code.jpg" alt="彩色的console log" /></p>

<p>在github也有<a href="https://github.com/adamschwartz/log">log</a>的repo，感兴趣的读者也可以研究研究。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/24/es7-javascript-decorators/">细说ES7 JavaScript Decorators</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-24T15:00:40+08:00" pubdate data-updated="true">Sep 24<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>开篇概述</h2>

<p>在上篇的<a href="http://greengerong.com/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>中，我们预先体验了ES7的Decorators，虽然它只是一个简单的日志AOP拦截Demo。但它也足以让我们体会到ES7 Decorators的强大魅力所在。所以为什么博主会为它而专门写作此文。在Angular2中的TypeScript Annotate就是标注装潢器的另一类实现。同样如果你也是一个React的爱好者，你应该已经发现了redux2中也开始利用ES7的Decorators进行了大量重构。</p>

<p>尝试过Python的同学们，我相信你做难忘的应该是装潢器。由<a href="https://github.com/wycats">Yehuda Katz</a>提出的<a href="https://github.com/wycats/javascript-decorators">decorator模式</a>，就是借鉴于Python的这一特性。作为读者的你，可以从上一篇博文<a href="http://greengerong.com/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>中看到它们之间的联系。</p>

<h2>Decorators</h2>

<h4>背后原理</h4>

<p>ES7的Decorators让我们能够在设计时对类、属性等进行标注和修改成为了可能。Decorators利用了ES5的</p>

<pre class='green'><code>Object.defineProperty(target, name, descriptor);
</code></pre>

<p>来实现这一特性。如果你还不了解Object.defineProperty，请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN文档</a>。首先我们来考虑一个普通的ES6类：</p>

<pre class='green'><code>class Person {
  name() { return `${this.first} ${this.last}` }
}
</code></pre>

<p>执行这一段class，给Person.prototype注册一个name属性，粗略的和如下代码相似：</p>

<pre class='green'><code>Object.defineProperty(Person.prototype, 'name', {
  value: specifiedFunction,
  enumerable: false,
  configurable: true,
  writable: true
});
</code></pre>

<p>如果利用装潢器来标注一个属性呢？</p>

<pre class='green'><code>class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}
</code></pre>

<p>在这种装潢下的属性，则会在利用Object.defineProperty为Person.prototype注册name属性之前，执行这段装潢器：</p>

<pre class='green'><code>let descriptor = {
  value: specifiedFunction,
  enumerable: false,
  configurable: true,enumerable、
  writable: true
};

descriptor = readonly(Person.prototype, 'name', descriptor) || descriptor;
Object.defineProperty(Person.prototype, 'name', descriptor);
</code></pre>

<p>从上面的伪代码中，我们能看出，装潢器只是在Object.defineProperty为Person.prototype注册属性之前，执行一个装饰函数，其属于一类对Object.defineProperty的拦截。所以它和Object.defineProperty具有一致的方法签名，它们的3个参数分别为：</p>

<ol>
<li>obj：作用的目标对象；</li>
<li>prop：作用的属性名；</li>
<li>descriptor: 针对该属性的描述符。</li>
</ol>


<p>这里最重要的是descriptor这个参数，它是一个数据或访问器的属性描述对象。在对数据和访问器属性描述时，它们都具有configurable、enumerable属性可用。而在数据描述时，value、writable属性则是数据所特有的。get、set属性则是访问器属性描述所特有的。属性描述器中的属性决定了对象prop属性的一些特性。比如 enumerable，它决定了目标对象是否可被枚举，能够在for…in循环中遍历到，或者出现在Object.keys法的返回值中；writable则决定了目标对象的属性是否可以被更改。完整的属性描述，请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description">MDN文档</a>。</p>

<p>对于descriptor中的属性，它们可以被我们在Decorators中使用，或者修改的，以达到我们标注或者拦截的目的。这也是装潢器拦截的主体信息。</p>

<h4>作用于访问器</h4>

<p>装潢器也可以作用与属性的getter/setter访问器之上，如下将属性标注为不可枚举的代码：</p>

<pre class='green'><code>class Person {
  @nonenumerable
  get kidCount() { return this.children.length; }
}

function nonenumerable(target, name, descriptor) {
  descriptor.enumerable = false;
  return descriptor;
}
</code></pre>

<p>下面是一个更复杂的对访问器的备用录模式运用：</p>

<pre class='green'><code>class Person {
  @memoize
  get name() { return `${this.first} ${this.last}` }
  set name(val) {
    let [first, last] = val.split(' ');
    this.first = first;
    this.last = last;
  }
}

let memoized = new WeakMap();
function memoize(target, name, descriptor) {
  let getter = descriptor.get, setter = descriptor.set;

  descriptor.get = function() {
    let table = memoizationFor(this);
    if (name in table) { return table[name]; }
    return table[name] = getter.call(this);
  }

  descriptor.set = function(val) {
    let table = memoizationFor(this);
    setter.call(this, val);
    table[name] = val;
  }
}

function memoizationFor(obj) {
  let table = memoized.get(obj);
  if (!table) { table = Object.create(null); memoized.set(obj, table); }
  return table;
}   
</code></pre>

<h4>作用域类上</h4>

<p>同样Decorators也可以为class装潢，如下对类是否annotated的标注：</p>

<pre class='green'><code>// A simple decorator
@annotation
class MyClass { }

function annotation(target) {
   // Add a property on target
   target.annotated = true;
}
</code></pre>

<h4>也可以是一个工厂方法</h4>

<p>对于装潢器来说，它同样也可以是一个工厂方法，接受配置参数信息，并返回一个应用于目标函数的装潢函数。如下例子，对类可测试性的标记：</p>

<pre class='green'><code>@isTestable(true)
class MyClass { }

function isTestable(value) {
   return function decorator(target) {
      target.isTestable = value;
   }
}
</code></pre>

<p>同样工厂方法，也可以被应用于属性之上，如下对可枚举属性的配置：</p>

<pre class='green'><code>class C {
  @enumerable(false)
  method() { }
}

function enumerable(value) {
  return function (target, key, descriptor) {
     descriptor.enumerable = value;
     return descriptor;
  }
}
</code></pre>

<p>同样在上篇<a href="http://greengerong.com/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>中对于日志拦截的日志类型配置信息，也是利用工厂方法来实现的。它是一个更复杂的工厂方式的Decorators实现。</p>

<h4>后续</h4>

<p>如上一篇博问所说：虽然它是ES7的特性，但在Babel大势流行的今天，我们可以利用Babel来使用它。我们可以利用Babel命令行工具，或者grunt、gulp、webpack的babel插件来使用Decorators。</p>

<p>关于ES7 Decorators的更有意思的玩法，你可以参见牛人实现的常用的Decorators：<a href="https://github.com/jayphelps/core-decorators.js">core-decorators</a>。以及<a href="http://raganwald.com/">raganwald</a>的<a href="http://raganwald.com/2015/06/26/decorators-in-es7.html">如何用Decorators来实现Mixin</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-23T07:11:07+08:00" pubdate data-updated="true">Sep 23<span>rd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上篇博文<a href="http://greengerong.com/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>中，笔者利用CoffeeScript支持的高阶函数，以及方法调用可省略括符的特性，实现了一个类似Python装潢器的日志Demo。这只是一种伪实现，JavaScript实现装潢器，我们需要等到ECMAScript7才行，在ES7特性中带来了Decorators，它就是我们所需要的装潢器特性。虽然它是ES7的特性，但在Babel大势流行的今天，我们可以利用Babel来使用它。关于Babel的推荐文章，请参见另一篇文章<a href="http://greengerong.com/blog/2015/03/22/babel-kai-shi-es6ti-yan/">Babel-现在开始使用 ES6</a>。</p>

<p>下面我们仍然和上节<a href="http://greengerong.com/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a>一样，实现一个ES7 Decorators版的日志拦截示例。我们希望得到的代码效果如下：</p>

<pre class='green'><code>class MyClass {
  @log('MyClass add')
  add(a, b){
    return a + b;
  }
  @log('MyClass product')
  product(a, b){
    return a * b;
  }
  @log('MyClass error')
  error(){
     throw 'Something is wrong!';
   }
}
</code></pre>

<p>在ES7中Decorators，也是一个函数，我们只需要在它前面加上@符号，并将它标注在特定的目标，如class、method等，则可以实现方法的包裹拦截。它的传入参数有：target, name, descriptor。它们分别标记目标，标记目标名称，以及目标描述信息。在descriptor中，包括configurable、enumerable、writable，value四个属性。它们分别可以控制目标的读写、枚举，以及目标值。</p>

<p>所以我们可以如下实现：</p>

<pre class='green'><code>let log = (type) =&gt; {
    const logger = new Logger('#console');
    return (target, name, descriptor) =&gt; {
      const method = descriptor.value;
      descriptor.value =  (...args) =&gt; {
            logger.info(`(${type}) before function execute: ${name}(${args}) = ?`);
            let ret;
            try {
                ret = method.apply(target, args);
                logger.info(`(${type})after function execute success: ${name}(${args}) =&gt; ${ret}`);
            } catch (error) {
                logger.error(`(${type}) function execute error: ${name}(${args}) =&gt; ${error}`);
            } finally {
                logger.info(`(${type}) function execute done: ${name}(${args}) =&gt; ${ret}`);
            }
            return ret;
        }
    }
}
</code></pre>

<p>首先我们将原来的方法体缓存起来，直到方法调用时，才会被调用以实现方法调用前后的日志拦截，打印相关信息。示例的效果如下：</p>

<p><img src="/images/blog_img/es7-decorators-log-aop.png" alt="es7 decorators log aop" /></p>

<p>整个demo示例，你也可以在codepen上细细把玩：</p>

<p data-height="350" data-theme-id="0" data-slug-hash="epzbMV" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/epzbMV/'>ES7 Decorators</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async="true" src="//assets.codepen.io/assets/embed/ei.js"></script>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/22/coffeescript-shi-xian-python-zhuang-huang-qi/">CoffeeScript实现Python装潢器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-22T21:09:03+08:00" pubdate data-updated="true">Sep 22<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上篇<a href="http://greengerong.com/blog/2015/09/12/coffeescriptban-ngcomponentfeng-zhuang/">Angular遇上CoffeeScript &ndash; NgComponent封装</a>中，我们讲述了CoffeeScript这门小巧的语言，摒弃JavaScript中糟粕（“坑”）部分，并将JavaScript中精粹部分发挥到淋淋尽致。虽然笔者更喜欢ES6 + Babel或者TypeScript这类鲜明特性的JavaScript语法。但是CoffeeScript也不失为一门不错的JavaScript扩展语言，特别在Ruby社区仍然是一个很好的选择。</p>

<p>在本节中，我们将会利用CoffeeScript来模拟Python中的装潢器实现。Python的装潢器是属于一类来自于语言层次的AOP实现。AOP是Aspect-Oriented Programming的缩写，意为：面向切面编程。通过编译时（Compile）植入代码、运行期（Runtime）动态代理、以及框架提供管道式执行等策略实现程序通用功能与业务模块的分离，统一处理、维护的一种解耦设计。AOP是OOP的延续，是软件开发中的一个热点，也是很多服务端框架（如Java世界的Spring）中的核心内容之一，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可复用性，同时提高开发效率。 AOP实用的场景主要有：权限控制、日志模块、事务处理、性能统计、异常处理等独立、通用的非业务模块。关于更多的AOP资料请参考<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a>。</p>

<p>在Python中的装潢器也是一个普通的函数，我们只需要使用@符号将方法标注在另一个方法签名上就能实现对被标注方法的装潢。这也是Python这门函数式语言中高阶函数的运用。被装潢的方法将会被传入装潢函数中，被装潢包裹以实现方法的拦截。</p>

<p>Python中的装潢器如下：</p>

<pre class='green'><code>def deco(func):
    def _deco(*args, **kwargs):
        print("before %s called." % func.__name__)
        ret = func(*args, **kwargs)
        print("  after %s called. result: %s" % (func.__name__, ret))
        return ret
    return _deco

@deco
def myfunc(a, b):
    print(" myfunc(%s,%s) called." % (a, b))
    return a+b
</code></pre>

<p>这里的装潢器deco，将会包裹myfunc方法，实现调用前后的日志信息拦截。</p>

<p>在CoffeeScript中，我们如何实现呢？在CoffeeScript并没有真正的装潢器这一特性，但它存在高阶函数，可以如下包裹：</p>

<pre class='green'><code>log(myfunc)
</code></pre>

<p>在CoffeeScript中，我们也可以简化去掉方法（）符号：</p>

<pre class='green'><code>log myfunc
</code></pre>

<p>如果我们再像Python一样强制加上@符号，并将log函数放在方法声明右边，则似乎就有点接近Python的装潢器：</p>

<pre class='green'><code>f = @log (a, b) -&gt; a + b
</code></pre>

<p>不知作为读者的你，是否也有点装潢的感觉呢？不用着急，我们在来看一个完整的demo示例：</p>

<p data-height="268" data-theme-id="0" data-slug-hash="wKKQKv" data-default-tab="result" data-user="greengerong" class='codepen'>See the Pen <a href='http://codepen.io/greengerong/pen/wKKQKv/'>CoffeeScript- decorator</a> by green (<a href='http://codepen.io/greengerong'>@greengerong</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async="true" src="//assets.codepen.io/assets/embed/ei.js"></script>


<p>这里利用了高阶函数的log函数来包装我们的自定义函数。其实这只是高阶函数的运用，如果这门语法也能省略掉方法调用的（），则完全也可以做到如上实现。希望作为读者的你，到这里已经明白的在函数式中高阶函数的魅力，以及其重要性。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/19/verlet-js-javascript-wu-li-yin-qing/">Verlet-js JavaScript 物理引擎</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-19T22:20:34+08:00" pubdate data-updated="true">Sep 19<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>subprotocol最近在Github上开源了verlet-js。地址为<a href="https://github.com/subprotocol/verlet-js">https://github.com/subprotocol/verlet-js</a>。verlet-js是一个集成Verlet的物理引擎，利用JavaScript编写。verlet-js支持粒子系统、距离限制、角度限制等。其Github声称基于这些基础，则可以帮助我们构建几乎任何我们所能想象到的东西。</p>

<p>其官网为我们提供了一下几个demo：</p>

<ol>
<li><a href="http://subprotocol.com/verlet-js/examples/shapes.html">Shapes (verlet-js Hello world)</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/tree.html">Fractal Trees</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/cloth.html">Cloth</a></li>
<li><a href="http://subprotocol.com/verlet-js/examples/spiderweb.html">Spiderweb</a></li>
</ol>


<p>笔者觉得<a href="http://subprotocol.com/verlet-js/examples/spiderweb.html">Spiderweb</a>特别有意思，下面是它的效果截图：</p>

<p><img src="/images/blog_img/verlet-js-Spiderweb.png" alt="verlet-js Spiderweb" /></p>

<p><img src="/images/blog_img/verlet-js-cloth.png" alt="verlet-js Spiderweb" /></p>

<p>Github地址：<a href="https://github.com/subprotocol/verlet-js">https://github.com/subprotocol/verlet-js</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>破 狼</h1>
  <p>    那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息。 那一月，我转过所有经轮，不为超度，只为触摸你的指纹。 那一年，我磕长头拥抱尘埃，不为朝佛，只为贴着了你的温暖。 那一世，我翻遍十万大山，不为修来世，只为路中能与你相遇。 那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。<a href="http://greengerong.github.io/blog/2009/12/24/cang-yang-jia-cuo-na-yi-tian-na-yi-yue-na-yi-nian-na-yi-shi/">《那一天，那一月，那一年，那一世》&#8211;仓央嘉措。</a></p>
</section>
<section>
  <p style="align: center"><a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3158890&amp;c=9476983" alt="count web site visits"/></a></p>
</section>
<section>
    <h1>博客友情链接</h1>
    <ul>
        <li><a href="http://www.cnblogs.com/whitewolf/">博客园-破狼</a></li>
        <li><img src="http://greengerong.com/self/wei-xin-wolf-er-wei-ma.jpg" alt="破狼微信号订阅号" /></li>
    </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/22/promisede-miao-yong/">Promise的前世今生和妙用技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/18/angular-wang-zhan-yong-hu-yin-dao-cha-jian/">自定义Angular插件 - 网站用户引导</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/13/smartcrop-dot-js-zhi-neng-tu-pian-cai-jian/">smartcrop.js智能图片裁剪库</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/13/shu-xie-gao-xiao-de-css-dai-ma/">书写高效的CSS代码-（待开发）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/09/css-chi-cun-dan-wei-em-px-huan-shi-percent/">CSS尺寸和字体单位-em、px还是%</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/28/duo-cai-de-consolexin-wan-fa/">多彩的Console打印新玩法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/24/es7-javascript-decorators/">细说ES7 JavaScript Decorators</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/greengerong">@greengerong</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'greengerong',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 破 狼 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress
</a></span>
</p>

</footer>
  
 
 


</body>
</html>
