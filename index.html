
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>破狼 Blog</title>
  <meta name="author" content="破 狼">

  
  <meta name="description" content="Guice是由Google大牛Bob lee开发的一款绝对轻量级的java IoC容器。其优势在于： 速度快，号称比spring快100倍。
无外部配置(如需要使用外部可以可以选用Guice的扩展包)，完全基于annotation特性，支持重构，代码静态检查。
简单，快速，基本没有学习成本。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://greengerong.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="破狼 Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">破狼 Blog</a></h1>
  
    <h2>Write less got more.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:greengerong.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/10/light-ioc-guice-framework/">java轻量级IOC框架Guice</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-10T21:50:37+08:00" pubdate data-updated="true">Dec 10<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/12/10/light-ioc-guice-framework/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/12/10/light-ioc-guice-framework/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Guice是由Google大牛Bob lee开发的一款绝对轻量级的java IoC容器。其优势在于：</p>

<ol>
<li>速度快，号称比spring快100倍。</li>
<li>无外部配置(如需要使用外部可以可以选用Guice的扩展包)，完全基于annotation特性，支持重构，代码静态检查。</li>
<li>简单，快速，基本没有学习成本。</li>
</ol>


<p>Guice和spring各有所长，Guice更适合与嵌入式或者高性能但项目简单方案，如OSGI容器，spring更适合大型项目组织。</p>

<h2>注入方式</h2>

<p>在我们谈到IOC框架，首先我们的话题将是构造，属性以及函数注入方式，Guice的实现只需要在构造函数，字段，或者注入函数上标注@Inject，如：</p>

<h4>构造注入</h4>

<pre><code>public class OrderServiceImpl implements OrderService {
    private ItemService itemService;
    private PriceService priceService;

    @Inject
    public OrderServiceImpl(ItemService itemService, PriceService priceService) {
        this.itemService = itemService;
        this.priceService = priceService;
    }

    ...
}
</code></pre>

<h4>属性注入</h4>

<pre><code>public class OrderServiceImpl implements OrderService {
    private ItemService itemService;
    private PriceService priceService;

    @Inject
    public void init(ItemService itemService, PriceService priceService) {
        this.itemService = itemService;
        this.priceService = priceService;
    }

    ...
}
</code></pre>

<h4>函数(setter)注入</h4>

<pre><code>public class OrderServiceImpl implements OrderService {
    private ItemService itemService;
    private PriceService priceService;

    @Inject
    public void setItemService(ItemService itemService) {
        this.itemService = itemService;
    }

    @Inject
    public void setPriceService(PriceService priceService) {
        this.priceService = priceService;
    } 

    ...
}
</code></pre>

<h2>Module依赖注册</h2>

<p>Guice提供依赖配置类，需要继承至AbstractModule，实现configure方法。在configure方法中我们可以用Binder配置依赖。</p>

<p>Binder利用链式形成一套独具语义的DSL，如：</p>

<ul>
<li>基本配置：binder.bind(serviceClass).to(implClass).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>无base类、接口配置：binder.bind(implClass).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>service实例配置：binder.bind(serviceClass).toInstance(servieInstance).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>多个实例按名注入：binder.bind(serviceClass).annotatedWith(Names.named(&ldquo;name&rdquo;)).to(implClass).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>运行时注入：利用@Provides标注注入方法，相当于spring的@Bean。</li>
<li>@ImplementedBy：或者在实现接口之上标注@ImplementedBy指定其实现类。这种方式有点反OO设计，抽象不该知道其实现类。</li>
</ul>


<p>对于上面的配置在注入的方式仅仅需要@Inject标注，但对于按名注入需要在参数前边加入@Named标注，如：</p>

<pre><code>public void configure() {
    final Binder binder = binder();

    //TODO: bind named instance;
    binder.bind(NamedService.class).annotatedWith(Names.named("impl1")).to(NamedServiceImpl1.class);
    binder.bind(NamedService.class).annotatedWith(Names.named("impl2")).to(NamedServiceImpl2.class);
}

@Inject
public List&lt;NamedService&gt; getAllItemServices(@Named("impl1") NamedService nameService1,
                                                 @Named("impl2") NamedService nameService2) {
}
</code></pre>

<p>Guice也可以利用@Provides标注注入方法来运行时注入：如</p>

<pre><code>@Provides
public List&lt;NamedService&gt; getAllItemServices(@Named("impl1") NamedService nameService1,
                                             @Named("impl2") NamedService nameService2) {
    final ArrayList&lt;NamedService&gt; list = new ArrayList&lt;NamedService&gt;();
    list.add(nameService1);
    list.add(nameService2);
    return list;
}
</code></pre>

<h2>Guice实例</h2>

<p>下面是一个Guice module的实例代码：包含大部分常用依赖配置方式。更多代码参见<a href="https://github.com/greengerong/guice-demo">github </a>.</p>

<pre><code>package com.github.greengerong.app;

/**
 * ***************************************
 * *
 * Auth: green gerong                     *
 * Date: 2014                             *
 * blog: http://greengerong.github.io/    *
 * github: https://github.com/greengerong *
 * *
 * ****************************************
 */
public class AppModule extends AbstractModule {
    private static final Logger LOGGER = LoggerFactory.getLogger(AppModule.class);
    private final BundleContext bundleContext;

    public AppModule(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
        LOGGER.info(String.format("enter app module with: %s", bundleContext));
    }

    @Override
    public void configure() {
        final Binder binder = binder();
        //TODO: bind interface
        binder.bind(ItemService.class).to(ItemServiceImpl.class).in(SINGLETON);
        binder.bind(OrderService.class).to(OrderServiceImpl.class).in(SINGLETON);
        //TODO: bind self class(without interface or base class)
        binder.bind(PriceService.class).in(Scopes.SINGLETON);


        //TODO: bind instance not class.
        binder.bind(RuntimeService.class).toInstance(new RuntimeService());

        //TODO: bind named instance;
        binder.bind(NamedService.class).annotatedWith(Names.named("impl1")).to(NamedServiceImpl1.class);
        binder.bind(NamedService.class).annotatedWith(Names.named("impl2")).to(NamedServiceImpl2.class);
    }

    @Provides
    public List&lt;NamedService&gt; getAllItemServices(@Named("impl1") NamedService nameService1,
                                                 @Named("impl2") NamedService nameService2) {
        final ArrayList&lt;NamedService&gt; list = new ArrayList&lt;NamedService&gt;();
        list.add(nameService1);
        list.add(nameService2);
        return list;
    }
}
</code></pre>

<h2>Guice的使用</h2>

<p>对于Guice的使用则比较简单，利用利用Guice module初始化Guice创建其injector，如：</p>

<pre><code>Injector injector = Guice.createInjector(new AppModule(bundleContext));
</code></pre>

<p>这里可以传入多个module，我们可以利用module分离领域依赖。</p>

<p>Guice api方法：</p>

<pre><code>public static Injector createInjector(Module... modules) 

public static Injector createInjector(Iterable&lt;? extends Module&gt; modules) 

public static Injector createInjector(Stage stage, Module... modules)

public static Injector createInjector(Stage stage, Iterable&lt;? extends Module&gt; modules) 
</code></pre>

<p>Guice同时也支持不同Region配置，上面的State重载，state支持 TOOL,DEVELOPMENT,PRODUCTION选项;默认为DEVELOPMENT环境。</p>

<h2>后续</h2>

<p>本文Guice更全的demo代码请参见<a href="https://github.com/greengerong/guice-demo">github </a>.</p>

<p>Guice还有很多的扩展如AOP，同一个服务多个实例注入set，map，OSGI，UOW等扩展，请参见<a href="https://github.com/google/guice/wiki">Guice wiki</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/27/guava-eventbus/">Guava - EventBus(事件总线)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-27T21:49:40+08:00" pubdate data-updated="true">Nov 27<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/27/guava-eventbus/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Guava在<a href="http://code.google.com/p/guava-libraries/">guava-libraries</a>中为我们提供了事件总线EventBus库，它是事件发布订阅模式的实现，让我们能在领域驱动设计(DDD)中以事件的弱引用本质对我们的模块和领域边界很好的解耦设计。</p>

<p>不再多的废话，直奔Guava EventBus主题。首先Guava为我们提供了同步事件EventBus和异步实现AsyncEventBus两个事件总线，他们都不是单例的，官方理由是并不想我们我们的使用方式。当然如果我们想其为单例，我们可以很容易封装它，一个单例模式保证只创建一个实例就对了。</p>

<p>下面将以EventBus为例，AsyncEventBus使用方式与其一致的。</p>

<h4>订阅</h4>

<p>首先EventBus为我们提供了register方法来订阅事件，Guava在这里的实现很友好，我们不需要实现任何的额外接口或者base类，只需要在订阅方法上标注上<strong>@Subscribe</strong>和保证<strong>只有一个输入参数</strong>的方法就可以搞定。这样对于简单的某些事件，我们甚至可以直接</p>

<pre><code>new Object() {

    @Subscribe
    public void lister(Integer integer) {
        System.out.printf("%d from int%n", integer);
    }
}
</code></pre>

<p>Guava发布的事件默认不会处理线程安全的，但我们可以标注@AllowConcurrentEvents来保证其线程安全</p>

<h4>发布</h4>

<p>对于事件源，则可以通过post方法发布事件。 正在这里对于Guava对于事件的发布，是依据上例中订阅方法的方法参数类型决定的，换而言之就是post传入的类型和其基类类型可以收到此事件。例如下例：</p>

<pre><code>final EventBus eventBus = new EventBus();
eventBus.register(new Object() {

    @Subscribe
    public void lister(Integer integer) {
        System.out.printf("%s from int%n", integer);
    }

    @Subscribe
    public void lister(Number integer) {
        System.out.printf("%s from Number%n", integer);
    }

    @Subscribe
    public void lister(Long integer) {
        System.out.printf("%s from long%n", integer);
    }
});

eventBus.post(1);
eventBus.post(1L);
</code></pre>

<p>在这里有    Integer，Long，与它们基类Number。我们发送一个整数数据的时候，或者Integer和Number的方法接收，而Long类型则Long类型和Number类型接受。</p>

<p>所以博主建议对于每类时间封装一个特定的事件类型是必要的。</p>

<h4>DeadEvent</h4>

<p>DeadEvent暂时不清楚怎么翻译更合意，它描述的是死亡事件，即没有没任何订阅者关心，没有被处理，以DeadEvent类型参数的方法表示.例如在上例中我们post一个Object类型，如下：</p>

<pre><code>final EventBus eventBus = new EventBus();
eventBus.register(new Object() {

    @Subscribe
    public void lister(DeadEvent event) {
        System.out.printf("%s=%s from dead events%n", event.getSource().getClass(), event.getEvent());
    }
});

eventBus.post(new Object());
</code></pre>

<p>更多Guava博文：</p>

<ol>
<li><a href="http://greengerong.github.io/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava &ndash; 并行编程Futures</a></li>
<li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/">Guava &ndash; EventBus(事件总线)</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava - 并行编程Futures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-21T20:41:30+08:00" pubdate data-updated="true">Nov 21<span>st</span>, 2014</time>
        
           | <a href="/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Guava为Java并行编程Future提供了很多有用扩展，其主要接口为ListenableFuture，并借助于Futures静态扩展。</p>

<p>继承至Future的ListenableFuture，允许我们添加回调函数在线程运算完成时返回值或者方法执行完成立即返回。</p>

<p>对ListenableFuture添加回调函数：</p>

<pre><code>Futures.addCallback(ListenableFuture&lt;V&gt;, FutureCallback&lt;V&gt;, Executor)
</code></pre>

<p>其中 FutureCallback<V>是一个包含onSuccess(V),onFailure(Throwable)的接口。</p>

<p>使用如：</p>

<pre><code>Futures.addCallback(ListenableFuture, new FutureCallback&lt;Object&gt;() {

    public void onSuccess(Object result) {
        System.out.printf("onSuccess with: %s%n", result);
    }

    public void onFailure(Throwable thrown) {
        System.out.printf("onFailure %s%n", thrown.getMessage());
    }
});
</code></pre>

<p>同时Guava中Futures对于Future扩展还有：</p>

<p>transform：对于ListenableFuture的返回值进行转换。</p>

<p>allAsList：对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。注：当其中一个Future失败或者取消的时候，将会进入失败或者取消。</p>

<p>successfulAsList：和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。</p>

<p>immediateFuture/immediateCancelledFuture： 立即返回一个待返回值的ListenableFuture。</p>

<p>makeChecked: 将ListenableFuture 转换成CheckedFuture。CheckedFuture 是一个ListenableFuture ，其中包含了多个版本的get 方法，方法声明抛出检查异常.这样使得创建一个在执行逻辑中可以抛出异常的Future更加容易</p>

<p>JdkFutureAdapters.listenInPoolThread(future): guava同时提供了将JDK Future转换为ListenableFuture的接口函数。</p>

<p>下边是一个对于Future的测试demo：</p>

<pre><code>@Test
public void should_test_furture() throws Exception {
    ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));

    ListenableFuture future1 = service.submit(new Callable&lt;Integer&gt;() {
        public Integer call() throws InterruptedException {
            Thread.sleep(1000);
            System.out.println("call future 1.");
            return 1;
        }
    });

    ListenableFuture future2 = service.submit(new Callable&lt;Integer&gt;() {
        public Integer call() throws InterruptedException {
            Thread.sleep(1000);
            System.out.println("call future 2.");
    //       throw new RuntimeException("----call future 2.");
            return 2;
        }
    });

    final ListenableFuture allFutures = Futures.allAsList(future1, future2);

    final ListenableFuture transform = Futures.transform(allFutures, new AsyncFunction&lt;List&lt;Integer&gt;, Boolean&gt;() {
        @Override
        public ListenableFuture apply(List&lt;Integer&gt; results) throws Exception {
            return Futures.immediateFuture(String.format("success future:%d", results.size()));
        }
    });

    Futures.addCallback(transform, new FutureCallback&lt;Object&gt;() {

        public void onSuccess(Object result) {
            System.out.println(result.getClass());
            System.out.printf("success with: %s%n", result);
        }

        public void onFailure(Throwable thrown) {
            System.out.printf("onFailure%s%n", thrown.getMessage());
        }
    });

    System.out.println(transform.get());
}
</code></pre>

<p>   官方资料主页：<a href="https://awk.so/@code.google.com!/p/guava-libraries/wiki/ListenableFutureExplained">https://awk.so/@code.google.com!/p/guava-libraries/wiki/ListenableFutureExplained</a></p>

<p>更多Guava博文：</p>

<ol>
<li><a href="http://greengerong.github.io/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava &ndash; 并行编程Futures</a></li>
<li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/">Guava &ndash; EventBus(事件总线)</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/">Nightmare基于phantomjs的自动化测试套件</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-20T18:58:15+08:00" pubdate data-updated="true">Nov 20<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天将介绍一款自动化测试套件名叫nightmare，他是一个基于phantomjs的测试框架，一个基于phantomjs之上为测试应用封装的一套high level API。其API以goto, refresh, click, type&hellip;等简单的常用e2e测试动作封装，使得其语义清晰，简洁。其官方在<a href="http://www.nightmarejs.org/">http://www.nightmarejs.org/</a>.</p>

<p>如果你的项目测试不需要想需求和测试人员理解，那么基于nightmare测试或许是一个好的选择，你的降低测试代码的成本，以及测试套件的部署。我们可以选择基于jasmine-node等作为测试套件集成。</p>

<p>安装nightmare：</p>

<pre><code>npm install nightmare
</code></pre>

<p>下面我们对比与远程phantomjs的对比：</p>

<p>原phantomjs的代码：</p>

<pre><code>phantom.create(function (ph) {
  ph.createPage(function (page) {
    page.open('http://yahoo.com', function (status) {
      page.evaluate(function () {
        var el =
          document.querySelector('input[title="Search"]');
        el.value = 'github nightmare';
      }, function (result) {
        page.evaluate(function () {
          var el = document.querySelector('.searchsubmit');
          var event = document.createEvent('MouseEvent');
          event.initEvent('click', true, false);
          el.dispatchEvent(event);
        }, function (result) {
          ph.exit();
        });
      });
    });
  });
});
</code></pre>

<p>nightmare代码：</p>

<pre><code>new Nightmare()
  .goto('http://yahoo.com')
  .type('input[title="Search"]', 'github nightmare')
  .click('.searchsubmit')
  .run();
</code></pre>

<p>一切显而易见，不用多说。</p>

<p>nightmare同时也支持插件方式抽取公用逻辑，以供复用和提高测试代码语意，如下例子：</p>

<pre><code>/**
 * Login to a Swiftly account.
 *
 * @param {String} email
 * @param {String} password
 */

exports.login = function(email, password){
  return function(nightmare) {
    nightmare
      .viewport(800, 1600)
      .goto('https://swiftly.com/login')
        .type('#username', email)
        .type('#password', password)
        .click('.button--primary')
      .wait();
  };
};
</code></pre>

<p>使用代码很简单：</p>

<pre><code>var Swiftly = require('nightmare-swiftly');
new Nightmare()
  .use(Swiftly.login(email, password))
  .use(Swiftly.task(instructions, uploads, path))
  .run();
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/17/typescript-classes/">TypeScript - Classes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-17T19:10:32+08:00" pubdate data-updated="true">Nov 17<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/17/typescript-classes/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/17/typescript-classes/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>简介</h2>

<p>JavaScript语言基于函数和原型链继承机制的方式构建可重用的组件。这对于OO方面编程来说显得比较笨拙。在下一代的JavaScript标准ECMAScript 6为我们提供了基于class base的OO设计方式。在TypeScript中我们也允许使用这种方式，TypeScript将编译为目前大多数浏览器能允许的普通Javascript代码，所以我们不用在等待ECMAScript 6的到来了。</p>

<h2>类</h2>

<p>我们先看一个关于class-base的实例：</p>

<pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

var greeter = new Greeter("world");
</code></pre>

<p>这种语法和我们先前在c#，java语言看见的很相似。在这里我们声明了一个Greeter的类，其中包含一个greeting的属性，构造函数，以及greet的方法。</p>

<p>你也许已经注意到了例子中的‘this’关键字，’this‘和java/C#一样代表对象实例的成员访问。</p>

<p>在最后一行我们利用‘new’关键字创建了一个Greeter的对象实例。这将会新建一个对象实例，并调用我们先前定义的构造函数初始化此对象。</p>

<h2>继承</h2>

<p>在TypeScript中我们可以使用我们常用的OO设计模式。当然对于OO设计最基本的是类型的继承(继承一个存在的类，复用存在的逻辑)，下例就是一个关于类继承的例子：</p>

<pre><code>class Animal {
    name:string;
    constructor(theName: string) { this.name = theName; }
    move(meters: number) {
        alert(this.name + " moved " + meters + "m.");
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move() {
        alert("Slithering...");
        super.move(5);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move() {
        alert("Galloping...");
        super.move(45);
    }
}

var sam = new Snake("Sammy the Python");
var tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
</code></pre>

<p>在这个案例中展示了TypeScript的OO继承方式，它和其他语言很相似。在TypeScript中我们采用‘extends’关键字来表示类的继承关系。在这里你可以看见 &lsquo;Horse&#8217;和&#8217;Snake&#8217;都是继承至&#8217;Animal&#8217;的子类实现。</p>

<p>在案例中也展示如何去重写父类的方法，在这里&#8217;Snake&#8217;和&#8217;Horse都各自创建了一个‘move’方法来重写父类&#8217;Animal&#8217;的‘move’方法，并和‘super’关键字来调用父类的方法。</p>

<h2>Private/Public访问限制</h2>

<h4>Public为默认行为</h4>

<p>你可能注意到了在上例中我们并没有用‘public’关键字去描述类的成员的访问级别让其可见。在C#这类语言中，我们必须显示的标注public关键字才能使得类的成员可见。但是在TypeScript中public为默认访问级别，而不是想c#一样private默认。</p>

<p>有时我们希望封装隐藏类的内部成员控制类成员的可见性，这个时候我们可以使用‘private’这类关键字来标示成员。如我们希望隐藏‘Animal’的name属性：</p>

<pre><code>class Animal {
    private name:string;
    constructor(theName: string) { this.name = theName; }
    move(meters: number) {
        alert(this.name + " moved " + meters + "m.");
    }
}
</code></pre>

<h4>理解private(私有)</h4>

<p>TypeScript有一个结构化的类型(或者鸭子类型)系统。在我们比较两个不同类型，我们不关心它们来自哪里，只关心对类型的每个成员的兼容性。一旦所有的成员都是兼容的，那么我们就认为这两个类型也是兼容的。</p>

<p>当类型检查系统比较两个‘private’成员时，将会认为是不同的对象。对于两个类型比较，当一个类型拥有私有成员的时候，那么另外一个类必须包含相同声明的私有变量(同一处声明，多为继承体现)。如下例：</p>

<pre><code>class Animal {
    private name:stringParameter properties;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name:string;
    constructor(theName: string) { this.name = theName; }   
}

var animal = new Animal("Goat");
var rhino = new Rhino();
var employee = new Employee("Bob");

animal = rhino;
animal = employee; //error: Animal and Employee are not compatible
</code></pre>

<p>在上例中我们有&#8217;Animal&#8217;和‘Rhino’两个类型，&#8217;Rhino&#8217;是‘Animal’的一个子类。同时我们也定义了一个 &lsquo;Employee&#8217;的类，它和‘Animal’类完全相同。我们分别创建了第三个类的对象，并相互赋值，结果&#8217;Animal&#8217;和&#8217;Rhino&#8217;继承关系，所以对于私有字段name在‘Animal’中具有相同的声明  &#8216;private name: string&#8217;，他们是兼容的。但对于&#8217;Employee&#8217;则各自声明了一个私有name字段，对于私有字段是不相同的，所以我们不能将employee赋值给animal对象，他们是不兼容的类型。</p>

<h4>参数属性(Parameter properties)</h4>

<p>访问限制关键字public&#8217;和&#8217;private也可以通过参数属性方式快捷初始化类成员字段，参数属性可以让我们一步创建类成员。下例是上例中我们去掉了‘theName’，利用‘private name: string’声明在构造函数参数上，它会为我们创建一个私有的name成员的同时初始化这个字段。</p>

<pre><code>class Animal {
    constructor(private name: string) { }
    move(meters: number) {
        alert(this.name + " moved " + meters + "m.");
    }
}
</code></pre>

<p>这里我们利用‘private’关键字为类创建了一个私有成员并初始化其值。对于public也类似。</p>

<h2>访问器(Accessors)</h2>

<p>TypeScript支持利用getters/setters来控制对成员的访问。让我们可以控制类的成员之间的访问方式。</p>

<p>下面演示如何转化普通的类为get/set方式，如下是没有get/set的方式：</p>

<pre><code>class Employee {
    fullName: string;
}

var employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>

<p>在这里我们允许任意的访问内部fullName成员。有时这可能不是我们所期望的。</p>

<p>在下边我们希望将其转化为在修改fullName的时候必须提供一个正确的passcode，使得不能任意修改此类name，如下：</p>

<pre><code>var passcode = "secret passcode";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            alert("Error: Unauthorized update of employee!");
        }
    }
}

var employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>

<p>这里我们在修改fullName属性的时候验证了passcode值，是否有权限修改。你可以尝试修改passcode的值，使其不匹配，观察下会发生什么问题？</p>

<p><strong>注意:</strong>访问器使用我们需要设置编译输出为ECMAScript 5。</p>

<h2>静态属性</h2>

<p>回到类主题，上面我们所描述都是关于如何创建类的实例成员。我们同样也可以创建类的静态成员，其可见性为类级访问。我们可以使用&#8217;static&#8217; 关键字标注类级成员。在下面的例子中表格原点对于所有表格都是通用的，所以我们可以用‘static’来定义类级成员。那么可以采用类名(Grid.)来访问访问该成员，类似于对象成员的&#8217;this.&lsquo;.</p>

<pre><code>class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        var xDist = (point.x - Grid.origin.x);
        var yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

var grid1 = new Grid(1.0);  // 1x scale
var grid2 = new Grid(5.0);  // 5x scale

alert(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
alert(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</code></pre>

<h2>高级特性</h2>

<h4>构造函数</h4>

<p>当我们在TypeScript中声明一个类的时候，有时可能会创建多种声明方式。首先类的实例方式：</p>

<pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

var greeter: Greeter;
greeter = new Greeter("world");
alert(greeter.greet());
</code></pre>

<p>这里“var greeter: Greeter”首先声明一个Greeter类的实例变量。这在很多OO语言中是很自然的方式。</p>

<p>同时也利用new关键字实例化了这个类的实例，并调用构造函数初始化该对象。下面我们可以看看同等的JavaScript将会如何去做：</p>

<pre><code>var Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return "Hello, " + this.greeting;
    };
    return Greeter;
})();

var greeter;
greeter = new Greeter("world");
alert(greeter.greet());
</code></pre>

<p>这里&#8217;var Greeter&#8217;被赋值构造函数，并利用‘new’调用了这个方法得到类的实例。同样我们的类也可以包含静态变量。我们可以这么认为所有的类都可以拥有实例和静态两种类型的成员。</p>

<p>让我们对上例稍微做一些修改：</p>

<pre><code>class Greeter {
    static standardGreeting = "Hello, there";
    greeting: string;
    greet() {
        if (this.greeting) {
            return "Hello, " + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

var greeter1: Greeter;
greeter1 = new Greeter();
alert(greeter1.greet());

var greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = "Hey there!";
var greeter2:Greeter = new greeterMaker();
alert(greeter2.greet());
</code></pre>

<p>这里‘greeter1’和上例工作很相似。我们初始化了‘Greeter’类，并调用此对象。其结果在上例已经看见。</p>

<p>接着，我们直接使用了类访问。首先我们定义了一个新的‘greeterMaker’的变量，这变量保持了Greeter类的类型信息，这里我们使用的是‘typeof Greeter’，这会返回Greeter自身的类类型信息。这个类型信息中会包含所以的静态成员信息和实例化对象的构造函数信息。然后通过‘new’ greeterMaker来创建一个Greeter的实例对象，在调用其方法greet。</p>

<h2>利用interface来使用class</h2>

<p>如上所述，类主要声明了类实例类型和构造函数两件事。因为类主要创建类型，所以我们可以在同一地方使用interface来替代它：</p>

<pre><code>class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

var point3d: Point3d = {x: 1, y: 2, z: 3};
</code></pre>

<p><strong>注意:</strong>TypeScript更准确说是为了类型检查的类型推断。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/13/typescript-interfaces/">TypeScript - Interfaces</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-13T21:49:25+08:00" pubdate data-updated="true">Nov 13<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/13/typescript-interfaces/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/13/typescript-interfaces/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>简介</h4>

<p>关注于数据值的 &lsquo;shape&#8217;的类型检查是TypeScript核心设计原则。这种模式有时被称为‘鸭子类型’或者‘结构子类型化’。 在TypeScript中接口interfaces的责任就是命名这些类型，而且还是你的代码之间或者是与外部项目代码的契约。</p>

<h2>初见Interface</h2>

<p>理解interface的最好办法，就是写个hello world程序：</p>

<pre><code>function printLabel(labelledObj: {label: string}) {
  console.log(labelledObj.label);
}

var myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
</code></pre>

<p>在这里类型检查系统会检查printLabel这个函数，printLabel函数要求传入一个包含一个label的字符串属性。上例可以了解我们传入的对象可以有多个属性，但是类型检查系统只会检查printLabel所要求的label属性是否满足其要求。</p>

<p>接下来我们可以进一步简化，声明一个interface来描述一个具有label字符串属性的对象：</p>

<pre><code>interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

var myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
</code></pre>

<p>接口LabelledValue描述了上例中printLabel的所要求的类型对象。它依然代表包含一个label的字符串属性。可以看见我们利用‘shape’(行)描述了printLabel的传入参数要求。</p>

<h2>可选的Properties</h2>

<p>有时不是所有定义在interface中的属性都是必须的。例如流行的&#8221;option bags&#8221;模式(option配置)，使用者可以之传入部分定制化属性。如下面“option bags”模式：</p>

<p>interface SquareConfig {
  color?: string;
  width?: number;
}</p>

<pre><code>function createSquare(config: SquareConfig): {color: string; area: number} {
  var newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

var mySquare = createSquare({color: "black"});
</code></pre>

<p>带有可选属性的interface定义和c#语言很相似，以&#8217;?&lsquo;紧跟类型后边表示。</p>

<p>interface的可选属性可以限制那些属性是可用的，这部分能得到类型检查，以及智能感知。例如下例：</p>

<pre><code>interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  var newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.collor;  // 类型检查系统能识别不正确的属性collor.
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

var mySquare = createSquare({color: "black"});  
</code></pre>

<h2>函数类型</h2>

<p>Interfaces为了描述对象能接收的数据形(shapes)的返回。对于interface不仅难呢过描述对象的属性，也能描述函数类型。</p>

<p>下面是定义的interface signature是一个接收两个string的输入参数，并返回boolean的函数类型：</p>

<pre><code>interface SearchFunc {
  (source: string, subString: string): boolean;
}
</code></pre>

<p>我也可以使用函数类型的interface去描述我们的数据。下面演示如何将一个相同类型的函数赋值给interface：</p>

<pre><code>var mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  var result = source.search(subString);
  if (result == -1) {
    return false;
  }
  else {
    return true;
  }
}
</code></pre>

<p>对于函数类型的interface，并不需要参数名的对应相同，如下例：</p>

<pre><code>var mySearch: SearchFunc;
mySearch = function(src: string, sub: string) {
  var result = src.search(sub);
  if (result == -1) {
    return false;
  }
  else {
    return true;
  }
}
</code></pre>

<p>对于函数参数的检查，会按照参数的顺序检查对应的类型是否匹配。同时也会检查函数的返回类型是否匹配，在这个函数我们期望返回boolean类型true/false， 如果返回的是numbers或者string，则类型检查系统会提示返回值类型不匹配。</p>

<h2>数组类型</h2>

<p>类似于函数类型，TypeScript也可以描述数组类型。在数组类型中有一个&#8217;index&#8217;类型其描述数组下标的类型，以及返回值类型描述每项的类型，如下：</p>

<pre><code>interface StringArray {
  [index: number]: string;
}

var myArray: StringArray;
myArray = ["Bob", "Fred"]
</code></pre>

<p>index的支持两种类型，分别是字符串和数值类型. 我们可以限制index的类型，同时也可以检查index项的返回值类型。</p>

<p>index的类型签名可以描述常用的数组或者是‘dictionary’（字典序）模式，这点会强制所有的属性都需要和其返回值匹配。下例中length属性不匹配这点，所以类型检查会给出一个错误：</p>

<pre><code>interface Dictionary {
  [index: string]: string;
  length: number;    // error, the type of 'length' is not a subtype of the indexer
} 
</code></pre>

<h2>Class类型</h2>

<h4>实现interface</h4>

<p>在C#和java中interface是很常使用的类型系统，其用来强制其实现类符合其契约。在TypeScript中同样也可以实现：</p>

<pre><code>interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>

<p>同样也可以在interface中实现函数类型的契约，并要求clas实现此函数。如下例的‘setTime’函数：</p>

<pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface  {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre>

<p>interface描述的的是class的公开(public)部分，而不是私有部分.</p>

<h4>类static/instance区别</h4>

<p>当使用类和接口的时候，我们需要知道类有两种类型：static(静态)部分和instance(实例)部分。如果尝试一个类去实现一个带有构造签名的interface，TypeScript类型检查会提示你错误。</p>

<pre><code>interface ClockInterface {
    new (hour: number, minute: number);
}

class Clock implements ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>

<p>这是因为一个类去实现接口的时候，只有instance(实例)的部分才会被检查。而构造函数属于静态部分，所以不会被类型检查。</p>

<p>相反你可以直接在类中实现这些(static)静态部分，如下例：</p>

<pre><code>interface ClockStatic {
    new (hour: number, minute: number);
}

class Clock  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}

var cs: ClockStatic = Clock;
var newClock = new cs(7, 30);
</code></pre>

<h4>interface的继承</h4>

<p>和类一样，接口也能集成其他的接口。这相当于复制接口的所有成员。接口的集成是的我们可以自由的抽象和分离到可重用的组件。</p>

<pre><code>interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

var square = &lt;Square&gt;{};
square.color = "blue";
square.sideLength = 10;
</code></pre>

<p>一个interface可以同时集成多个interface，实现多个接口成员的合并。</p>

<pre><code>interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

var square = &lt;Square&gt;{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>

<h2>混合式类型</h2>

<p>如前边提到的一样，在interface几乎可以描述JavaScript世界的一切对象。因为JavaScript是一个动态，灵活的脚本语言，所以偶尔也希望一个对象能够描述一些多个类型.</p>

<p>下面是一个混合式描述函数，对象以及额外属性的实例：</p>

<pre><code>interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

var c: Counter;
c(10);
c.reset();
c.interval = 5.0;
</code></pre>

<p>和第三方JavaScript库交互的时候，也许我们也会上面的模式来描述一个完整的类型。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/13/typescript-basic-types/">TypeScript - 基本类型系统</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-13T19:53:50+08:00" pubdate data-updated="true">Nov 13<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/13/typescript-basic-types/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/13/typescript-basic-types/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>对于程序来说我们需要基本的数据单元,如：numbers, strings, structures, boolean 等数据结构。在TypeScript中我们支持很多你所期望在JavaScript中所拥有的数据类型系统。</p>

<h4>Boolean</h4>

<p>在JavaScript和TypeScript中也具有最基本的逻辑断言值true/false，采用&#8217;boolean&#8217;类型。</p>

<pre><code>var isDone: boolean = false;
</code></pre>

<h4>Number</h4>

<p>如JavaScript，TypeScript所有的数值类型采用浮点型计数，其类型为‘number’。</p>

<pre><code>var height: number = 6;
</code></pre>

<h4>String</h4>

<p>在webpages的JavaScript或者服务端的应用程序最基本的功能就是处理文本数据。在其他语言中大多使用&#8217;string&#8217;去代表文本数据类型。TypeScript和JavaScript一样也是用双引号(&ldquo;)或者单引号包裹文本数据。</p>

<pre><code>var name: string = "bob";
    name = 'smith';
</code></pre>

<h4>Array</h4>

<p>在TypeScript中如JavaScript一样允许我们操结合操作。数组类型可以使用下边两种方式之一。</p>

<p>第一种方式，你可以在数据类型之后带上&#8217;[]&lsquo;:</p>

<pre><code>var list:number[] = [1, 2, 3];
</code></pre>

<p>第二种方式，也可以采用泛型的数组类型：</p>

<pre><code>var list:Array&lt;number&gt; = [1, 2, 3];
</code></pre>

<h4>Enum</h4>

<p>TypeScript为JavaScript新增了枚举这种标准的集合数据类型。和在c#中一样，枚举是为一组数值类型一组更友好的名称。</p>

<pre><code>enum Color {Red, Green, Blue};
var c: Color = Color.Green;
</code></pre>

<p>默认枚举类型其实数值从0开始，你可以可用手动设置某一个成员的数值。例如我们可以将上文的起始值定为1：</p>

<pre><code>enum Color {Red = 1, Green, Blue};
var c: Color = Color.Green;
</code></pre>

<p>或是手动设置全部的枚举成员：</p>

<pre><code>enum Color {Red = 1, Green = 2, Blue = 4};
var c: Color = Color.Green;
</code></pre>

<p>枚举类型可以和容易从一个数值类型获取对应枚举名称。例如我们有一个数值类型2，但不确认将匹配哪一个枚举成员，那么我们可以如下使用：</p>

<pre><code>enum Color {Red = 1, Green, Blue};
var colorName: string = Color[2];

alert(colorName);
</code></pre>

<h4>Any</h4>

<p>有时我们需要描述一些我们不知道的什么写进应用的动态数据类型，这可能来自第三方用户或者lib。在这里我们希望该数据不要加入TypeScript的类型检查,是的此值通过编译时检查。为此我们可以采用‘any’类型标注：</p>

<pre><code>var notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
</code></pre>

<p>‘any’类型是一种强大的兼容存在的JavaScript库的类型系统。他允许跳过TypeScript的编译时类型的检查。</p>

<p>&lsquo;any&#8217;类型对于我们只知道部分数据类型，但是不是所有的数据类型的类型系统。如一个混合了多种类型的集合数组。</p>

<pre><code>var list:any[] = [1, true, "free"];

list[1] = 100;
</code></pre>

<h4>Void</h4>

<p>和‘any’相对的数据类型则是’Void‘，它代表没有任何数据类型。我们常用的一个方法没有任何返回值：</p>

<pre><code>function warnUser(): void {
    alert("This is my warning message");
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/12/vsftpd-refusing-to-run-with-writable-root-inside-chroot/">Vsftpd Refusing to Run With Writable Root Inside Chroot</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-12T19:38:05+08:00" pubdate data-updated="true">Nov 12<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/12/vsftpd-refusing-to-run-with-writable-root-inside-chroot/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/12/vsftpd-refusing-to-run-with-writable-root-inside-chroot/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="images/blog_img/vsftpd.jpg" alt="vsftpd" /></p>

<p>今天记录一个在安装vsftpd的时候遇见错误：</p>

<pre><code>500 OOPS: vsftpd: refusing to run with writable root inside chroot ()
</code></pre>

<p>在一阵的外文查找，最后定为到是因为用户的根目录可写，并且使用了chroot限制，而这在最近的更新里是不被允许的。要修复这个错误，可以用命令chmod a-w /home/$user去除用户根目录的写权限,或者在vsftpd。conf配置允许writeable。</p>

<p>设置允许writeable为：</p>

<pre><code>allow_writeable_chroot=YES
</code></pre>

<p>最简单的方式就是允许writeable。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/12/mockito-custom-verify-matcher/">Mockito自定义verify参数Matcher</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-12T13:53:13+08:00" pubdate data-updated="true">Nov 12<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/12/mockito-custom-verify-matcher/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/12/mockito-custom-verify-matcher/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在TDD开发中，也许我们会遇见对一些重要的无返回值的行为测试，比如在用户的积分DB中增加用户的积分，这个行为对于我们的业务具有重要的价值，所以我们也希望能测试覆盖这部分业务价值。这个时候我们就得使用mockito带来的verify断言，但verify的参数断言主要有eq，或者any常见的方式。有时我们也希望能够断言对象的一部分属性，比如上文的积分数值，对于不同的场景增加的用户积分可能不同。</p>

<p>回到Mockito的参数Matcher，Mockito给我们提供了ArgumentMatcher，以供我们来扩展Matcher。下面假设一个增加用户积分的场景：</p>

<pre><code>     public class Game {
        private String type;
        private int rate;

        public Game(String type, int rate) {
            this.type = type;
            this.rate = rate;
        }

        public String getType() {
            return type;
        }

        public int getRate() {
            return rate;
        }

    }

    public class GameDao {
        public void addRate(Game game) {
            //TODO: insert to db
        }
    }
</code></pre>

<p>我们希望能够对verify GameDao调用了addRate，并且是积分rate为特定值。</p>

<p>所以我们可以扩展Mockito的ArgumentMatcher：</p>

<pre><code>public class PartyMatcher&lt;T&gt; extends ArgumentMatcher&lt;T&gt; {
    private Object value;
    private Function&lt;T, Object&gt; function;

    public PartyMatcher(Function&lt;T, Object&gt; getProperty, Object value) {
        this.value = value;
        this.function = getProperty;
    }

    public static &lt;F&gt; PartyMatcher&lt;F&gt; partyMatcher(Function&lt;F, Object&gt; getProperty, Object value) {
        return new PartyMatcher&lt;F&gt;(getProperty, value);
    }

    @Override
    public boolean matches(Object o) {
        return function.apply((T) o).equals(value);
    }
}
</code></pre>

<p>所以我们的测试可以如下：</p>

<pre><code>    @Test
    public void should_run_customer_mockito_matcher() throws Exception {

        final GameDao gameDao = mock(GameDao.class);
        gameDao.addRate(new Game("签到", 7));

        verify(gameDao).addRate(argThat(new PartyMatcher&lt;Game&gt;(new Function&lt;Game, Object&gt;() {
            @Override
            public Object apply(Game game) {
                return game.getRate();
            }
        }, 7)));

        verify(gameDao).addRate(argThat(new PartyMatcher&lt;Game&gt;(new Function&lt;Game, Object&gt;() {
            @Override
            public Object apply(Game game) {
                return game.getType();
            }
        }, "签到")));
    }
</code></pre>

<p>Mockito给我们提供了很多关于Matcher扩展的方法，本文只是ArgumentMatcher的实例。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/07/jian-jie-gulp-grunt-bower-npm-vs/">简介Gulp, Grunt, Bower, 和 Npm 对Visual Studio的支持</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-07T12:18:24+08:00" pubdate data-updated="true">Oct 7<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/10/07/jian-jie-gulp-grunt-bower-npm-vs/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/10/07/jian-jie-gulp-grunt-bower-npm-vs/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p> [原文发表地址]<a href="http://www.hanselman.com/blog/IntroducingGulpGruntBowerAndNpmSupportForVisualStudio.aspx">Introducing Gulp, Grunt, Bower, and npm support for Visual Studio</a></p>

<p>Web 开发，特别是前端 Web 开发，正迅速变得像传统的后端开发一样复杂和精密。<strong>大多数项目不仅仅是通过</strong> FTP上传一些 JS 和 CSS 文件。而现在的<strong>前端生成过程，</strong>可以囊括SASS 和LESS扩展、CSS/JS的压缩包、JSHint 或 JSLint的运行时 、或者更多。这些生成任务和进程都和像Gulp和Grunt这样的工具一起协调工作。此外，类似于npm和bower这样的管理系统将客户端库作为软件包来管理。</p>

<h5>ASP.NET客户端软件包的管理者，为什么不用 NuGet？或MSBuild？</h5>

<p>你们中的一些人可能会问，为什么JavaScript不使用 NuGet？为什么不扩展 MSBuild 去构建 CSS/JS？原因很简单。因为已经有了丰富的系统，来做这种事情。对于服务器端库 （和一些客户端）来说，使用NuGet 就已经很棒了。npm和bower 上已经有了很多的，而且还会有更多的 CSS 和 JS 库。而对于服务器端的应用程序构建来说，使用MSBuild很棒，但当构建客户端应用程序时，它有些多余了。</p>

<p>所以，两者都可以使用。这些都是您工具包中的工具。添加Gulp，Grun，Bower，npm的支持（和将来需要其他东西） ，这意味着为ASP.NET前端开发者提供了一个更熟悉的环境。它允许 ASP.NET 开发人员引入 JS 和 CSS 库，使他们可以每天使用。</p>

<h5>引入任务资源管理器</h5>

<p>我们从你们中，以及整个社会收到了相当多的、关于Grunt/Gulp的功能请求。我们利用Visual Studio “14的充分可扩展性正在构建对Grunt/Gulp第一流的支持。现在我们已经准备好将这个支持作为VS2013的一个扩展加入到预览版本中， 并且我们感激您帮助我们测试和考察这个功能。</p>

<p>今天我们介绍一个预览版本，在这个预览版本中，“<a href="http://visualstudiogallery.msdn.microsoft.com/8e1b4368-4afb-467a-bc13-9650572db708">任务资源管理器</a>”将作为VSIX<strong>的一个扩展。</strong><strong>同时也推荐两个其他的</strong><strong>VSIX</strong><strong>来完善对这个功能的体验。</strong></p>

<p><strong>注意：</strong><strong> </strong><strong>VSIX</strong><strong>扩展中的大多数功能都被内置到</strong><strong>Visual Studio</strong><strong>中，因此你不需要安装其他别的东西。而且，</strong><strong>在</strong><strong>VS2013</strong><strong>和此预览版本中我们需要更多的</strong><strong>VSIX</strong><strong>，让你迟早能得到这些扩展。</strong><strong> </strong><strong>请注意，今天任务资源管理器只工作于</strong><strong>Vsiaual Studio Express </strong><strong>版本中，但</strong><strong>VS14</strong><strong>的所有功能都将出现在</strong><strong>VS</strong><strong>免费版本中。</strong></p>

<p>类似于VS Productivity Power Tools一样， “DevLabs”这样的功能现在还在预览版中。但是他们终将会集成到最终的产品中。</p>

<h5>你需要什么？</h5>

<h5>首先，你将需要<a href="http://www.microsoft.com/en-us/download/details.aspx?id=43721">Visual Studio 2013.3</a> ，3的意思是免费的更新&#8221;Update 3&#8221;。</h5>

<ol>
<li><a href="http://www.microsofttranslator.com/bv.aspx?from=en&amp;amp;to=zh-CHS&amp;amp;a=http%3A%2F%2Fvisualstudiogallery.msdn.microsoft.com%2F8e1b4368-4afb-467a-bc13-9650572db708"><strong>TRX-</strong><strong>任务资源管理器</strong></a><strong> </strong>Visual Studio 扩展</li>
<li><a href="http://www.microsofttranslator.com/bv.aspx?from=en&amp;amp;to=zh-CHS&amp;amp;a=http%3A%2F%2Fvisualstudiogallery.msdn.microsoft.com%2F65748cdb-4087-497e-a394-2e3449c8e61e">NMP/NBower包智能感知</a>-搜索NPM 和Bower包在线版，它直接附加智能感知功能。</li>
<li><p>可选的<a href="http://visualstudiogallery.msdn.microsoft.com/dcbc5325-79ef-4b72-960e-0a51ee33a0ff">Grunt Launcher</a>（在解决方案资源管理器上右键单击选项— — 你会看到&#8221; npm install &ldquo;）</p>

<ul>
<li>如果你现在没有这种扩展，那么你将需要自己运行npm install来还原/添加软件包</li>
<li>如果你有这种扩展，那么请在运行grunt/gulp之前，右键单击 packages.json 和&#8221;npm install&#8221;</li>
</ul>
</li>
</ol>


<p>要打开 TRX （任务资源管理器），只需用鼠标右键单击您的项目中任何一个 gruntfile.js文件：</p>

<p><img src="http://www.hanselman.com/blog/content/binary/Windows-Live-Writer/Introducing-Gulp-Grunt_E733/image002_60531aad-06cb-4ce7-83ea-5629fa7e8b8d.png" alt="" /></p>

<p>默认情况下，TRX 位于VS的底部，，看起来像这样：</p>

<p><img src="http://www.hanselman.com/blog/content/binary/Windows-Live-Writer/Introducing-Gulp-Grunt_E733/image001_8eae3676-2331-461b-bfe6-fec463c7f49c.png" alt="" /></p>

<p>在这里，我们看到 gruntfile.js 在该解决方案中的一个或多个项目的根目录中。它还有<strong>任务绑定功能，也就是说任何任务或目标可以由</strong><strong> 4 </strong><strong>个</strong><strong>不同</strong><strong> Visual Studio </strong><strong>事件触发。</strong></p>

<p>要想将一个任务/目标和一个VS事件绑定在一起，只需右键单击进行绑定设置。</p>

<p><img src="http://www.hanselman.com/blog/content/binary/Windows-Live-Writer/Introducing-Gulp-Grunt_E733/image003_9d3aeb6c-f450-4e68-8d4c-010b619f7da8.png" alt="" /></p>

<p>要想运行任何一个任务/目标，只需双击它，然后控制台将显示如下：</p>

<p><img src="http://www.hanselman.com/blog/content/binary/Windows-Live-Writer/Introducing-Gulp-Grunt_E733/image004_1db90c39-a4cd-42a7-81df-b3ec2493e8c0.png" alt="" /></p>

<p>当你有了软件包智能感知扩展功能时，你会发现通过bower 和 npm来直接编辑package.json很容易添加并更新软件包。</p>

<p>甚至，你也有了异步填充元数据工具提示功能。</p>

<p><img src="http://www.hanselman.com/blog/content/binary/Windows-Live-Writer/Introducing-Gulp-Grunt_E733/tooltip-animated_thumb.gif" alt="" /></p>

<p>现在你可以去测试它了，记住在你用任务资源管理器来运行Grunt任务之前，你需要运行“ npm install” 。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>破 狼</h1>
  <p>    那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息。 那一月，我转过所有经轮，不为超度，只为触摸你的指纹。 那一年，我磕长头拥抱尘埃，不为朝佛，只为贴着了你的温暖。 那一世，我翻遍十万大山，不为修来世，只为路中能与你相遇。 那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。<a href="http://greengerong.github.io/blog/2009/12/24/cang-yang-jia-cuo-na-yi-tian-na-yi-yue-na-yi-nian-na-yi-shi/">《那一天，那一月，那一年，那一世》&#8211;仓央嘉措。</a></p>
</section>
<section>
  <p style="align: center"><a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3158890&amp;c=9476983" alt="count web site visits"/></a></p>
</section>
<section>
<h1>博客友情链接</h1>
  <ul>
    <li><a href="http://www.cnblogs.com/whitewolf/">博客园-破狼</a></li>
    <li><a href="http://whitewolfblog.blog.51cto.com/">51CTO&#8211;破狼</a></li>
    <li><a href="http://www.davenkin.me/">无知者云</a></li>
    <li><a href="http://agiledon.github.io/">简单文本</a></li>
  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/10/light-ioc-guice-framework/">java轻量级IOC框架Guice</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/27/guava-eventbus/">Guava - EventBus(事件总线)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava - 并行编程Futures</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/">Nightmare基于phantomjs的自动化测试套件</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/17/typescript-classes/">TypeScript - Classes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/typescript-interfaces/">TypeScript - Interfaces</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/typescript-basic-types/">TypeScript - 基本类型系统</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/12/vsftpd-refusing-to-run-with-writable-root-inside-chroot/">Vsftpd Refusing to Run With Writable Root Inside Chroot</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/greengerong">@greengerong</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'greengerong',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 破 狼 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'greengerong';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
