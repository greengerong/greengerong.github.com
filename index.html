
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>破狼 Blog</title>
  <meta name="author" content="破 狼">

  
  <meta name="description" content="2014年我一直从事在企业敏捷实践咨询项目，这也是我颇有收获的一年，特别是咨询项目的每一点改变，不管是代码质量的提高，还是自组织团队的建设，每一点的改变都能让我感到很大的欣慰。涉及人的问题都是复杂问题，改变人，改变一个组织是个更复杂问题，这里可能涉及很多的非技术，非能力问题， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://greengerong.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="破狼 Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">破狼 Blog</a></h1>
  
    <h2>Write less got more.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:greengerong.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/05/tddsui-xiang-lu/">TDD随想录</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-05T21:58:10+08:00" pubdate data-updated="true">Jan 5<span>th</span>, 2015</time>
        
           | <a href="/blog/2015/01/05/tddsui-xiang-lu/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2015/01/05/tddsui-xiang-lu/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>2014年我一直从事在企业敏捷实践咨询项目，这也是我颇有收获的一年，特别是咨询项目的每一点改变，不管是代码质量的提高，还是自组织团队的建设，每一点的改变都能让我感到很大的欣慰。涉及人的问题都是复杂问题，改变人，改变一个组织是个更复杂问题，这里可能涉及很多的非技术，非能力问题，所以每一点改变都会让你感到欣慰。</p>

<p>在2014年12月我在某企业内部推行TDD(测试驱动开发)培训，一共分4个课时完成一个特定需求的例子，看着大家一步一步的加深对TDD的理解，直到2014-12-31号，也是2014的最后一天下午培训完TDD课程，经过一系列的总结过后，某参与人员说道：“单元测试需要写更多的代码，但是从项目的总体来看，一个字‘值’.”。算是2014年的一个完美结束吧，倍感欣慰。不知来的更大的欣慰也将到来，后来某参与人员发了一份其关于TDD培训感受，名叫《TDD随想录》也将是本文的主题，本文或许更好的说是转载此文，了解一个开发人员对TDD了解的心路历程，以及对TDD的看法。</p>

<p>注：原文发布与hxfirefox的<a href="https://github.com/hxfirefox/blog/blob/master/TDD/TDD%E9%9A%8F%E6%83%B3%E5%BD%95.md">https://github.com/hxfirefox/blog/blob/master/TDD/TDD%E9%9A%8F%E6%83%B3%E5%BD%95.md</a>.</p>

<p>原文如下：</p>

<h2>TDD随想录</h2>

<p>谨以本文献给TDD的开创者与传播者</p>

<p>本文纯属个人经历，如有雷同纯属巧合</p>

<p>我从不觉得自己是一个好的程序员，甚至可能连合格都谈不上，不过在内心深处我却渴望着在编程这件事上获得成功。</p>

<p>可惜每次审视自己写的暂且称之为代码的东西，都会有挫折感，想重构却又感觉盘根错节，难以下手;想重写却又感觉自己好不容易写出来的，也花了不少心思，就这样丢弃心有不甘。</p>

<p>也曾思考过如何才能写好代码，有段时间觉得只有严格符合编程规范的代码才是好代码进而如同遵守戒律一样地字字斟酌，还有段时间觉得只有用上设计模式才能称之优秀代码进而非模式不用，一切套用模式。不过这些都没有让我走出开发的迷雾，永远是加不完的班，修不完的bug。</p>

<p>究竟是否有一种方法能够让我拨开开发迷雾，至少能够让我能够轻松地修剪代码，降低bug发生率，那么我觉得这种方法在我身上就是成功的。</p>

<p>初次接触到TDD是通过公司内部的“代码大全培训”，犹如十月革命中阿芙勒尔号的一声炮响，为我打开了软件开发的视野。先测试后开发，小步迭代，持续集成，这些新名词突然涌进了我的大脑，既新鲜又晦涩。犹如人的幼年容易犯幼稚病一样，初识这些新名词就以为了解了TDD的一切，结果却发现在实践过程中处处碰壁，举步维艰。对TDD中每个环节真正隐含的开发思想的囫囵吞枣，让这一次的培训只在我脑中留下TDD的一个模糊身影:为软件开发结下一张安全网。</p>

<p>虽然未领悟精髓，但培训后体验和直觉告诉我TDD是一条通往我向往的软件成功的道路，尽管自己摸索前行比较坎坷。很幸运的是团队获得了随队敏捷教练的支持，结对让我系统地了解到了TDD的思想。</p>

<p><strong>测试先行</strong>，其实讲的是需求边界，测试不是漫无目的而是精确计算成本的一项活动。测试从何而来，从需求来，需求推演出测试，也规划出产品边界，不能反映需求的测试是一种浪费，因此引申出开发需要讲求适当。开发是一项功利性的活动，永远都在追求盈利，而测试就一条红线，一旦跨过就意味着亏损。</p>

<p><strong>小步迭代</strong>，“让子弹飞”中有句话很经典:步子要一步一步迈，一步迈大了，咔，容易扯着蛋。代码堆叠的后遗症是复杂，复杂到没人愿意触碰，且不停地咒骂这代码有多烂，这是步子迈太大的真实写照。TDD讲求的小步迭代是写完一个测试再去写完一个实现，每个实现都是通过测试的，如此累加小胜为大胜，最后所有代码的收尾也不过是让最后一个测试通过而已，就是这样简单。</p>

<p><strong>重构</strong>，这是我最喜欢的部分，为啥？因为这里面所有的活动都会要求你去思考，且看上去都像是让你的代码向着大师级代码前进。漂亮的代码并不是堆砌各种技巧，而是在正确的时间，正确的地点做正确的事，重构很容易实现这个目标。重构是一件让人一旦开始就会欲罢不能的事，会让开发者在整个开发阶段都能够不停地去思考、实践再思考，直到无法再添加或删除一个字母。</p>

<p><strong>持续集成</strong>，你终究是需要交付产品的，产品就是客户需要的价值，就如同厨师终究会端出客人点的大餐一样，没有哪个厨师是把所有食材罗列着呈现给你的，而是混合在一起，蒸煮炖烧，有些食材需要先处理，这样吃起来才软硬适中，而有些则是最后下锅，这样吃起来才鲜嫩多汁，厨师就是这样一步步将食材集成起来，每一步的处理都是可用都是有价值的，都是为后续进行的铺垫。软件开发也一样，持续集成就要保证每一次的完成都是有价值都可以为后续提供支撑。</p>

<p>写到这里也许会有人问你如何知道TDD是真理，是康庄大道，它一定适合每个人吗？不，我并不知道，我所写的一切只是发生在我身上的一段经历。这段经历告诉我TDD迫使我去更多的思考，去切割我那些冗长且复杂又不切实际的胡思乱想，把它们碾碎成一个个小片段，提炼，过滤，不断累加，最终变成最接近交代价值的东西，而这最终的东西正是我一直在追求的那个成就感。如果想要知道TDD是不是适合自己，最好的办法就是去尝试，去亲身体验一下，无论好坏也许你能获得比我更多的体会。</p>

<h2>博主总结</h2>

<p>TDD并不是万能的，但是TDD也不是一无是处的，总要的是用方法论的人，引入某同事一句话：</p>

<pre><code>站在教学的角度来讲，我还是很推崇TDD的，TDD是一个很好的思维框架，如果非要教人一个思维框架的话就得教TDD，
不然人会瞎碰，不思考，不总结，不结果导向，靠灵感编程，凭直觉设计，撞大运修bug。最糟糕的是因为没有好的习惯
会接二连三的发生灵异现象。同一道题，习惯不好的人做，总能做出无数种新问题来。而且问题套问题，给他解决要浪费
我半天时间，如果他学会了TDD出的错只在最近一个引入的变化里，就好纠正多了。甚至他自己都能纠正。
</code></pre>

<p>博主很是赞同该同事的看法，并且作者认为：</p>

<pre><code>tdd重要的不是测试代码本身，是解决问题的思维，也许可以泛化，哪怕没测试，如果能够做到快速验证，反馈，价值的
稳定叠加，有足够信心，也未尝不可。也许你会说测试可以cover功能，那么如果只有这一点的话，我更喜欢BDD
(behavior-driven development)，因为这具有用户最终的使用价值。如果你说快速定位bug，我们我更倾向于BDD
(bug-driven development，自创的)。这写都是TDD的结果导致的好处所在，而价值反馈思维才是实现TDD背后原理。
TDD驱使我们以结果导向，使得我们简单设计(并不是无设计)，日常重构我们的代码库，注重交付价值流稳定叠加。
</code></pre>

<p>如果你对TDD还有兴趣，你可以对比本文新人的《TDD随想录》和某大牛的《<a href="http://coolshell.cn/articles/3649.html">TDD并不是看上去的那么美</a>》，世上并没有放之四海皆准的法则，TDD好坏在于你的判断，本文并不会给你一个完美的答案，这需要你自己的发掘。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/10/light-ioc-guice-framework/">java轻量级IOC框架Guice</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-10T21:50:37+08:00" pubdate data-updated="true">Dec 10<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/12/10/light-ioc-guice-framework/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/12/10/light-ioc-guice-framework/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Guice是由Google大牛Bob lee开发的一款绝对轻量级的java IoC容器。其优势在于：</p>

<ol>
<li>速度快，号称比spring快100倍。</li>
<li>无外部配置(如需要使用外部可以可以选用Guice的扩展包)，完全基于annotation特性，支持重构，代码静态检查。</li>
<li>简单，快速，基本没有学习成本。</li>
</ol>


<p>Guice和spring各有所长，Guice更适合与嵌入式或者高性能但项目简单方案，如OSGI容器，spring更适合大型项目组织。</p>

<h2>注入方式</h2>

<p>在我们谈到IOC框架，首先我们的话题将是构造，属性以及函数注入方式，Guice的实现只需要在构造函数，字段，或者注入函数上标注@Inject，如：</p>

<h4>构造注入</h4>

<pre><code>public class OrderServiceImpl implements OrderService {
    private ItemService itemService;
    private PriceService priceService;

    @Inject
    public OrderServiceImpl(ItemService itemService, PriceService priceService) {
        this.itemService = itemService;
        this.priceService = priceService;
    }

    ...
}
</code></pre>

<h4>属性注入</h4>

<pre><code>public class OrderServiceImpl implements OrderService {
    private ItemService itemService;
    private PriceService priceService;

    @Inject
    public void init(ItemService itemService, PriceService priceService) {
        this.itemService = itemService;
        this.priceService = priceService;
    }

    ...
}
</code></pre>

<h4>函数(setter)注入</h4>

<pre><code>public class OrderServiceImpl implements OrderService {
    private ItemService itemService;
    private PriceService priceService;

    @Inject
    public void setItemService(ItemService itemService) {
        this.itemService = itemService;
    }

    @Inject
    public void setPriceService(PriceService priceService) {
        this.priceService = priceService;
    } 

    ...
}
</code></pre>

<h2>Module依赖注册</h2>

<p>Guice提供依赖配置类，需要继承至AbstractModule，实现configure方法。在configure方法中我们可以用Binder配置依赖。</p>

<p>Binder利用链式形成一套独具语义的DSL，如：</p>

<ul>
<li>基本配置：binder.bind(serviceClass).to(implClass).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>无base类、接口配置：binder.bind(implClass).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>service实例配置：binder.bind(serviceClass).toInstance(servieInstance).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>多个实例按名注入：binder.bind(serviceClass).annotatedWith(Names.named(&ldquo;name&rdquo;)).to(implClass).in(Scopes.[SINGLETON | NO_SCOPE]);</li>
<li>运行时注入：利用@Provides标注注入方法，相当于spring的@Bean。</li>
<li>@ImplementedBy：或者在实现接口之上标注@ImplementedBy指定其实现类。这种方式有点反OO设计，抽象不该知道其实现类。</li>
</ul>


<p>对于上面的配置在注入的方式仅仅需要@Inject标注，但对于按名注入需要在参数前边加入@Named标注，如：</p>

<pre><code>public void configure() {
    final Binder binder = binder();

    //TODO: bind named instance;
    binder.bind(NamedService.class).annotatedWith(Names.named("impl1")).to(NamedServiceImpl1.class);
    binder.bind(NamedService.class).annotatedWith(Names.named("impl2")).to(NamedServiceImpl2.class);
}

@Inject
public List&lt;NamedService&gt; getAllItemServices(@Named("impl1") NamedService nameService1,
                                                 @Named("impl2") NamedService nameService2) {
}
</code></pre>

<p>Guice也可以利用@Provides标注注入方法来运行时注入：如</p>

<pre><code>@Provides
public List&lt;NamedService&gt; getAllItemServices(@Named("impl1") NamedService nameService1,
                                             @Named("impl2") NamedService nameService2) {
    final ArrayList&lt;NamedService&gt; list = new ArrayList&lt;NamedService&gt;();
    list.add(nameService1);
    list.add(nameService2);
    return list;
}
</code></pre>

<h2>Guice实例</h2>

<p>下面是一个Guice module的实例代码：包含大部分常用依赖配置方式。更多代码参见<a href="https://github.com/greengerong/guice-demo">github </a>.</p>

<pre><code>package com.github.greengerong.app;

/**
 * ***************************************
 * *
 * Auth: green gerong                     *
 * Date: 2014                             *
 * blog: http://greengerong.github.io/    *
 * github: https://github.com/greengerong *
 * *
 * ****************************************
 */
public class AppModule extends AbstractModule {
    private static final Logger LOGGER = LoggerFactory.getLogger(AppModule.class);
    private final BundleContext bundleContext;

    public AppModule(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
        LOGGER.info(String.format("enter app module with: %s", bundleContext));
    }

    @Override
    public void configure() {
        final Binder binder = binder();
        //TODO: bind interface
        binder.bind(ItemService.class).to(ItemServiceImpl.class).in(SINGLETON);
        binder.bind(OrderService.class).to(OrderServiceImpl.class).in(SINGLETON);
        //TODO: bind self class(without interface or base class)
        binder.bind(PriceService.class).in(Scopes.SINGLETON);


        //TODO: bind instance not class.
        binder.bind(RuntimeService.class).toInstance(new RuntimeService());

        //TODO: bind named instance;
        binder.bind(NamedService.class).annotatedWith(Names.named("impl1")).to(NamedServiceImpl1.class);
        binder.bind(NamedService.class).annotatedWith(Names.named("impl2")).to(NamedServiceImpl2.class);
    }

    @Provides
    public List&lt;NamedService&gt; getAllItemServices(@Named("impl1") NamedService nameService1,
                                                 @Named("impl2") NamedService nameService2) {
        final ArrayList&lt;NamedService&gt; list = new ArrayList&lt;NamedService&gt;();
        list.add(nameService1);
        list.add(nameService2);
        return list;
    }
}
</code></pre>

<h2>Guice的使用</h2>

<p>对于Guice的使用则比较简单，利用利用Guice module初始化Guice创建其injector，如：</p>

<pre><code>Injector injector = Guice.createInjector(new AppModule(bundleContext));
</code></pre>

<p>这里可以传入多个module，我们可以利用module分离领域依赖。</p>

<p>Guice api方法：</p>

<pre><code>public static Injector createInjector(Module... modules) 

public static Injector createInjector(Iterable&lt;? extends Module&gt; modules) 

public static Injector createInjector(Stage stage, Module... modules)

public static Injector createInjector(Stage stage, Iterable&lt;? extends Module&gt; modules) 
</code></pre>

<p>Guice同时也支持不同Region配置，上面的State重载，state支持 TOOL,DEVELOPMENT,PRODUCTION选项;默认为DEVELOPMENT环境。</p>

<h2>后续</h2>

<p>本文Guice更全的demo代码请参见<a href="https://github.com/greengerong/guice-demo">github </a>.</p>

<p>Guice还有很多的扩展如AOP，同一个服务多个实例注入set，map，OSGI，UOW等扩展，请参见<a href="https://github.com/google/guice/wiki">Guice wiki</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/27/guava-eventbus/">Guava - EventBus(事件总线)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-27T21:49:40+08:00" pubdate data-updated="true">Nov 27<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/27/guava-eventbus/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Guava在<a href="http://code.google.com/p/guava-libraries/">guava-libraries</a>中为我们提供了事件总线EventBus库，它是事件发布订阅模式的实现，让我们能在领域驱动设计(DDD)中以事件的弱引用本质对我们的模块和领域边界很好的解耦设计。</p>

<p>不再多的废话，直奔Guava EventBus主题。首先Guava为我们提供了同步事件EventBus和异步实现AsyncEventBus两个事件总线，他们都不是单例的，官方理由是并不想我们我们的使用方式。当然如果我们想其为单例，我们可以很容易封装它，一个单例模式保证只创建一个实例就对了。</p>

<p>下面将以EventBus为例，AsyncEventBus使用方式与其一致的。</p>

<h4>订阅</h4>

<p>首先EventBus为我们提供了register方法来订阅事件，Guava在这里的实现很友好，我们不需要实现任何的额外接口或者base类，只需要在订阅方法上标注上<strong>@Subscribe</strong>和保证<strong>只有一个输入参数</strong>的方法就可以搞定。这样对于简单的某些事件，我们甚至可以直接</p>

<pre><code>new Object() {

    @Subscribe
    public void lister(Integer integer) {
        System.out.printf("%d from int%n", integer);
    }
}
</code></pre>

<p>Guava发布的事件默认不会处理线程安全的，但我们可以标注@AllowConcurrentEvents来保证其线程安全</p>

<h4>发布</h4>

<p>对于事件源，则可以通过post方法发布事件。 正在这里对于Guava对于事件的发布，是依据上例中订阅方法的方法参数类型决定的，换而言之就是post传入的类型和其基类类型可以收到此事件。例如下例：</p>

<pre><code>final EventBus eventBus = new EventBus();
eventBus.register(new Object() {

    @Subscribe
    public void lister(Integer integer) {
        System.out.printf("%s from int%n", integer);
    }

    @Subscribe
    public void lister(Number integer) {
        System.out.printf("%s from Number%n", integer);
    }

    @Subscribe
    public void lister(Long integer) {
        System.out.printf("%s from long%n", integer);
    }
});

eventBus.post(1);
eventBus.post(1L);
</code></pre>

<p>在这里有    Integer，Long，与它们基类Number。我们发送一个整数数据的时候，或者Integer和Number的方法接收，而Long类型则Long类型和Number类型接受。</p>

<p>所以博主建议对于每类时间封装一个特定的事件类型是必要的。</p>

<h4>DeadEvent</h4>

<p>DeadEvent暂时不清楚怎么翻译更合意，它描述的是死亡事件，即没有没任何订阅者关心，没有被处理，以DeadEvent类型参数的方法表示.例如在上例中我们post一个Object类型，如下：</p>

<pre><code>final EventBus eventBus = new EventBus();
eventBus.register(new Object() {

    @Subscribe
    public void lister(DeadEvent event) {
        System.out.printf("%s=%s from dead events%n", event.getSource().getClass(), event.getEvent());
    }
});

eventBus.post(new Object());
</code></pre>

<p>更多Guava博文：</p>

<ol>
<li><a href="http://greengerong.github.io/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava &ndash; 并行编程Futures</a></li>
<li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/">Guava &ndash; EventBus(事件总线)</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava - 并行编程Futures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-21T20:41:30+08:00" pubdate data-updated="true">Nov 21<span>st</span>, 2014</time>
        
           | <a href="/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Guava为Java并行编程Future提供了很多有用扩展，其主要接口为ListenableFuture，并借助于Futures静态扩展。</p>

<p>继承至Future的ListenableFuture，允许我们添加回调函数在线程运算完成时返回值或者方法执行完成立即返回。</p>

<p>对ListenableFuture添加回调函数：</p>

<pre><code>Futures.addCallback(ListenableFuture&lt;V&gt;, FutureCallback&lt;V&gt;, Executor)
</code></pre>

<p>其中 FutureCallback<V>是一个包含onSuccess(V),onFailure(Throwable)的接口。</p>

<p>使用如：</p>

<pre><code>Futures.addCallback(ListenableFuture, new FutureCallback&lt;Object&gt;() {

    public void onSuccess(Object result) {
        System.out.printf("onSuccess with: %s%n", result);
    }

    public void onFailure(Throwable thrown) {
        System.out.printf("onFailure %s%n", thrown.getMessage());
    }
});
</code></pre>

<p>同时Guava中Futures对于Future扩展还有：</p>

<p>transform：对于ListenableFuture的返回值进行转换。</p>

<p>allAsList：对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。注：当其中一个Future失败或者取消的时候，将会进入失败或者取消。</p>

<p>successfulAsList：和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。</p>

<p>immediateFuture/immediateCancelledFuture： 立即返回一个待返回值的ListenableFuture。</p>

<p>makeChecked: 将ListenableFuture 转换成CheckedFuture。CheckedFuture 是一个ListenableFuture ，其中包含了多个版本的get 方法，方法声明抛出检查异常.这样使得创建一个在执行逻辑中可以抛出异常的Future更加容易</p>

<p>JdkFutureAdapters.listenInPoolThread(future): guava同时提供了将JDK Future转换为ListenableFuture的接口函数。</p>

<p>下边是一个对于Future的测试demo：</p>

<pre><code>@Test
public void should_test_furture() throws Exception {
    ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));

    ListenableFuture future1 = service.submit(new Callable&lt;Integer&gt;() {
        public Integer call() throws InterruptedException {
            Thread.sleep(1000);
            System.out.println("call future 1.");
            return 1;
        }
    });

    ListenableFuture future2 = service.submit(new Callable&lt;Integer&gt;() {
        public Integer call() throws InterruptedException {
            Thread.sleep(1000);
            System.out.println("call future 2.");
    //       throw new RuntimeException("----call future 2.");
            return 2;
        }
    });

    final ListenableFuture allFutures = Futures.allAsList(future1, future2);

    final ListenableFuture transform = Futures.transform(allFutures, new AsyncFunction&lt;List&lt;Integer&gt;, Boolean&gt;() {
        @Override
        public ListenableFuture apply(List&lt;Integer&gt; results) throws Exception {
            return Futures.immediateFuture(String.format("success future:%d", results.size()));
        }
    });

    Futures.addCallback(transform, new FutureCallback&lt;Object&gt;() {

        public void onSuccess(Object result) {
            System.out.println(result.getClass());
            System.out.printf("success with: %s%n", result);
        }

        public void onFailure(Throwable thrown) {
            System.out.printf("onFailure%s%n", thrown.getMessage());
        }
    });

    System.out.println(transform.get());
}
</code></pre>

<p>   官方资料主页：<a href="https://awk.so/@code.google.com!/p/guava-libraries/wiki/ListenableFutureExplained">https://awk.so/@code.google.com!/p/guava-libraries/wiki/ListenableFutureExplained</a></p>

<p>更多Guava博文：</p>

<ol>
<li><a href="http://greengerong.github.io/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava &ndash; 并行编程Futures</a></li>
<li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/">Guava &ndash; EventBus(事件总线)</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/">Nightmare基于phantomjs的自动化测试套件</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-20T18:58:15+08:00" pubdate data-updated="true">Nov 20<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天将介绍一款自动化测试套件名叫nightmare，他是一个基于phantomjs的测试框架，一个基于phantomjs之上为测试应用封装的一套high level API。其API以goto, refresh, click, type&hellip;等简单的常用e2e测试动作封装，使得其语义清晰，简洁。其官方在<a href="http://www.nightmarejs.org/">http://www.nightmarejs.org/</a>.</p>

<p>如果你的项目测试不需要想需求和测试人员理解，那么基于nightmare测试或许是一个好的选择，你的降低测试代码的成本，以及测试套件的部署。我们可以选择基于jasmine-node等作为测试套件集成。</p>

<p>安装nightmare：</p>

<pre><code>npm install nightmare
</code></pre>

<p>下面我们对比与远程phantomjs的对比：</p>

<p>原phantomjs的代码：</p>

<pre><code>phantom.create(function (ph) {
  ph.createPage(function (page) {
    page.open('http://yahoo.com', function (status) {
      page.evaluate(function () {
        var el =
          document.querySelector('input[title="Search"]');
        el.value = 'github nightmare';
      }, function (result) {
        page.evaluate(function () {
          var el = document.querySelector('.searchsubmit');
          var event = document.createEvent('MouseEvent');
          event.initEvent('click', true, false);
          el.dispatchEvent(event);
        }, function (result) {
          ph.exit();
        });
      });
    });
  });
});
</code></pre>

<p>nightmare代码：</p>

<pre><code>new Nightmare()
  .goto('http://yahoo.com')
  .type('input[title="Search"]', 'github nightmare')
  .click('.searchsubmit')
  .run();
</code></pre>

<p>一切显而易见，不用多说。</p>

<p>nightmare同时也支持插件方式抽取公用逻辑，以供复用和提高测试代码语意，如下例子：</p>

<pre><code>/**
 * Login to a Swiftly account.
 *
 * @param {String} email
 * @param {String} password
 */

exports.login = function(email, password){
  return function(nightmare) {
    nightmare
      .viewport(800, 1600)
      .goto('https://swiftly.com/login')
        .type('#username', email)
        .type('#password', password)
        .click('.button--primary')
      .wait();
  };
};
</code></pre>

<p>使用代码很简单：</p>

<pre><code>var Swiftly = require('nightmare-swiftly');
new Nightmare()
  .use(Swiftly.login(email, password))
  .use(Swiftly.task(instructions, uploads, path))
  .run();
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/17/typescript-classes/">TypeScript - Classes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-17T19:10:32+08:00" pubdate data-updated="true">Nov 17<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/17/typescript-classes/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/17/typescript-classes/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>简介</h2>

<p>JavaScript语言基于函数和原型链继承机制的方式构建可重用的组件。这对于OO方面编程来说显得比较笨拙。在下一代的JavaScript标准ECMAScript 6为我们提供了基于class base的OO设计方式。在TypeScript中我们也允许使用这种方式，TypeScript将编译为目前大多数浏览器能允许的普通Javascript代码，所以我们不用在等待ECMAScript 6的到来了。</p>

<h2>类</h2>

<p>我们先看一个关于class-base的实例：</p>

<pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

var greeter = new Greeter("world");
</code></pre>

<p>这种语法和我们先前在c#，java语言看见的很相似。在这里我们声明了一个Greeter的类，其中包含一个greeting的属性，构造函数，以及greet的方法。</p>

<p>你也许已经注意到了例子中的‘this’关键字，’this‘和java/C#一样代表对象实例的成员访问。</p>

<p>在最后一行我们利用‘new’关键字创建了一个Greeter的对象实例。这将会新建一个对象实例，并调用我们先前定义的构造函数初始化此对象。</p>

<h2>继承</h2>

<p>在TypeScript中我们可以使用我们常用的OO设计模式。当然对于OO设计最基本的是类型的继承(继承一个存在的类，复用存在的逻辑)，下例就是一个关于类继承的例子：</p>

<pre><code>class Animal {
    name:string;
    constructor(theName: string) { this.name = theName; }
    move(meters: number) {
        alert(this.name + " moved " + meters + "m.");
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move() {
        alert("Slithering...");
        super.move(5);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move() {
        alert("Galloping...");
        super.move(45);
    }
}

var sam = new Snake("Sammy the Python");
var tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
</code></pre>

<p>在这个案例中展示了TypeScript的OO继承方式，它和其他语言很相似。在TypeScript中我们采用‘extends’关键字来表示类的继承关系。在这里你可以看见 &lsquo;Horse&#8217;和&#8217;Snake&#8217;都是继承至&#8217;Animal&#8217;的子类实现。</p>

<p>在案例中也展示如何去重写父类的方法，在这里&#8217;Snake&#8217;和&#8217;Horse都各自创建了一个‘move’方法来重写父类&#8217;Animal&#8217;的‘move’方法，并和‘super’关键字来调用父类的方法。</p>

<h2>Private/Public访问限制</h2>

<h4>Public为默认行为</h4>

<p>你可能注意到了在上例中我们并没有用‘public’关键字去描述类的成员的访问级别让其可见。在C#这类语言中，我们必须显示的标注public关键字才能使得类的成员可见。但是在TypeScript中public为默认访问级别，而不是想c#一样private默认。</p>

<p>有时我们希望封装隐藏类的内部成员控制类成员的可见性，这个时候我们可以使用‘private’这类关键字来标示成员。如我们希望隐藏‘Animal’的name属性：</p>

<pre><code>class Animal {
    private name:string;
    constructor(theName: string) { this.name = theName; }
    move(meters: number) {
        alert(this.name + " moved " + meters + "m.");
    }
}
</code></pre>

<h4>理解private(私有)</h4>

<p>TypeScript有一个结构化的类型(或者鸭子类型)系统。在我们比较两个不同类型，我们不关心它们来自哪里，只关心对类型的每个成员的兼容性。一旦所有的成员都是兼容的，那么我们就认为这两个类型也是兼容的。</p>

<p>当类型检查系统比较两个‘private’成员时，将会认为是不同的对象。对于两个类型比较，当一个类型拥有私有成员的时候，那么另外一个类必须包含相同声明的私有变量(同一处声明，多为继承体现)。如下例：</p>

<pre><code>class Animal {
    private name:stringParameter properties;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name:string;
    constructor(theName: string) { this.name = theName; }   
}

var animal = new Animal("Goat");
var rhino = new Rhino();
var employee = new Employee("Bob");

animal = rhino;
animal = employee; //error: Animal and Employee are not compatible
</code></pre>

<p>在上例中我们有&#8217;Animal&#8217;和‘Rhino’两个类型，&#8217;Rhino&#8217;是‘Animal’的一个子类。同时我们也定义了一个 &lsquo;Employee&#8217;的类，它和‘Animal’类完全相同。我们分别创建了第三个类的对象，并相互赋值，结果&#8217;Animal&#8217;和&#8217;Rhino&#8217;继承关系，所以对于私有字段name在‘Animal’中具有相同的声明  &#8216;private name: string&#8217;，他们是兼容的。但对于&#8217;Employee&#8217;则各自声明了一个私有name字段，对于私有字段是不相同的，所以我们不能将employee赋值给animal对象，他们是不兼容的类型。</p>

<h4>参数属性(Parameter properties)</h4>

<p>访问限制关键字public&#8217;和&#8217;private也可以通过参数属性方式快捷初始化类成员字段，参数属性可以让我们一步创建类成员。下例是上例中我们去掉了‘theName’，利用‘private name: string’声明在构造函数参数上，它会为我们创建一个私有的name成员的同时初始化这个字段。</p>

<pre><code>class Animal {
    constructor(private name: string) { }
    move(meters: number) {
        alert(this.name + " moved " + meters + "m.");
    }
}
</code></pre>

<p>这里我们利用‘private’关键字为类创建了一个私有成员并初始化其值。对于public也类似。</p>

<h2>访问器(Accessors)</h2>

<p>TypeScript支持利用getters/setters来控制对成员的访问。让我们可以控制类的成员之间的访问方式。</p>

<p>下面演示如何转化普通的类为get/set方式，如下是没有get/set的方式：</p>

<pre><code>class Employee {
    fullName: string;
}

var employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>

<p>在这里我们允许任意的访问内部fullName成员。有时这可能不是我们所期望的。</p>

<p>在下边我们希望将其转化为在修改fullName的时候必须提供一个正确的passcode，使得不能任意修改此类name，如下：</p>

<pre><code>var passcode = "secret passcode";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            alert("Error: Unauthorized update of employee!");
        }
    }
}

var employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>

<p>这里我们在修改fullName属性的时候验证了passcode值，是否有权限修改。你可以尝试修改passcode的值，使其不匹配，观察下会发生什么问题？</p>

<p><strong>注意:</strong>访问器使用我们需要设置编译输出为ECMAScript 5。</p>

<h2>静态属性</h2>

<p>回到类主题，上面我们所描述都是关于如何创建类的实例成员。我们同样也可以创建类的静态成员，其可见性为类级访问。我们可以使用&#8217;static&#8217; 关键字标注类级成员。在下面的例子中表格原点对于所有表格都是通用的，所以我们可以用‘static’来定义类级成员。那么可以采用类名(Grid.)来访问访问该成员，类似于对象成员的&#8217;this.&lsquo;.</p>

<pre><code>class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        var xDist = (point.x - Grid.origin.x);
        var yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

var grid1 = new Grid(1.0);  // 1x scale
var grid2 = new Grid(5.0);  // 5x scale

alert(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
alert(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</code></pre>

<h2>高级特性</h2>

<h4>构造函数</h4>

<p>当我们在TypeScript中声明一个类的时候，有时可能会创建多种声明方式。首先类的实例方式：</p>

<pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

var greeter: Greeter;
greeter = new Greeter("world");
alert(greeter.greet());
</code></pre>

<p>这里“var greeter: Greeter”首先声明一个Greeter类的实例变量。这在很多OO语言中是很自然的方式。</p>

<p>同时也利用new关键字实例化了这个类的实例，并调用构造函数初始化该对象。下面我们可以看看同等的JavaScript将会如何去做：</p>

<pre><code>var Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return "Hello, " + this.greeting;
    };
    return Greeter;
})();

var greeter;
greeter = new Greeter("world");
alert(greeter.greet());
</code></pre>

<p>这里&#8217;var Greeter&#8217;被赋值构造函数，并利用‘new’调用了这个方法得到类的实例。同样我们的类也可以包含静态变量。我们可以这么认为所有的类都可以拥有实例和静态两种类型的成员。</p>

<p>让我们对上例稍微做一些修改：</p>

<pre><code>class Greeter {
    static standardGreeting = "Hello, there";
    greeting: string;
    greet() {
        if (this.greeting) {
            return "Hello, " + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

var greeter1: Greeter;
greeter1 = new Greeter();
alert(greeter1.greet());

var greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = "Hey there!";
var greeter2:Greeter = new greeterMaker();
alert(greeter2.greet());
</code></pre>

<p>这里‘greeter1’和上例工作很相似。我们初始化了‘Greeter’类，并调用此对象。其结果在上例已经看见。</p>

<p>接着，我们直接使用了类访问。首先我们定义了一个新的‘greeterMaker’的变量，这变量保持了Greeter类的类型信息，这里我们使用的是‘typeof Greeter’，这会返回Greeter自身的类类型信息。这个类型信息中会包含所以的静态成员信息和实例化对象的构造函数信息。然后通过‘new’ greeterMaker来创建一个Greeter的实例对象，在调用其方法greet。</p>

<h2>利用interface来使用class</h2>

<p>如上所述，类主要声明了类实例类型和构造函数两件事。因为类主要创建类型，所以我们可以在同一地方使用interface来替代它：</p>

<pre><code>class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

var point3d: Point3d = {x: 1, y: 2, z: 3};
</code></pre>

<p><strong>注意:</strong>TypeScript更准确说是为了类型检查的类型推断。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/13/typescript-interfaces/">TypeScript - Interfaces</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-13T21:49:25+08:00" pubdate data-updated="true">Nov 13<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/13/typescript-interfaces/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/13/typescript-interfaces/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>简介</h4>

<p>关注于数据值的 &lsquo;shape&#8217;的类型检查是TypeScript核心设计原则。这种模式有时被称为‘鸭子类型’或者‘结构子类型化’。 在TypeScript中接口interfaces的责任就是命名这些类型，而且还是你的代码之间或者是与外部项目代码的契约。</p>

<h2>初见Interface</h2>

<p>理解interface的最好办法，就是写个hello world程序：</p>

<pre><code>function printLabel(labelledObj: {label: string}) {
  console.log(labelledObj.label);
}

var myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
</code></pre>

<p>在这里类型检查系统会检查printLabel这个函数，printLabel函数要求传入一个包含一个label的字符串属性。上例可以了解我们传入的对象可以有多个属性，但是类型检查系统只会检查printLabel所要求的label属性是否满足其要求。</p>

<p>接下来我们可以进一步简化，声明一个interface来描述一个具有label字符串属性的对象：</p>

<pre><code>interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

var myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
</code></pre>

<p>接口LabelledValue描述了上例中printLabel的所要求的类型对象。它依然代表包含一个label的字符串属性。可以看见我们利用‘shape’(行)描述了printLabel的传入参数要求。</p>

<h2>可选的Properties</h2>

<p>有时不是所有定义在interface中的属性都是必须的。例如流行的&#8221;option bags&#8221;模式(option配置)，使用者可以之传入部分定制化属性。如下面“option bags”模式：</p>

<p>interface SquareConfig {
  color?: string;
  width?: number;
}</p>

<pre><code>function createSquare(config: SquareConfig): {color: string; area: number} {
  var newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

var mySquare = createSquare({color: "black"});
</code></pre>

<p>带有可选属性的interface定义和c#语言很相似，以&#8217;?&lsquo;紧跟类型后边表示。</p>

<p>interface的可选属性可以限制那些属性是可用的，这部分能得到类型检查，以及智能感知。例如下例：</p>

<pre><code>interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  var newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.collor;  // 类型检查系统能识别不正确的属性collor.
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

var mySquare = createSquare({color: "black"});  
</code></pre>

<h2>函数类型</h2>

<p>Interfaces为了描述对象能接收的数据形(shapes)的返回。对于interface不仅难呢过描述对象的属性，也能描述函数类型。</p>

<p>下面是定义的interface signature是一个接收两个string的输入参数，并返回boolean的函数类型：</p>

<pre><code>interface SearchFunc {
  (source: string, subString: string): boolean;
}
</code></pre>

<p>我也可以使用函数类型的interface去描述我们的数据。下面演示如何将一个相同类型的函数赋值给interface：</p>

<pre><code>var mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  var result = source.search(subString);
  if (result == -1) {
    return false;
  }
  else {
    return true;
  }
}
</code></pre>

<p>对于函数类型的interface，并不需要参数名的对应相同，如下例：</p>

<pre><code>var mySearch: SearchFunc;
mySearch = function(src: string, sub: string) {
  var result = src.search(sub);
  if (result == -1) {
    return false;
  }
  else {
    return true;
  }
}
</code></pre>

<p>对于函数参数的检查，会按照参数的顺序检查对应的类型是否匹配。同时也会检查函数的返回类型是否匹配，在这个函数我们期望返回boolean类型true/false， 如果返回的是numbers或者string，则类型检查系统会提示返回值类型不匹配。</p>

<h2>数组类型</h2>

<p>类似于函数类型，TypeScript也可以描述数组类型。在数组类型中有一个&#8217;index&#8217;类型其描述数组下标的类型，以及返回值类型描述每项的类型，如下：</p>

<pre><code>interface StringArray {
  [index: number]: string;
}

var myArray: StringArray;
myArray = ["Bob", "Fred"]
</code></pre>

<p>index的支持两种类型，分别是字符串和数值类型. 我们可以限制index的类型，同时也可以检查index项的返回值类型。</p>

<p>index的类型签名可以描述常用的数组或者是‘dictionary’（字典序）模式，这点会强制所有的属性都需要和其返回值匹配。下例中length属性不匹配这点，所以类型检查会给出一个错误：</p>

<pre><code>interface Dictionary {
  [index: string]: string;
  length: number;    // error, the type of 'length' is not a subtype of the indexer
} 
</code></pre>

<h2>Class类型</h2>

<h4>实现interface</h4>

<p>在C#和java中interface是很常使用的类型系统，其用来强制其实现类符合其契约。在TypeScript中同样也可以实现：</p>

<pre><code>interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>

<p>同样也可以在interface中实现函数类型的契约，并要求clas实现此函数。如下例的‘setTime’函数：</p>

<pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface  {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre>

<p>interface描述的的是class的公开(public)部分，而不是私有部分.</p>

<h4>类static/instance区别</h4>

<p>当使用类和接口的时候，我们需要知道类有两种类型：static(静态)部分和instance(实例)部分。如果尝试一个类去实现一个带有构造签名的interface，TypeScript类型检查会提示你错误。</p>

<pre><code>interface ClockInterface {
    new (hour: number, minute: number);
}

class Clock implements ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>

<p>这是因为一个类去实现接口的时候，只有instance(实例)的部分才会被检查。而构造函数属于静态部分，所以不会被类型检查。</p>

<p>相反你可以直接在类中实现这些(static)静态部分，如下例：</p>

<pre><code>interface ClockStatic {
    new (hour: number, minute: number);
}

class Clock  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}

var cs: ClockStatic = Clock;
var newClock = new cs(7, 30);
</code></pre>

<h4>interface的继承</h4>

<p>和类一样，接口也能集成其他的接口。这相当于复制接口的所有成员。接口的集成是的我们可以自由的抽象和分离到可重用的组件。</p>

<pre><code>interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

var square = &lt;Square&gt;{};
square.color = "blue";
square.sideLength = 10;
</code></pre>

<p>一个interface可以同时集成多个interface，实现多个接口成员的合并。</p>

<pre><code>interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

var square = &lt;Square&gt;{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>

<h2>混合式类型</h2>

<p>如前边提到的一样，在interface几乎可以描述JavaScript世界的一切对象。因为JavaScript是一个动态，灵活的脚本语言，所以偶尔也希望一个对象能够描述一些多个类型.</p>

<p>下面是一个混合式描述函数，对象以及额外属性的实例：</p>

<pre><code>interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

var c: Counter;
c(10);
c.reset();
c.interval = 5.0;
</code></pre>

<p>和第三方JavaScript库交互的时候，也许我们也会上面的模式来描述一个完整的类型。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/13/typescript-basic-types/">TypeScript - 基本类型系统</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-13T19:53:50+08:00" pubdate data-updated="true">Nov 13<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/13/typescript-basic-types/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/13/typescript-basic-types/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>对于程序来说我们需要基本的数据单元,如：numbers, strings, structures, boolean 等数据结构。在TypeScript中我们支持很多你所期望在JavaScript中所拥有的数据类型系统。</p>

<h4>Boolean</h4>

<p>在JavaScript和TypeScript中也具有最基本的逻辑断言值true/false，采用&#8217;boolean&#8217;类型。</p>

<pre><code>var isDone: boolean = false;
</code></pre>

<h4>Number</h4>

<p>如JavaScript，TypeScript所有的数值类型采用浮点型计数，其类型为‘number’。</p>

<pre><code>var height: number = 6;
</code></pre>

<h4>String</h4>

<p>在webpages的JavaScript或者服务端的应用程序最基本的功能就是处理文本数据。在其他语言中大多使用&#8217;string&#8217;去代表文本数据类型。TypeScript和JavaScript一样也是用双引号(&ldquo;)或者单引号包裹文本数据。</p>

<pre><code>var name: string = "bob";
    name = 'smith';
</code></pre>

<h4>Array</h4>

<p>在TypeScript中如JavaScript一样允许我们操结合操作。数组类型可以使用下边两种方式之一。</p>

<p>第一种方式，你可以在数据类型之后带上&#8217;[]&lsquo;:</p>

<pre><code>var list:number[] = [1, 2, 3];
</code></pre>

<p>第二种方式，也可以采用泛型的数组类型：</p>

<pre><code>var list:Array&lt;number&gt; = [1, 2, 3];
</code></pre>

<h4>Enum</h4>

<p>TypeScript为JavaScript新增了枚举这种标准的集合数据类型。和在c#中一样，枚举是为一组数值类型一组更友好的名称。</p>

<pre><code>enum Color {Red, Green, Blue};
var c: Color = Color.Green;
</code></pre>

<p>默认枚举类型其实数值从0开始，你可以可用手动设置某一个成员的数值。例如我们可以将上文的起始值定为1：</p>

<pre><code>enum Color {Red = 1, Green, Blue};
var c: Color = Color.Green;
</code></pre>

<p>或是手动设置全部的枚举成员：</p>

<pre><code>enum Color {Red = 1, Green = 2, Blue = 4};
var c: Color = Color.Green;
</code></pre>

<p>枚举类型可以和容易从一个数值类型获取对应枚举名称。例如我们有一个数值类型2，但不确认将匹配哪一个枚举成员，那么我们可以如下使用：</p>

<pre><code>enum Color {Red = 1, Green, Blue};
var colorName: string = Color[2];

alert(colorName);
</code></pre>

<h4>Any</h4>

<p>有时我们需要描述一些我们不知道的什么写进应用的动态数据类型，这可能来自第三方用户或者lib。在这里我们希望该数据不要加入TypeScript的类型检查,是的此值通过编译时检查。为此我们可以采用‘any’类型标注：</p>

<pre><code>var notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
</code></pre>

<p>‘any’类型是一种强大的兼容存在的JavaScript库的类型系统。他允许跳过TypeScript的编译时类型的检查。</p>

<p>&lsquo;any&#8217;类型对于我们只知道部分数据类型，但是不是所有的数据类型的类型系统。如一个混合了多种类型的集合数组。</p>

<pre><code>var list:any[] = [1, true, "free"];

list[1] = 100;
</code></pre>

<h4>Void</h4>

<p>和‘any’相对的数据类型则是’Void‘，它代表没有任何数据类型。我们常用的一个方法没有任何返回值：</p>

<pre><code>function warnUser(): void {
    alert("This is my warning message");
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/12/vsftpd-refusing-to-run-with-writable-root-inside-chroot/">Vsftpd Refusing to Run With Writable Root Inside Chroot</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-12T19:38:05+08:00" pubdate data-updated="true">Nov 12<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/12/vsftpd-refusing-to-run-with-writable-root-inside-chroot/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/12/vsftpd-refusing-to-run-with-writable-root-inside-chroot/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="images/blog_img/vsftpd.jpg" alt="vsftpd" /></p>

<p>今天记录一个在安装vsftpd的时候遇见错误：</p>

<pre><code>500 OOPS: vsftpd: refusing to run with writable root inside chroot ()
</code></pre>

<p>在一阵的外文查找，最后定为到是因为用户的根目录可写，并且使用了chroot限制，而这在最近的更新里是不被允许的。要修复这个错误，可以用命令chmod a-w /home/$user去除用户根目录的写权限,或者在vsftpd。conf配置允许writeable。</p>

<p>设置允许writeable为：</p>

<pre><code>allow_writeable_chroot=YES
</code></pre>

<p>最简单的方式就是允许writeable。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/12/mockito-custom-verify-matcher/">Mockito自定义verify参数Matcher</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-12T13:53:13+08:00" pubdate data-updated="true">Nov 12<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/11/12/mockito-custom-verify-matcher/#disqus_thread"
             data-disqus-identifier="http://greengerong.github.io/blog/2014/11/12/mockito-custom-verify-matcher/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在TDD开发中，也许我们会遇见对一些重要的无返回值的行为测试，比如在用户的积分DB中增加用户的积分，这个行为对于我们的业务具有重要的价值，所以我们也希望能测试覆盖这部分业务价值。这个时候我们就得使用mockito带来的verify断言，但verify的参数断言主要有eq，或者any常见的方式。有时我们也希望能够断言对象的一部分属性，比如上文的积分数值，对于不同的场景增加的用户积分可能不同。</p>

<p>回到Mockito的参数Matcher，Mockito给我们提供了ArgumentMatcher，以供我们来扩展Matcher。下面假设一个增加用户积分的场景：</p>

<pre><code>     public class Game {
        private String type;
        private int rate;

        public Game(String type, int rate) {
            this.type = type;
            this.rate = rate;
        }

        public String getType() {
            return type;
        }

        public int getRate() {
            return rate;
        }

    }

    public class GameDao {
        public void addRate(Game game) {
            //TODO: insert to db
        }
    }
</code></pre>

<p>我们希望能够对verify GameDao调用了addRate，并且是积分rate为特定值。</p>

<p>所以我们可以扩展Mockito的ArgumentMatcher：</p>

<pre><code>public class PartyMatcher&lt;T&gt; extends ArgumentMatcher&lt;T&gt; {
    private Object value;
    private Function&lt;T, Object&gt; function;

    public PartyMatcher(Function&lt;T, Object&gt; getProperty, Object value) {
        this.value = value;
        this.function = getProperty;
    }

    public static &lt;F&gt; PartyMatcher&lt;F&gt; partyMatcher(Function&lt;F, Object&gt; getProperty, Object value) {
        return new PartyMatcher&lt;F&gt;(getProperty, value);
    }

    @Override
    public boolean matches(Object o) {
        return function.apply((T) o).equals(value);
    }
}
</code></pre>

<p>所以我们的测试可以如下：</p>

<pre><code>    @Test
    public void should_run_customer_mockito_matcher() throws Exception {

        final GameDao gameDao = mock(GameDao.class);
        gameDao.addRate(new Game("签到", 7));

        verify(gameDao).addRate(argThat(new PartyMatcher&lt;Game&gt;(new Function&lt;Game, Object&gt;() {
            @Override
            public Object apply(Game game) {
                return game.getRate();
            }
        }, 7)));

        verify(gameDao).addRate(argThat(new PartyMatcher&lt;Game&gt;(new Function&lt;Game, Object&gt;() {
            @Override
            public Object apply(Game game) {
                return game.getType();
            }
        }, "签到")));
    }
</code></pre>

<p>Mockito给我们提供了很多关于Matcher扩展的方法，本文只是ArgumentMatcher的实例。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>破 狼</h1>
  <p>    那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息。 那一月，我转过所有经轮，不为超度，只为触摸你的指纹。 那一年，我磕长头拥抱尘埃，不为朝佛，只为贴着了你的温暖。 那一世，我翻遍十万大山，不为修来世，只为路中能与你相遇。 那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。<a href="http://greengerong.github.io/blog/2009/12/24/cang-yang-jia-cuo-na-yi-tian-na-yi-yue-na-yi-nian-na-yi-shi/">《那一天，那一月，那一年，那一世》&#8211;仓央嘉措。</a></p>
</section>
<section>
  <p style="align: center"><a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3158890&amp;c=9476983" alt="count web site visits"/></a></p>
</section>
<section>
<h1>博客友情链接</h1>
  <ul>
    <li><a href="http://www.cnblogs.com/whitewolf/">博客园-破狼</a></li>
    <li><a href="http://whitewolfblog.blog.51cto.com/">51CTO&#8211;破狼</a></li>
    <li><a href="http://www.davenkin.me/">无知者云</a></li>
    <li><a href="http://agiledon.github.io/">简单文本</a></li>
  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/05/tddsui-xiang-lu/">TDD随想录</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/10/light-ioc-guice-framework/">java轻量级IOC框架Guice</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/27/guava-eventbus/">Guava - EventBus(事件总线)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/21/guava-bing-xing-bian-cheng-futures/">Guava - 并行编程Futures</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/20/nightmareji-yu-phantomjsde-zi-dong-hua-ce-shi-tao-jian/">Nightmare基于phantomjs的自动化测试套件</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/17/typescript-classes/">TypeScript - Classes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/typescript-interfaces/">TypeScript - Interfaces</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/typescript-basic-types/">TypeScript - 基本类型系统</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/greengerong">@greengerong</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'greengerong',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 破 狼 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'greengerong';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
